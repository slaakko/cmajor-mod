// =================================
// Copyright (c) 2024 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Windows;

namespace spring
{
    enum EndPointKind
    {
        source, target
    }

    class EndPoint
    {
        public EndPoint() : this(null, Connector(), PointF())
        {
        }
        public EndPoint(DiagramElement* element_, const Connector& connector_, const PointF& point_) :
            element(element_),
            connector(connector_),
            point(point_),
            primaryTextElement(new TextElement("primaryText")),
            secondaryTextElement(new TextElement("secondaryText")),
            index(-1)
        {
        }
        public inline DiagramElement* Element() const
        {
            return element;
        }
        public void SetElement(DiagramElement* element_)
        {
            element = element_;
        }
        public inline Connector& GetConnector() const
        {
            return connector;
        }
        public void SetConnector(const Connector& connector_)
        {
            connector = connector_;
        }
        public inline const PointF& Point() const
        {
            return point;
        }
        public void SetPoint(const PointF& point_)
        {
            point = point_;
        }
        public inline TextElement* PrimaryTextElement() const
        {
            return primaryTextElement;
        }
        public inline TextElement* SecondaryTextElement() const
        {
            return secondaryTextElement;
        }
        public inline int Index() const
        {
            return index;
        }
        [nodiscard]
        public Result<bool> SetIndex(const Map<ContainerElement*, int>& containerElementIndexMap)
        {
            if (element != null)
            {
                ContainerElement* containerElement = element->GetContainerElement();
                auto it = containerElementIndexMap.Find(containerElement);
                if (it != containerElementIndexMap.End())
                {
                    index = it->second;
                }
                else
                {
                    auto errorId = AllocateError("EndPoint.SetIndex: index for container element '" + containerElement->Name() + "' not found");
                    return Result<bool>(ErrorId(errorId));
                }
            }
            else
            {
                index = -1;
            }
            return Result<bool>(true);
        }
        private DiagramElement* element;
        private Connector connector;
        private PointF point;
        private TextElement* primaryTextElement;
        private TextElement* secondaryTextElement;
        private int index;
    }

    class EndPointNearer : Rel<EndPoint*>
    {
        public EndPointNearer(const PointF& location_) : location(location_)
        {
        }
        public inline bool operator()(EndPoint* left, EndPoint* right) const
        {
            return Distance(left->Point(), location) < Distance(right->Point(), location);
        }
        private PointF location;
    }
}
