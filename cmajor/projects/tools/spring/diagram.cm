// =================================
// Copyright (c) 2024 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Windows;

namespace spring
{
    enum DiagramFlags
    {
        none, changed = 1 << 0, invalidated = 1 << 1, modified = 1 << 2
    }

    class Diagram
    {
        public Diagram() : flags(DiagramFlags.none), canvas(null), operation(new EmptyOperation(this)), selection(new EmptySelection(this)), errorId(0)
        {
        }
        [nodiscard]
        public Result<bool> Draw(Graphics& graphics)
        {
            if (Changed())
            {
                ResetChanged();
                Configuration.Instance().GetLayout()->SetGraphics(&graphics);
                for (const auto& element : elements)
                {
                    auto result = element->Measure(graphics);
                    if (result.Error()) return result;
                }
            }
            if (Invalidated())
            {
                ResetInvalidated();
            }
            List<DiagramElement*> relationshipElements;
            for (const auto& element : elements)
            {
                if (element->IsContainerElement())
                {
                    auto result = element->Draw(graphics);
                    if (result.Error()) return result;
                }
                else if (element->IsRelationshipElement())
                {
                    relationshipElements.Add(element.Get());
                }
            }
            for (DiagramElement* relationshipElement : relationshipElements)
            {
                auto result = relationshipElement->Draw(graphics);
                if (result.Error()) return result;
            }
            auto result = operation->Draw(graphics);
            if (result.Error()) return result;
            selection->Draw(graphics);
            return Result<bool>(true);
        }
        public inline bool Changed() const
        {
            return (flags & DiagramFlags.changed) != DiagramFlags.none;
        }
        [nodiscard]
        public Result<bool> SetChanged()
        {
            if (!Changed())
            {
                flags = cast<DiagramFlags>(flags | DiagramFlags.changed);
                auto result = SetModified();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        public void ResetChanged()
        {
            flags = cast<DiagramFlags>(flags & ~DiagramFlags.changed);
        }
        public inline bool IsModified() const
        {
            return (flags & DiagramFlags.modified) != DiagramFlags.none;
        }
        [nodiscard]
        public Result<bool> SetModified()
        {
            flags = cast<DiagramFlags>(flags | DiagramFlags.modified);
            if (canvas != null)
            {
                StatusBarItem* modifiedStatusBarItem = canvas->ModifiedStatusBarItem();
                if (modifiedStatusBarItem != null)
                {
                    auto result = modifiedStatusBarItem->SetText("*");
                    if (result.Error()) return result;
                }
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> ResetModified()
        {
            if (IsModified())
            {
                flags = cast<DiagramFlags>(flags & ~DiagramFlags.modified);
                if (canvas != null)
                {
                    StatusBarItem* modifiedStatusBarItem = canvas->ModifiedStatusBarItem();
                    if (modifiedStatusBarItem != null)
                    {
                        auto result = modifiedStatusBarItem->SetText(" ");
                        if (result.Error()) return result;
                    }
                }
            }
            return Result<bool>(true);
        }
        public inline bool Invalidated() const
        {
            return (flags & DiagramFlags.invalidated) != DiagramFlags.none;
        }
        [nodiscard]
        public Result<bool> Invalidate()
        {
            if (!Invalidated())
            {
                flags = cast<DiagramFlags>(flags | DiagramFlags.invalidated);
                if (canvas != null)
                {
                    auto result = canvas->Invalidate();
                    if (result.Error()) return result;
                }
            }
            return Result<bool>(true);
        }
        public void ResetInvalidated()
        {
            flags = cast<DiagramFlags>(flags & ~DiagramFlags.invalidated);
        }
        public void SetCanvas(Canvas* canvas_)
        {
            canvas = canvas_;
        }
        public inline Canvas* GetCanvas() const
        {
            return canvas;
        }
        public inline CommandList& GetCommandList()
        {
            return commandList;
        }
        [nodiscard]
        public Result<bool> SetMenuItems(MenuItem* undoMenuItem, MenuItem* redoMenuItem)
        {
            auto result = commandList.SetMenuItems(undoMenuItem, redoMenuItem);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline Selection* GetSelection() const
        {
            return selection.Get();
        }
        [nodiscard]
        public Result<bool> SetSelection(Selection* selection_)
        {
            auto result = selection->Clear();
            if (result.Error()) return result;
            selection.Reset(selection_);
            if (!selection->IsEmpty())
            {
                auto result = EnableCopy();
                if (result.Error()) return result;
                result = EnableCut();
                if (result.Error()) return result;
            }
            else
            {
                auto result = DisableCopy();
                if (result.Error()) return result;
                result = DisableCut();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> ResetSelection()
        {
            auto result = selection->Clear();
            if (result.Error()) return result;
            result = DisposeContextMenu();
            if (result.Error()) return result;
            selection.Reset(new EmptySelection(this));
            result = DisableCopy();
            if (result.Error()) return result;
            result = DisableCut();
            if (result.Error()) return result;
            result = SetChanged();
            if (result.Error()) return result;
            result = Invalidate();
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> DeleteSelection()
        {
            if (!selection->IsEmpty())
            {
                auto result = selection->Delete();
                if (result.Error()) return result;
                result = ResetSelection();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        public inline Operation* GetOperation() const
        {
            return operation.Get();
        }
        public void SetOperation(Operation* operation_)
        {
            operation.Reset(operation_);
        }
        public void ResetOperation()
        {
            operation.Reset(new EmptyOperation(this));
        }
        [nodiscard]
        public Result<bool> EnableCopy()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                auto result = canvas->EnableCopy();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> EnableCut()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                auto result = canvas->EnableCut();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> DisableCopy()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                auto result = canvas->DisableCopy();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> DisableCut()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                auto result = canvas->DisableCut();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> AdvanceOperation(MouseArgs& mouseArgs)
        {
            if (operation->IsEmptyOperation()) return Result<bool>(true);
            auto result = operation->AdvanceTo(mouseArgs);
            if (result.Error()) return result;
            result = SetChanged();
            if (result.Error()) return result;
            result = Invalidate();
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> CommitOperation(MouseArgs& mouseArgs)
        {
            auto result = operation->Commit(mouseArgs);
            if (result.Error()) return result;
            ResetOperation();
            result = SetChanged();
            if (result.Error()) return result;
            result = Invalidate();
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> CancelOperation()
        {
            operation->Cancel();
            ResetOperation();
            auto result = Tools.Instance().SetCurrent(Tools.Instance().GetSelectTool());
            if (result.Error()) return result;
            result = SetChanged();
            if (result.Error()) return result;
            result = Invalidate();
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> DisposeContextMenu()
        {
            Window* window = canvas->GetWindow();
            auto result = window->RemoveContextMenu();
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> HideContextMenu()
        {
            Window* window = canvas->GetWindow();
            auto result = window->HideContextMenu();
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> Undo()
        {
            if (commandList.CanUndo())
            {
                auto result = commandList.Undo();
                if (result.Error()) return result;
                result = SetChanged();
                if (result.Error()) return result;
                result = Invalidate();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> Redo()
        {
            if (commandList.CanRedo())
            {
                auto result = commandList.Redo();
                if (result.Error()) return result;
                result = SetChanged();
                if (result.Error()) return result;
                result = Invalidate();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        public int NextIndex() const
        {
            return cast<int>(elements.Count());
        }
        public DiagramElement* GetElementByIndex(int index) const
        {
            return elements.Get(index);
        }
        public void SetElementByIndex(DiagramElement* element, int index)
        {
            elements.Set(index, element);
        }
        public int GetIndexOfElement(DiagramElement* element) const
        {
            int n = cast<int>(elements.Count());
            for (int i = 0; i < n; ++i)
            {
                if (elements.Get(i) == element)
                {
                    return i;
                }
            }
            return -1;
        }
        public int GetIndexOfElementAt(const PointF& location) const
        {
            spring.Contains<DiagramElement> pred(location);
            return IndexOf(elements, pred);
        }
        public bool HasIntersectingContainerElements(const RectF& rect) const
        {
            for (const auto& element : elements)
            {
                if (element->IsContainerElement())
                {
                    ContainerElement* containerElement = cast<ContainerElement*>(element.Get());
                    if (containerElement->IntersectsWith(rect)) return true;
                }
            }
            return false;
        }
        public int GetNumberOfIntersectingContainerElements(const RectF& rect) const
        {
            int count = 0;
            for (const auto& element : elements)
            {
                if (element->IsContainerElement())
                {
                    ContainerElement* containerElement = cast<ContainerElement*>(element.Get());
                    if (containerElement->IntersectsWith(rect))
                    {
                        ++count;
                    }
                }
            }
            return count;
        }
        public List<int> GetIntersectingContainerElementIndeces(const RectF& rect) const
        {
            List<int> indeces;
            int n = cast<int>(elements.Count());
            for (int i = 0; i < n; ++i)
            {
                DiagramElement* element = GetElementByIndex(i);
                if (element->IsContainerElement())
                {
                    ContainerElement* containerElement = cast<ContainerElement*>(element);
                    if (containerElement->IntersectsWith(rect))
                    {
                        indeces.Add(i);
                    }
                }
            }
            return indeces;
        }
        [nodiscard]
        public Result<bool> AddElement(DiagramElement* element)
        {
            elements.Add(element);
            element->SetDiagram(this);
            auto result = SetChanged();
            if (result.Error()) return result;
            result = Invalidate();
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public UniquePtr<DiagramElement> RemoveElementByIndex(int index)
        {
            return elements.Remove(index);
        }
        public void InsertElement(DiagramElement* element, int index)
        {
            elements.Insert(index, element);
        }
        public DiagramElement* ReleaseElementByIndex(int index)
        {
            return elements.Release(index);
        }
        public inline bool Error() const
        {
            return errorId != 0;
        }
        public inline int GetErrorId() const
        {
            return errorId;
        }
        public void SetErrorId(int errorId_)
        {
            errorId = errorId_;
        }
        public void ResetError()
        {
            errorId = 0;
        }
        private DiagramFlags flags;
        private Canvas* canvas;
        private CommandList commandList;
        private UniquePtr<Operation> operation;
        private UniquePtr<Selection> selection;
        private IndexList<DiagramElement> elements;
        private int errorId;
    }
}

