// =================================
// Copyright (c) 2024 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;

namespace cm.ast
{
    public class EmptyModuleId
    {
        public static const Uuid& Get() const
        {
            return emptyModuleId;
        }
        private static Uuid emptyModuleId;
    }

    public enum NodeType : byte
    {
        autoNode, boolNode, sbyteNode, byteNode, shortNode, ushortNode, intNode, uintNode, longNode, ulongNode, floatNode, doubleNode,
        charNode, wcharNode, ucharNode, voidNode, booleanLiteralNode, sbyteLiteralNode, byteLiteralNode, shortLiteralNode,
        ushortLiteralNode, intLiteralNode, uintLiteralNode, longLiteralNode, ulongLiteralNode, floatLiteralNode, doubleLiteralNode,
        charLiteralNode, wcharLiteralNode, ucharLiteralNode, stringLiteralNode, wstringLiteralNode, ustringLiteralNode,
        nullLiteralNode, arrayLiteralNode, structuredLiteralNode, sourceFileNode, namespaceNode, aliasNode, namespaceImportNode,
        identifierNode, templateIdNode, functionNode, classNode, thisInitializerNode, baseInitializerNode, memberInitializerNode,
        staticConstructorNode, constructorNode, destructorNode, memberFunctionNode, conversionFunctionNode, memberVariableNode,
        interfaceNode, delegateNode, classDelegateNode, parenthesizedConstraintNode, disjunctiveConstraintNode, conjunctiveConstraintNode,
        whereConstraintNode, predicateConstraintNode, isConstraintNode, multiParamConstraintNode, typeNameConstraintNode,
        constructorConstraintNode, destructorConstraintNode, memberFunctionConstraintNode, functionConstraintNode, sameConstraintNode,
        derivedConstraintNode, convertibleConstraintNode, explicitlyConvertibleConstraintNode, commonConstraintNode,
        nonreferenceTypeConstraintNode, axiomStatementNode, axiomNode, conceptIdNode, conceptNode, sameConceptNode, derivedConceptNode,
        convertibleConceptNode, explicitlyConvertibleConceptNode, commonConceptNode, nonreferenceTypeConceptNode, labelNode,
        compoundStatementNode, returnStatementNode, ifStatementNode, whileStatementNode, doStatementNode, forStatementNode,
        breakStatementNode, continueStatementNode, gotoStatementNode, constructionStatementNode, deleteStatementNode,
        destroyStatementNode, assignmentStatementNode, expressionStatementNode, emptyStatementNode, rangeForStatementNode,
        switchStatementNode, caseStatementNode, defaultStatementNode, gotoCaseStatementNode, gotoDefaultStatementNode,
        throwStatementNode, catchNode, tryStatementNode, assertStatementNode, typedefNode, constantNode, enumTypeNode,
        enumConstantNode, parameterNode, templateParameterNode, constNode, lvalueRefNode, rvalueRefNode, pointerNode, arrayNode,
        dotNode, arrowNode, equivalenceNode, implicationNode, disjunctionNode, conjunctionNode, bitOrNode, bitXorNode, bitAndNode,
        equalNode, notEqualNode, lessNode, greaterNode, lessOrEqualNode, greaterOrEqualNode, shiftLeftNode, shiftRightNode, addNode,
        subNode, mulNode, divNode, remNode, notNode, unaryPlusNode, unaryMinusNode, prefixIncrementNode, prefixDecrementNode, complementNode,
        derefNode, addrOfNode, isNode, asNode, indexingNode, invokeNode, postfixIncrementNode, postfixDecrementNode, sizeOfNode, typeNameNode,
        typeIdNode, castNode, constructNode, newNode, thisNode, baseNode, conditionalCompilationDisjunctionNode,
        conditionalCompilationConjunctionNode, conditionalCompilationNotNode, conditionalCompilationPrimaryNode, conditionalCompilationPartNode,
        conditionalCompilationStatementNode, uuidLiteralNode, parenthesizedExpressionNode, globalVariableNode,
        parenthesizedCondCompExpressionNode, labeledStatementNode, commentNode, functionPtrNode, syncNode, syncStatementNode,
        attributeNode, attributesNode, fullInstantiationRequestNode, argumentListNode, maxNode
    }

    public abstract class Node
    {
        public suppress Node(const Node&);
        public Node(NodeType nodeType_, const System.Lex.Span& span_, int fileIndex_) : nodeType(nodeType_), span(span_), fileIndex(fileIndex_), parent(null)
        {
        }
        public virtual ~Node()
        {
        }
        public suppress Node& operator=(const Node&);
        public inline NodeType GetNodeType() const
        {
            return nodeType;
        }
        public inline const System.Lex.Span& GetSpan() const
        {
            return span;
        }
        public inline void SetSpan(const System.Lex.Span& span_)
        {
            span = span_;
        }
        public inline int FileIndex() const
        {
            return fileIndex;
        }
        public inline const Node* Parent() const
        {
            return parent;
        }
        public inline Node* Parent()
        {
            return parent;
        }
        public inline void SetParent(Node* parent_)
        {
            parent = parent_;
        }
        public abstract Node* Clone(CloneContext& cloneContext) const;
        public abstract void Accept(Visitor& visitor);
        public virtual Result<string> ToString() const
        {
            return Result<string>(string());
        }
        public virtual void AddArgument(Node* argument)
        {
            Panic("AddArgument not overridden");
        }
        public virtual void AddParameter(ParameterNode* parameter)
        {
            Panic("AddParameter not overridden");
        }
        public virtual void AddTemplateParameter(TemplateParameterNode* templateParameter)
        {
            Panic("AddTemplateParameter not overridden");
        }
        public virtual bool IsUnsignedTypeNode() const
        {
            return false;
        }
        public virtual bool IsStatementNode() const
        {
            return false;
        }
        public virtual bool IsNodeConstraintNode() const
        {
            return false;
        }
        public virtual bool IsConceptNode() const
        {
            return false;
        }
        public virtual bool IsFunctionNode() const
        {
            return false;
        }
        public virtual bool IsIntrinsicConceptNode() const
        {
            return false;
        }
        public virtual bool IsConditionalCompilationExpressionNode() const
        {
            return false;
        }
        public virtual Specifiers GetSpecifiers() const
        {
            return Specifiers.none;
        }
        public virtual Result<bool> Write(AstWriter& writer)
        {
            return Result<bool>(true);
        }
        public virtual Result<bool> Read(AstReader& reader)
        {
            return Result<bool>(true);
        }
        public virtual const Uuid& ModuleId() const
        {
            if (parent != null)
            {
                return parent->ModuleId();
            }
            else
            {
                return EmptyModuleId.Get();
            }
        }
        public System.Lex.FullSpan GetFullSpan() const
        {
            return System.Lex.FullSpan(ModuleId(), FileIndex(), GetSpan());
        }
        private NodeType nodeType;
        private System.Lex.Span span;
        private int fileIndex;
        private Node* parent;
    }

    public abstract class UnaryNode : Node
    {
        public UnaryNode(NodeType nodeType_, const System.Lex.Span& span_, int fileIndex_) : base(nodeType_, span_, fileIndex_), subject()
        {
        }
        public UnaryNode(NodeType nodeType_, const System.Lex.Span& span_, int fileIndex_, Node* subject_) : base(nodeType_, span_, fileIndex_), subject(subject_)
        {
        }
        public inline const Node* Subject() const
        {
            return subject.Get();
        }
        public inline Node* Subject()
        {
            return subject.Get();
        }
        public override Result<bool> Write(AstWriter& writer)
        {
            auto result = base->Write(writer);
            if (result.Error())
            {
                return result;
            }
            return writer.Write(subject.Get());
        }
        public override Result<bool> Read(AstReader& reader)
        {
            auto result = base->Read(reader);
            if (result.Error())
            {
                return result;
            }
            auto subjectResult = reader.ReadNode();
            if (subjectResult.Error())
            {
                return Result<bool>(ErrorId(subjectResult.GetErrorId()));
            }
            subject.Reset(subjectResult.Value());
            subject->SetParent(this);
            return Result<bool>(true);
        }
        private UniquePtr<Node> subject;
    }

    public abstract class BinaryNode : Node
    {
        public BinaryNode(NodeType nodeType, const System.Lex.Span& span_, int fileIndex_) : base(nodeType, span_, fileIndex_), left(), right()
        {
        }
        public BinaryNode(NodeType nodeType, const System.Lex.Span& span_, int fileIndex_, Node* left_, Node* right_) :
            base(nodeType, span_, fileIndex_), left(left_), right(right_)
        {
            left->SetParent(this);
            right->SetParent(this);
        }
        public inline const Node* Left() const
        {
            return left.Get();
        }
        public inline Node* Left()
        {
            return left.Get();
        }
        public inline const Node* Right() const
        {
            return right.Get();
        }
        public inline Node* Right()
        {
            return right.Get();
        }
        public override Result<bool> Write(AstWriter& writer)
        {
            auto result = base->Write(writer);
            if (result.Error())
            {
                return result;
            }
            result = writer.Write(left.Get());
            if (result.Error())
            {
                return result;
            }
            return writer.Write(right.Get());
        }
        public override Result<bool> Read(AstReader& reader)
        {
            auto result = base->Read(reader);
            if (result.Error())
            {
                return result;
            }
            auto leftResult = reader.ReadNode();
            if (leftResult.Error())
            {
                return Result<bool>(ErrorId(leftResult.GetErrorId()));
            }
            left.Reset(leftResult.Value());
            left->SetParent(this);
            auto rightResult = reader.ReadNode();
            if (rightResult.Error())
            {
                return Result<bool>(ErrorId(rightResult.GetErrorId()));
            }
            right.Reset(rightResult.Value());
            right->SetParent(this);
            return Result<bool>(true);
        }
        private UniquePtr<Node> left;
        private UniquePtr<Node> right;
    }

    public abstract class NodeCreator
    {
        public suppress NodeCreator(const NodeCreator&);
        public NodeCreator()
        {
        }
        public virtual ~NodeCreator()
        {
        }
        public suppress NodeCreator& operator=(const NodeCreator&);
        public abstract Node* CreateNode(const System.Lex.Span& span, int fileIndex);
    }

    public class NodeFactory
    {
        static NodeFactory()
        {
            instance.Reset(new NodeFactory());
        }
        public suppress NodeFactory(const NodeFactory&);
        public NodeFactory()
        {
            creators.Resize(cast<long>(cast<byte>(NodeType.maxNode)));
            Register(NodeType.autoNode, new ConcreteNodeCreator<AutoNode>());
            Register(NodeType.boolNode, new ConcreteNodeCreator<BoolNode>());
            Register(NodeType.sbyteNode, new ConcreteNodeCreator<SByteNode>());
            Register(NodeType.byteNode, new ConcreteNodeCreator<ByteNode>());
            Register(NodeType.shortNode, new ConcreteNodeCreator<ShortNode>());
            Register(NodeType.ushortNode, new ConcreteNodeCreator<UShortNode>());
            Register(NodeType.intNode, new ConcreteNodeCreator<IntNode>());
            Register(NodeType.uintNode, new ConcreteNodeCreator<UIntNode>());
            Register(NodeType.longNode, new ConcreteNodeCreator<LongNode>());
            Register(NodeType.ulongNode, new ConcreteNodeCreator<ULongNode>());
            Register(NodeType.floatNode, new ConcreteNodeCreator<FloatNode>());
            Register(NodeType.doubleNode, new ConcreteNodeCreator<DoubleNode>());
            Register(NodeType.charNode, new ConcreteNodeCreator<CharNode>());
            Register(NodeType.wcharNode, new ConcreteNodeCreator<WCharNode>());
            Register(NodeType.ucharNode, new ConcreteNodeCreator<UCharNode>());
            Register(NodeType.voidNode, new ConcreteNodeCreator<VoidNode>());
            Register(NodeType.booleanLiteralNode, new ConcreteNodeCreator<BooleanLiteralNode>());
            Register(NodeType.sbyteLiteralNode, new ConcreteNodeCreator<SByteLiteralNode>());
            Register(NodeType.byteLiteralNode, new ConcreteNodeCreator<ByteLiteralNode>());
            Register(NodeType.shortLiteralNode, new ConcreteNodeCreator<ShortLiteralNode>());
            Register(NodeType.ushortLiteralNode, new ConcreteNodeCreator<UShortLiteralNode>());
            Register(NodeType.intLiteralNode, new ConcreteNodeCreator<IntLiteralNode>());
            Register(NodeType.uintLiteralNode, new ConcreteNodeCreator<UIntLiteralNode>());
            Register(NodeType.longLiteralNode, new ConcreteNodeCreator<LongLiteralNode>());
            Register(NodeType.ulongLiteralNode, new ConcreteNodeCreator<ULongLiteralNode>());
            Register(NodeType.floatLiteralNode, new ConcreteNodeCreator<FloatLiteralNode>());
            Register(NodeType.doubleLiteralNode, new ConcreteNodeCreator<DoubleLiteralNode>());
            Register(NodeType.charLiteralNode, new ConcreteNodeCreator<CharLiteralNode>());
            Register(NodeType.wcharLiteralNode, new ConcreteNodeCreator<WCharLiteralNode>());
            Register(NodeType.ucharLiteralNode, new ConcreteNodeCreator<UCharLiteralNode>());
            Register(NodeType.stringLiteralNode, new ConcreteNodeCreator<StringLiteralNode>());
            Register(NodeType.wstringLiteralNode, new ConcreteNodeCreator<WStringLiteralNode>());
            Register(NodeType.ustringLiteralNode, new ConcreteNodeCreator<UStringLiteralNode>());
            Register(NodeType.nullLiteralNode, new ConcreteNodeCreator<NullLiteralNode>());
            Register(NodeType.arrayLiteralNode, new ConcreteNodeCreator<ArrayLiteralNode>());
            Register(NodeType.structuredLiteralNode, new ConcreteNodeCreator<StructuredLiteralNode>());
            Register(NodeType.sourceFileNode, new ConcreteNodeCreator<SourceFileNode>());
            Register(NodeType.namespaceNode, new ConcreteNodeCreator<NamespaceNode>());
            Register(NodeType.aliasNode, new ConcreteNodeCreator<AliasNode>());
            Register(NodeType.namespaceImportNode, new ConcreteNodeCreator<NamespaceImportNode>());
            Register(NodeType.identifierNode, new ConcreteNodeCreator<IdentifierNode>());
            Register(NodeType.templateIdNode, new ConcreteNodeCreator<TemplateIdNode>());
            Register(NodeType.functionNode, new ConcreteNodeCreator<FunctionNode>());
            Register(NodeType.classNode, new ConcreteNodeCreator<ClassNode>());
            Register(NodeType.thisInitializerNode, new ConcreteNodeCreator<ThisInitializerNode>());
            Register(NodeType.baseInitializerNode, new ConcreteNodeCreator<BaseInitializerNode>());
            Register(NodeType.memberInitializerNode, new ConcreteNodeCreator<MemberInitializerNode>());
            Register(NodeType.staticConstructorNode, new ConcreteNodeCreator<StaticConstructorNode>());
            Register(NodeType.constructorNode, new ConcreteNodeCreator<ConstructorNode>());
            Register(NodeType.destructorNode, new ConcreteNodeCreator<DestructorNode>());
            Register(NodeType.memberFunctionNode, new ConcreteNodeCreator<MemberFunctionNode>());
            Register(NodeType.conversionFunctionNode, new ConcreteNodeCreator<ConversionFunctionNode>());
            Register(NodeType.memberVariableNode, new ConcreteNodeCreator<MemberVariableNode>());
            Register(NodeType.interfaceNode, new ConcreteNodeCreator<InterfaceNode>());
            Register(NodeType.delegateNode, new ConcreteNodeCreator<DelegateNode>());
            Register(NodeType.classDelegateNode, new ConcreteNodeCreator<ClassDelegateNode>());
            Register(NodeType.parenthesizedConstraintNode, new ConcreteNodeCreator<ParenthesizedConstraintNode>());
            Register(NodeType.disjunctiveConstraintNode, new ConcreteNodeCreator<DisjunctiveConstraintNode>());
            Register(NodeType.conjunctiveConstraintNode, new ConcreteNodeCreator<ConjunctiveConstraintNode>());
            Register(NodeType.whereConstraintNode, new ConcreteNodeCreator<WhereConstraintNode>());
            Register(NodeType.predicateConstraintNode, new ConcreteNodeCreator<PredicateConstraintNode>());
            Register(NodeType.isConstraintNode, new ConcreteNodeCreator<IsConstraintNode>());
            Register(NodeType.multiParamConstraintNode, new ConcreteNodeCreator<MultiParamConstraintNode>());
            Register(NodeType.typeNameConstraintNode, new ConcreteNodeCreator<TypeNameConstraintNode>());
            Register(NodeType.constructorConstraintNode, new ConcreteNodeCreator<ConstructorConstraintNode>());
            Register(NodeType.destructorConstraintNode, new ConcreteNodeCreator<DestructorConstraintNode>());
            Register(NodeType.memberFunctionConstraintNode, new ConcreteNodeCreator<MemberFunctionConstraintNode>());
            Register(NodeType.functionConstraintNode, new ConcreteNodeCreator<FunctionConstraintNode>());
            Register(NodeType.sameConstraintNode, new ConcreteNodeCreator<SameConstraintNode>());
            Register(NodeType.derivedConstraintNode, new ConcreteNodeCreator<DerivedConstraintNode>());
            Register(NodeType.convertibleConstraintNode, new ConcreteNodeCreator<ConvertibleConstraintNode>());
            Register(NodeType.explicitlyConvertibleConstraintNode, new ConcreteNodeCreator<ExplicitlyConvertibleConstraintNode>());
            Register(NodeType.commonConstraintNode, new ConcreteNodeCreator<CommonConstraintNode>());
            Register(NodeType.nonreferenceTypeConstraintNode, new ConcreteNodeCreator<NonreferenceTypeConstraintNode>());
            Register(NodeType.axiomStatementNode, new ConcreteNodeCreator<AxiomStatementNode>());
            Register(NodeType.axiomNode, new ConcreteNodeCreator<AxiomNode>());
            Register(NodeType.conceptIdNode, new ConcreteNodeCreator<ConceptIdNode>());
            Register(NodeType.conceptNode, new ConcreteNodeCreator<ConceptNode>());
            Register(NodeType.sameConceptNode, new ConcreteNodeCreator<SameConceptNode>());
            Register(NodeType.derivedConceptNode, new ConcreteNodeCreator<DerivedConceptNode>());
            Register(NodeType.convertibleConceptNode, new ConcreteNodeCreator<ConvertibleConceptNode>());
            Register(NodeType.explicitlyConvertibleConceptNode, new ConcreteNodeCreator<ExplicitlyConvertibleConceptNode>());
            Register(NodeType.commonConceptNode, new ConcreteNodeCreator<CommonConceptNode>());
            Register(NodeType.nonreferenceTypeConceptNode, new ConcreteNodeCreator<NonreferenceTypeConceptNode>());
            Register(NodeType.labelNode, new ConcreteNodeCreator<LabelNode>());
            Register(NodeType.labeledStatementNode, new ConcreteNodeCreator<LabeledStatementNode>());
            Register(NodeType.compoundStatementNode, new ConcreteNodeCreator<CompoundStatementNode>());
            Register(NodeType.returnStatementNode, new ConcreteNodeCreator<ReturnStatementNode>());
            Register(NodeType.ifStatementNode, new ConcreteNodeCreator<IfStatementNode>());
            Register(NodeType.whileStatementNode, new ConcreteNodeCreator<WhileStatementNode>());
            Register(NodeType.doStatementNode, new ConcreteNodeCreator<DoStatementNode>());
            Register(NodeType.forStatementNode, new ConcreteNodeCreator<ForStatementNode>());
            Register(NodeType.breakStatementNode, new ConcreteNodeCreator<BreakStatementNode>());
            Register(NodeType.continueStatementNode, new ConcreteNodeCreator<ContinueStatementNode>());
            Register(NodeType.gotoStatementNode, new ConcreteNodeCreator<GotoStatementNode>());
            Register(NodeType.constructionStatementNode, new ConcreteNodeCreator<ConstructionStatementNode>());
            Register(NodeType.deleteStatementNode, new ConcreteNodeCreator<DeleteStatementNode>());
            Register(NodeType.destroyStatementNode, new ConcreteNodeCreator<DestroyStatementNode>());
            Register(NodeType.assignmentStatementNode, new ConcreteNodeCreator<AssignmentStatementNode>());
            Register(NodeType.expressionStatementNode, new ConcreteNodeCreator<ExpressionStatementNode>());
            Register(NodeType.emptyStatementNode, new ConcreteNodeCreator<EmptyStatementNode>());
            Register(NodeType.rangeForStatementNode, new ConcreteNodeCreator<RangeForStatementNode>());
            Register(NodeType.switchStatementNode, new ConcreteNodeCreator<SwitchStatementNode>());
            Register(NodeType.caseStatementNode, new ConcreteNodeCreator<CaseStatementNode>());
            Register(NodeType.defaultStatementNode, new ConcreteNodeCreator<DefaultStatementNode>());
            Register(NodeType.gotoCaseStatementNode, new ConcreteNodeCreator<GotoCaseStatementNode>());
            Register(NodeType.gotoDefaultStatementNode, new ConcreteNodeCreator<GotoDefaultStatementNode>());
            Register(NodeType.throwStatementNode, new ConcreteNodeCreator<ThrowStatementNode>());
            Register(NodeType.catchNode, new ConcreteNodeCreator<CatchNode>());
            Register(NodeType.tryStatementNode, new ConcreteNodeCreator<TryStatementNode>());
            Register(NodeType.assertStatementNode, new ConcreteNodeCreator<AssertStatementNode>());
            Register(NodeType.typedefNode, new ConcreteNodeCreator<TypedefNode>());
            Register(NodeType.constantNode, new ConcreteNodeCreator<ConstantNode>());
            Register(NodeType.enumTypeNode, new ConcreteNodeCreator<EnumTypeNode>());
            Register(NodeType.enumConstantNode, new ConcreteNodeCreator<EnumConstantNode>());
            Register(NodeType.parameterNode, new ConcreteNodeCreator<ParameterNode>());
            Register(NodeType.templateParameterNode, new ConcreteNodeCreator<TemplateParameterNode>());
            Register(NodeType.constNode, new ConcreteNodeCreator<ConstNode>());
            Register(NodeType.lvalueRefNode, new ConcreteNodeCreator<LValueRefNode>());
            Register(NodeType.rvalueRefNode, new ConcreteNodeCreator<RValueRefNode>());
            Register(NodeType.pointerNode, new ConcreteNodeCreator<PointerNode>());
            Register(NodeType.dotNode, new ConcreteNodeCreator<DotNode>());
            Register(NodeType.arrowNode, new ConcreteNodeCreator<ArrowNode>());
            Register(NodeType.arrayNode, new ConcreteNodeCreator<ArrayNode>());
            Register(NodeType.equivalenceNode, new ConcreteNodeCreator<EquivalenceNode>());
            Register(NodeType.implicationNode, new ConcreteNodeCreator<ImplicationNode>());
            Register(NodeType.disjunctionNode, new ConcreteNodeCreator<DisjunctionNode>());
            Register(NodeType.conjunctionNode, new ConcreteNodeCreator<ConjunctionNode>());
            Register(NodeType.bitOrNode, new ConcreteNodeCreator<BitOrNode>());
            Register(NodeType.bitXorNode, new ConcreteNodeCreator<BitXorNode>());
            Register(NodeType.bitAndNode, new ConcreteNodeCreator<BitAndNode>());
            Register(NodeType.equalNode, new ConcreteNodeCreator<EqualNode>());
            Register(NodeType.notEqualNode, new ConcreteNodeCreator<NotEqualNode>());
            Register(NodeType.lessNode, new ConcreteNodeCreator<LessNode>());
            Register(NodeType.greaterNode, new ConcreteNodeCreator<GreaterNode>());
            Register(NodeType.lessOrEqualNode, new ConcreteNodeCreator<LessOrEqualNode>());
            Register(NodeType.greaterOrEqualNode, new ConcreteNodeCreator<GreaterOrEqualNode>());
            Register(NodeType.shiftLeftNode, new ConcreteNodeCreator<ShiftLeftNode>());
            Register(NodeType.shiftRightNode, new ConcreteNodeCreator<ShiftRightNode>());
            Register(NodeType.addNode, new ConcreteNodeCreator<AddNode>());
            Register(NodeType.subNode, new ConcreteNodeCreator<SubNode>());
            Register(NodeType.mulNode, new ConcreteNodeCreator<MulNode>());
            Register(NodeType.divNode, new ConcreteNodeCreator<DivNode>());
            Register(NodeType.remNode, new ConcreteNodeCreator<RemNode>());
            Register(NodeType.notNode, new ConcreteNodeCreator<NotNode>());
            Register(NodeType.unaryPlusNode, new ConcreteNodeCreator<UnaryPlusNode>());
            Register(NodeType.unaryMinusNode, new ConcreteNodeCreator<UnaryMinusNode>());
            Register(NodeType.prefixIncrementNode, new ConcreteNodeCreator<PrefixIncrementNode>());
            Register(NodeType.prefixDecrementNode, new ConcreteNodeCreator<PrefixDecrementNode>());
            Register(NodeType.complementNode, new ConcreteNodeCreator<ComplementNode>());
            Register(NodeType.derefNode, new ConcreteNodeCreator<DerefNode>());
            Register(NodeType.addrOfNode, new ConcreteNodeCreator<AddrOfNode>());
            Register(NodeType.isNode, new ConcreteNodeCreator<IsNode>());
            Register(NodeType.asNode, new ConcreteNodeCreator<AsNode>());
            Register(NodeType.indexingNode, new ConcreteNodeCreator<IndexingNode>());
            Register(NodeType.invokeNode, new ConcreteNodeCreator<InvokeNode>());
            Register(NodeType.postfixIncrementNode, new ConcreteNodeCreator<PostfixIncrementNode>());
            Register(NodeType.postfixDecrementNode, new ConcreteNodeCreator<PostfixDecrementNode>());
            Register(NodeType.sizeOfNode, new ConcreteNodeCreator<SizeOfNode>());
            Register(NodeType.typeNameNode, new ConcreteNodeCreator<TypeNameNode>());
            Register(NodeType.typeIdNode, new ConcreteNodeCreator<TypeIdNode>());
            Register(NodeType.castNode, new ConcreteNodeCreator<CastNode>());
            Register(NodeType.constructNode, new ConcreteNodeCreator<ConstructNode>());
            Register(NodeType.newNode, new ConcreteNodeCreator<NewNode>());
            Register(NodeType.thisNode, new ConcreteNodeCreator<ThisNode>());
            Register(NodeType.baseNode, new ConcreteNodeCreator<BaseNode>());
            Register(NodeType.conditionalCompilationDisjunctionNode, new ConcreteNodeCreator<ConditionalCompilationDisjunctionNode>());
            Register(NodeType.conditionalCompilationConjunctionNode, new ConcreteNodeCreator<ConditionalCompilationConjunctionNode>());
            Register(NodeType.conditionalCompilationNotNode, new ConcreteNodeCreator<ConditionalCompilationNotNode>());
            Register(NodeType.conditionalCompilationPrimaryNode, new ConcreteNodeCreator<ConditionalCompilationPrimaryNode>());
            Register(NodeType.conditionalCompilationPartNode, new ConcreteNodeCreator<ConditionalCompilationPartNode>());
            Register(NodeType.parenthesizedCondCompExpressionNode, new ConcreteNodeCreator<ParenthesizedConditionalCompilationExpressionNode>());
            Register(NodeType.conditionalCompilationStatementNode, new ConcreteNodeCreator<ConditionalCompilationStatementNode>());
            Register(NodeType.uuidLiteralNode, new ConcreteNodeCreator<UuidLiteralNode>());
            Register(NodeType.parenthesizedExpressionNode, new ConcreteNodeCreator<ParenthesizedExpressionNode>());
            Register(NodeType.globalVariableNode, new ConcreteNodeCreator<GlobalVariableNode>());
            Register(NodeType.commentNode, new ConcreteNodeCreator<CommentNode>());
            Register(NodeType.attributeNode, new ConcreteNodeCreator<AttributeNode>());
            Register(NodeType.attributesNode, new ConcreteNodeCreator<AttributesNode>());
            Register(NodeType.fullInstantiationRequestNode, new ConcreteNodeCreator<FullInstantiationRequestNode>());
        }
        public suppress NodeFactory& operator=(const NodeFactory&);
        public static NodeFactory& Instance()
        {
            return *instance;
        }
        public static UniquePtr<NodeFactory> instance;
        public void Register(NodeType nodeType, NodeCreator* creator)
        {
            creators[cast<long>(cast<byte>(nodeType))] = UniquePtr<NodeCreator>(creator);
        }
        public Node* CreateNode(NodeType nodeType, const System.Lex.Span& span, int fileIndex)
        {
            const UniquePtr<NodeCreator>& creator = creators[cast<long>(cast<byte>(nodeType))];
            if (!creator.IsNull())
            {
                Node* value = creator->CreateNode(span, fileIndex);
                if ((value != null))
                {
                    return value;
                }
                else
                {
                    Panic("could not create node");
                }
            }
            else
            {
                Panic("no creator for node type \'" + NodeTypeStr(nodeType) + "\'");
            }
            return null;
        }
        private List<UniquePtr<NodeCreator>> creators;
    }

    public class ConcreteNodeCreator<T> : NodeCreator
    {
        public ConcreteNodeCreator() : base()
        {
        }
        public suppress ConcreteNodeCreator(const ConcreteNodeCreator&);
        public suppress ConcreteNodeCreator& operator=(const ConcreteNodeCreator&);
        public override Node* CreateNode(const System.Lex.Span& span, int fileIndex)
        {
            return new T(span, fileIndex);
        }
    }
    public string NodeTypeStr(NodeType nodeType)
    {
        switch (nodeType)
        {
            case NodeType.autoNode: return "autoNode";
            case NodeType.boolNode: return "boolNode";
            case NodeType.sbyteNode: return "sbyteNode";
            case NodeType.byteNode: return "byteNode";
            case NodeType.shortNode: return "shortNode";
            case NodeType.ushortNode: return "ushortNode";
            case NodeType.intNode: return "intNode";
            case NodeType.uintNode: return "uintNode";
            case NodeType.longNode: return "longNode";
            case NodeType.ulongNode: return "ulongNode";
            case NodeType.floatNode: return "floatNode";
            case NodeType.doubleNode: return "doubleNode";
            case NodeType.charNode: return "charNode";
            case NodeType.wcharNode: return "wcharNode";
            case NodeType.ucharNode: return "ucharNode";
            case NodeType.voidNode: return "voidNode";
            case NodeType.booleanLiteralNode: return "booleanLiteralNode";
            case NodeType.sbyteLiteralNode: return "sbyteLiteralNode";
            case NodeType.byteLiteralNode: return "byteLiteralNode";
            case NodeType.shortLiteralNode: return "shortLiteralNode";
            case NodeType.ushortLiteralNode: return "ushortLiteralNode";
            case NodeType.intLiteralNode: return "intLiteralNode";
            case NodeType.uintLiteralNode: return "uintLiteralNode";
            case NodeType.longLiteralNode: return "longLiteralNode";
            case NodeType.ulongLiteralNode: return "ulongLiteralNode";
            case NodeType.floatLiteralNode: return "floatLiteralNode";
            case NodeType.doubleLiteralNode: return "doubleLiteralNode";
            case NodeType.charLiteralNode: return "charLiteralNode";
            case NodeType.wcharLiteralNode: return "wcharLiteralNode";
            case NodeType.ucharLiteralNode: return "ucharLiteralNode";
            case NodeType.stringLiteralNode: return "stringLiteralNode";
            case NodeType.wstringLiteralNode: return "wstringLiteralNode";
            case NodeType.ustringLiteralNode: return "ustringLiteralNode";
            case NodeType.nullLiteralNode: return "nullLiteralNode";
            case NodeType.arrayLiteralNode: return "arrayLiteralNode";
            case NodeType.structuredLiteralNode: return "structuredLiteralNode";
            case NodeType.sourceFileNode: return "sourceFileNode";
            case NodeType.namespaceNode: return "namespaceNode";
            case NodeType.aliasNode: return "aliasNode";
            case NodeType.namespaceImportNode: return "namespaceImportNode";
            case NodeType.identifierNode: return "identifierNode";
            case NodeType.templateIdNode: return "templateIdNode";
            case NodeType.functionNode: return "functionNode";
            case NodeType.classNode: return "classNode";
            case NodeType.thisInitializerNode: return "thisInitializerNode";
            case NodeType.baseInitializerNode: return "baseInitializerNode";
            case NodeType.memberInitializerNode: return "memberInitializerNode";
            case NodeType.staticConstructorNode: return "staticConstructorNode";
            case NodeType.constructorNode: return "constructorNode";
            case NodeType.destructorNode: return "destructorNode";
            case NodeType.memberFunctionNode: return "memberFunctionNode";
            case NodeType.conversionFunctionNode: return "conversionFunctionNode";
            case NodeType.memberVariableNode: return "memberVariableNode";
            case NodeType.interfaceNode: return "interfaceNode";
            case NodeType.delegateNode: return "delegateNode";
            case NodeType.classDelegateNode: return "classDelegateNode";
            case NodeType.parenthesizedConstraintNode: return "parenthesizedConstraintNode";
            case NodeType.disjunctiveConstraintNode: return "disjunctiveConstraintNode";
            case NodeType.conjunctiveConstraintNode: return "conjunctiveConstraintNode";
            case NodeType.whereConstraintNode: return "whereConstraintNode";
            case NodeType.predicateConstraintNode: return "predicateConstraintNode";
            case NodeType.isConstraintNode: return "isConstraintNode";
            case NodeType.multiParamConstraintNode: return "multiParamConstraintNode";
            case NodeType.typeNameConstraintNode: return "typeNameConstraintNode";
            case NodeType.constructorConstraintNode: return "constructorConstraintNode";
            case NodeType.destructorConstraintNode: return "destructorConstraintNode";
            case NodeType.memberFunctionConstraintNode: return "memberFunctionConstraintNode";
            case NodeType.functionConstraintNode: return "functionConstraintNode";
            case NodeType.sameConstraintNode: return "sameConstraintNode";
            case NodeType.derivedConstraintNode: return "derivedConstraintNode";
            case NodeType.convertibleConstraintNode: return "convertibleConstraintNode";
            case NodeType.explicitlyConvertibleConstraintNode: return "explicitlyConvertibleConstraintNode";
            case NodeType.commonConstraintNode: return "commonConstraintNode";
            case NodeType.nonreferenceTypeConstraintNode: return "nonreferenceTypeConstraintNode";
            case NodeType.axiomStatementNode: return "axiomStatementNode";
            case NodeType.axiomNode: return "axiomNode";
            case NodeType.conceptIdNode: return "conceptIdNode";
            case NodeType.conceptNode: return "conceptNode";
            case NodeType.sameConceptNode: return "sameConceptNode";
            case NodeType.derivedConceptNode: return "derivedConceptNode";
            case NodeType.convertibleConceptNode: return "convertibleConceptNode";
            case NodeType.explicitlyConvertibleConceptNode: return "explicitlyConvertibleConceptNode";
            case NodeType.commonConceptNode: return "commonConceptNode";
            case NodeType.nonreferenceTypeConceptNode: return "nonreferenceTypeConceptNode";
            case NodeType.labelNode: return "labelNode";
            case NodeType.compoundStatementNode: return "compoundStatementNode";
            case NodeType.returnStatementNode: return "returnStatementNode";
            case NodeType.ifStatementNode: return "ifStatementNode";
            case NodeType.whileStatementNode: return "whileStatementNode";
            case NodeType.doStatementNode: return "doStatementNode";
            case NodeType.forStatementNode: return "forStatementNode";
            case NodeType.breakStatementNode: return "breakStatementNode";
            case NodeType.continueStatementNode: return "continueStatementNode";
            case NodeType.gotoStatementNode: return "gotoStatementNode";
            case NodeType.constructionStatementNode: return "constructionStatementNode";
            case NodeType.deleteStatementNode: return "deleteStatementNode";
            case NodeType.destroyStatementNode: return "destroyStatementNode";
            case NodeType.assignmentStatementNode: return "assignmentStatementNode";
            case NodeType.expressionStatementNode: return "expressionStatementNode";
            case NodeType.emptyStatementNode: return "emptyStatementNode";
            case NodeType.rangeForStatementNode: return "rangeForStatementNode";
            case NodeType.switchStatementNode: return "switchStatementNode";
            case NodeType.caseStatementNode: return "caseStatementNode";
            case NodeType.defaultStatementNode: return "defaultStatementNode";
            case NodeType.gotoCaseStatementNode: return "gotoCaseStatementNode";
            case NodeType.gotoDefaultStatementNode: return "gotoDefaultStatementNode";
            case NodeType.throwStatementNode: return "throwStatementNode";
            case NodeType.catchNode: return "catchNode";
            case NodeType.tryStatementNode: return "tryStatementNode";
            case NodeType.assertStatementNode: return "assertStatementNode";
            case NodeType.typedefNode: return "typedefNode";
            case NodeType.constantNode: return "constantNode";
            case NodeType.enumTypeNode: return "enumTypeNode";
            case NodeType.enumConstantNode: return "enumConstantNode";
            case NodeType.parameterNode: return "parameterNode";
            case NodeType.templateParameterNode: return "templateParameterNode";
            case NodeType.constNode: return "constNode";
            case NodeType.lvalueRefNode: return "lvalueRefNode";
            case NodeType.rvalueRefNode: return "rvalueRefNode";
            case NodeType.pointerNode: return "pointerNode";
            case NodeType.arrayNode: return "arrayNode";
            case NodeType.dotNode: return "dotNode";
            case NodeType.arrowNode: return "arrowNode";
            case NodeType.equivalenceNode: return "equivalenceNode";
            case NodeType.implicationNode: return "implicationNode";
            case NodeType.disjunctionNode: return "disjunctionNode";
            case NodeType.conjunctionNode: return "conjunctionNode";
            case NodeType.bitOrNode: return "bitOrNode";
            case NodeType.bitXorNode: return "bitXorNode";
            case NodeType.bitAndNode: return "bitAndNode";
            case NodeType.equalNode: return "equalNode";
            case NodeType.notEqualNode: return "notEqualNode";
            case NodeType.lessNode: return "lessNode";
            case NodeType.greaterNode: return "greaterNode";
            case NodeType.lessOrEqualNode: return "lessOrEqualNode";
            case NodeType.greaterOrEqualNode: return "greaterOrEqualNode";
            case NodeType.shiftLeftNode: return "shiftLeftNode";
            case NodeType.shiftRightNode: return "shiftRightNode";
            case NodeType.addNode: return "addNode";
            case NodeType.subNode: return "subNode";
            case NodeType.mulNode: return "mulNode";
            case NodeType.divNode: return "divNode";
            case NodeType.remNode: return "remNode";
            case NodeType.notNode: return "notNode";
            case NodeType.unaryPlusNode: return "unaryPlusNode";
            case NodeType.unaryMinusNode: return "unaryMinusNode";
            case NodeType.prefixIncrementNode: return "prefixIncrementNode";
            case NodeType.prefixDecrementNode: return "prefixDecrementNode";
            case NodeType.complementNode: return "complementNode";
            case NodeType.derefNode: return "derefNode";
            case NodeType.addrOfNode: return "addrOfNode";
            case NodeType.isNode: return "isNode";
            case NodeType.asNode: return "asNode";
            case NodeType.indexingNode: return "indexingNode";
            case NodeType.invokeNode: return "invokeNode";
            case NodeType.postfixIncrementNode: return "postfixIncrementNode";
            case NodeType.postfixDecrementNode: return "postfixDecrementNode";
            case NodeType.sizeOfNode: return "sizeOfNode";
            case NodeType.typeNameNode: return "typeNameNode";
            case NodeType.typeIdNode: return "typeIdNode";
            case NodeType.castNode: return "castNode";
            case NodeType.constructNode: return "constructNode";
            case NodeType.newNode: return "newNode";
            case NodeType.thisNode: return "thisNode";
            case NodeType.baseNode: return "baseNode";
            case NodeType.conditionalCompilationDisjunctionNode: return "conditionalCompilationDisjunctionNode";
            case NodeType.conditionalCompilationConjunctionNode: return "conditionalCompilationConjunctionNode";
            case NodeType.conditionalCompilationNotNode: return "conditionalCompilationNotNode";
            case NodeType.conditionalCompilationPrimaryNode: return "conditionalCompilationPrimaryNode";
            case NodeType.conditionalCompilationPartNode: return "conditionalCompilationPartNode";
            case NodeType.conditionalCompilationStatementNode: return "conditionalCompilationStatementNode";
            case NodeType.uuidLiteralNode: return "uuidLiteralNode";
            case NodeType.parenthesizedExpressionNode: return "parenthesizedExpressionNode";
            case NodeType.globalVariableNode: return "globalVariableNode";
            case NodeType.parenthesizedCondCompExpressionNode: return "parenthesizedCondCompExpressionNode";
            case NodeType.labeledStatementNode: return "labeledStatementNode";
            case NodeType.commentNode: return "commentNode";
            case NodeType.attributeNode: return "attributeNode";
            case NodeType.attributesNode: return "attributesNode";
            case NodeType.fullInstantiationRequestNode: return "fullInstantiationRequestNode";
        }
        return string();
    }

} // namespace cm.ast
