// this file has been automatically generated from 'C:/work/cmajor-mod/cmajor/projects/tools/soulcm/cm.parser/fundamental_type.parser' using soul parser generator spg version 5.0.0

using System;
using System.Lex;
using System.Parsing;
using cm.ast;
using cm.token;

namespace cm.parser
{
    public static class FundamentalTypeParser<LexerT>
    {
        public static Result<System.Parsing.Match> FundamentalType(LexerT& lexer)
        {
            System.Lex.RuleGuard<LexerT> ruleGuard(lexer, 6112958198560325633);
            System.Parsing.Match match(false);
            long pos = lexer.GetPos();
            switch (*lexer)
            {
                case AUTO:
                {
                    auto incResult0 = ++lexer; 
                    if (incResult0.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult0.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.AutoNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case BOOL:
                {
                    auto incResult1 = ++lexer; 
                    if (incResult1.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult1.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.BoolNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case SBYTE:
                {
                    auto incResult2 = ++lexer; 
                    if (incResult2.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult2.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.SByteNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case BYTE:
                {
                    auto incResult3 = ++lexer; 
                    if (incResult3.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult3.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.ByteNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case SHORT:
                {
                    auto incResult4 = ++lexer; 
                    if (incResult4.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult4.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.ShortNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case USHORT:
                {
                    auto incResult5 = ++lexer; 
                    if (incResult5.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult5.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.UShortNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case INT:
                {
                    auto incResult6 = ++lexer; 
                    if (incResult6.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult6.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.IntNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case UINT:
                {
                    auto incResult7 = ++lexer; 
                    if (incResult7.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult7.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.UIntNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case LONG:
                {
                    auto incResult8 = ++lexer; 
                    if (incResult8.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult8.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.LongNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case ULONG:
                {
                    auto incResult9 = ++lexer; 
                    if (incResult9.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult9.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.ULongNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case FLOAT:
                {
                    auto incResult10 = ++lexer; 
                    if (incResult10.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult10.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.FloatNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case DOUBLE:
                {
                    auto incResult11 = ++lexer; 
                    if (incResult11.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult11.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.DoubleNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case CHAR:
                {
                    auto incResult12 = ++lexer; 
                    if (incResult12.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult12.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.CharNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case WCHAR:
                {
                    auto incResult13 = ++lexer; 
                    if (incResult13.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult13.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.WCharNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case UCHAR:
                {
                    auto incResult14 = ++lexer; 
                    if (incResult14.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult14.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.UCharNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
                case VOID:
                {
                    auto incResult15 = ++lexer; 
                    if (incResult15.Error())
                    {
                        return Result<System.Parsing.Match>(ErrorId(incResult15.GetErrorId()));
                    }
                    {
                        return Result<System.Parsing.Match>(System.Parsing.Match(true, new cm.ast.VoidNode(lexer.GetSpan(pos))));
                    }
                    break;
                }
            }
            if (!match.hit)
            {
                match.value = null;
            }
            return Result<System.Parsing.Match>(match);
        }
    }

    new class FundamentalTypeParser<CmajorLexer>;

} // namespace cm.parser
