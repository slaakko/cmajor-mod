// =================================
// Copyright (c) 2024 Seppo Laakko
// Distributed under the MIT license
// =================================

export module cm.parser;

import cm.ast;
import cm.token;

parser FundamentalTypeParser
{
    lexer CmajorLexer;

    FundamentalType : cm.ast.Node*
        ::= AUTO{ return new cm.ast.AutoNode(lexer.GetSpan(pos)); }
        |   BOOL{ return new cm.ast.BoolNode(lexer.GetSpan(pos)); }
        |   SBYTE{ return new cm.ast.SByteNode(lexer.GetSpan(pos)); }
        |   BYTE{ return new cm.ast.ByteNode(lexer.GetSpan(pos)); }
        |   SHORT{ return new cm.ast.ShortNode(lexer.GetSpan(pos)); }
        |   USHORT{ return new cm.ast.UShortNode(lexer.GetSpan(pos)); }
        |   INT{ return new cm.ast.IntNode(lexer.GetSpan(pos)); }
        |   UINT{ return new cm.ast.UIntNode(lexer.GetSpan(pos)); }
        |   LONG{ return new cm.ast.LongNode(lexer.GetSpan(pos)); }
        |   ULONG{ return new cm.ast.ULongNode(lexer.GetSpan(pos)); }
        |   FLOAT{ return new cm.ast.FloatNode(lexer.GetSpan(pos)); }
        |   DOUBLE{ return new cm.ast.DoubleNode(lexer.GetSpan(pos)); }
        |   CHAR{ return new cm.ast.CharNode(lexer.GetSpan(pos)); }
        |   WCHAR{ return new cm.ast.WCharNode(lexer.GetSpan(pos)); }
        |   UCHAR{ return new cm.ast.UCharNode(lexer.GetSpan(pos)); }
        |   VOID{ return new cm.ast.VoidNode(lexer.GetSpan(pos)); }
        ;
}