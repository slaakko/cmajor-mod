// =================================
// Copyright (c) 2024 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;

namespace intermediate
{
    public void Break()
    {
    }

    public enum OpCode : byte
    {
        store, arg, jmp, branch, procedure_call, ret, switch_,
        not_, neg, signextend, zeroextend, truncate, fpextend, bitcast, inttofloat, floattoint, inttoptr, ptrtoint,
        add, sub, mul, div_, mod, and_, or_, xor_, shl, shr, equal, less,
        param, local, load, elemaddr, ptroffset, ptrdiff, function_call,
        nop
    }

    inline public void AddInstToInstructionSet(Instruction* inst, List<Instruction*>& set)
    {
        if (Find(set.Begin(), set.End(), inst) == set.End())
        {
            set.Add(inst);
        }
    }

    inline public void RemoveInstFromInstructionSet(Instruction* inst, List<Instruction*>& set)
    {
        set.Remove(inst);
    }

    inline public void AddBasicBlockToBasicBlockSet(BasicBlock* bb, List<BasicBlock*>& set)
    {
        if (Find(set.Begin(), set.End(), bb) == set.End())
        {
            set.Add(bb);
        }
    }

    inline public void RemoveBasicBlockFromBasicBlockSet(BasicBlock* bb, List<BasicBlock*>& set)
    {
        set.Remove(bb);
    }

    public void AddUser(Instruction* user, Value* value)
    {
        if (value != null)
        {
            if (value->IsRegValue())
            {
                RegValue* regValue = cast<RegValue*>(value);
                if (regValue->Inst() != null)
                {
                    regValue->Inst()->AddUser(user);
                }
            }
        }
    }

    public void RemoveUser(Instruction* user, Value* value)
    {
        if (value != null)
        {
            if (value->IsRegValue())
            {
                RegValue* regValue = cast<RegValue*>(value);
                if (regValue->Inst() != null)
                {
                    regValue->Inst()->RemoveUser(user);
                }
            }
        }
    }

    public void AddToUsesList(List<Instruction*>& uses, Value* value)
    {
        if (value != null)
        {
            if (value->IsRegValue())
            {
                RegValue* regValue = cast<RegValue*>(value);
                if (regValue->Inst() != null)
                {
                    uses.Add(regValue->Inst());
                }
            }
        }
    }

    public string OpCodeStr(OpCode opCode)
    {
        switch (opCode)
        {
            case OpCode.store:
            {
                return "store";
            }
            case OpCode.arg:
            {
                return "arg";
            }
            case OpCode.jmp:
            {
                return "jmp";
            }
            case OpCode.branch:
            {
                return "branch";
            }
            case OpCode.procedure_call:
            {
                return "call";
            }
            case OpCode.ret:
            {
                return "ret";
            }
            case OpCode.switch_:
            {
                return "switch";
            }
            case OpCode.not_:
            {
                return "not";
            }
            case OpCode.neg:
            {
                return "neg";
            }
            case OpCode.signextend:
            {
                return "signextend";
            }
            case OpCode.zeroextend:
            {
                return "zeroextend";
            }
            case OpCode.truncate:
            {
                return "truncate";
            }
            case OpCode.fpextend:
            {
                return "fpextend";
            }
            case OpCode.bitcast:
            {
                return "bitcast";
            }
            case OpCode.inttofloat:
            {
                return "inttofloat";
            }
            case OpCode.floattoint:
            {
                return "floattoint";
            }
            case OpCode.inttoptr:
            {
                return "inttoptr";
            }
            case OpCode.ptrtoint:
            {
                return "ptrtoint";
            }
            case OpCode.add:
            {
                return "add";
            }
            case OpCode.sub:
            {
                return "sub";
            }
            case OpCode.mul:
            {
                return "mul";
            }
            case OpCode.div_:
            {
                return "div";
            }
            case OpCode.mod:
            {
                return "mod";
            }
            case OpCode.and_:
            {
                return "and";
            }
            case OpCode.or_:
            {
                return "or";
            }
            case OpCode.xor_:
            {
                return "xor";
            }
            case OpCode.shl:
            {
                return "shl";
            }
            case OpCode.shr:
            {
                return "shr";
            }
            case OpCode.equal:
            {
                return "equal";
            }
            case OpCode.less:
            {
                return "less";
            }
            case OpCode.param:
            {
                return "param";
            }
            case OpCode.local:
            {
                return "local";
            }
            case OpCode.load:
            {
                return "load";
            }
            case OpCode.elemaddr:
            {
                return "elemaddr";
            }
            case OpCode.ptroffset:
            {
                return "ptroffset";
            }
            case OpCode.ptrdiff:
            {
                return "ptrdiff";
            }
            case OpCode.function_call:
            {
                return "call";
            }
            case OpCode.nop:
            {
                return "nop";
            }
        }
        return "<unknown opcode>";
    }

    public class RegValue : Value
    {
        public RegValue(const System.Lex.Span& span_, Type* type_, int reg_) : base(ValueKind.regValue, span_, type_), reg(reg_), inst(null)
        {
            #assert(GetType() != null);
        }
        public ~RegValue()
        {
            if (inst != null && inst->IsValueInstruction())
            {
                ValueInstruction* valueInst = cast<ValueInstruction*>(inst);
                if (valueInst->GetResult() == this)
                {
                    valueInst->ResetResult();
                }
            }
        }
        public override string ToString() const
        {
            #assert(inst != null);
            return "$" + ToString(inst->RegValueIndex());
        }
        public override void Dump()
        {
            int instReg = -1;
            if (inst != null)
            {
                instReg = inst->RegValueIndex();
            }
            Console.Out() << "REG VALUE " << reg << "=" << instReg << " : " << cast<ulong>(this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            RegValue* regValue = cloneContext.CurrentFunction()->GetRegValue(reg);
            if (regValue != null)
            {
                return Result<Value*>(regValue);
            }
            Result<RegValue*> cloneResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), reg);
            if (cloneResult.Error()) return Result<Value*>(ErrorId(cloneResult.GetErrorId()));
            RegValue* clone = cloneResult.Value();
            Instruction* mappedInst = cloneContext.GetMappedInstruction(inst);
            if (mappedInst != null)
            {
                clone->SetInst(mappedInst);
            }
            else
            {
                cloneContext.AddUnmappedInstruction(inst, clone);
            }
            return Result<Value*>(clone);
        }
        public inline int Reg() const
        {
            return reg;
        }
        public inline void SetReg(int reg_)
        {
            reg = reg_;
        }
        public inline Instruction* Inst() const
        {
            return inst;
        }
        public inline void SetInst(Instruction* inst_)
        {
            #assert(this != null);
            inst = inst_;
        }
        private int reg;
        private Instruction* inst;
    }

    public abstract class Instruction : Component
    {
        public Instruction(const System.Lex.Span& span_, Type* type_, OpCode opCode_) :
            base(ValueKind.instruction, span_, type_), opCode(opCode_), index(-1), sourceLineNumber(0), regValueIndex(-1), assemblyIndex(-1)
        {
        }
        public bool IsLeader() const
        {
            BasicBlock* basicBlock = Parent();
            return this == basicBlock->Leader();
        }
        public string Name()
        {
            return OpCodeStr(opCode);
        }
        [nodiscard]
        public abstract Result<bool> Write(System.Text.CodeFormatter& formatter);
        [nodiscard]
        public Result<bool> WriteComment(System.Text.CodeFormatter& formatter)
        {
            Result<bool> result = formatter.Write(" // ");
            if (result.Error()) return result;
            result = formatter.Write(" line=");
            if (result.Error()) return result;
            result = formatter.Write(ToString(sourceLineNumber));
            if (result.Error()) return result;
            result = formatter.Write(", index=");
            if (result.Error()) return result;
            result = formatter.Write(ToString(index));
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline BasicBlock* Parent() const
        {
            #assert(GetContainer() != null);
            return cast<BasicBlock*>(GetContainer()->Parent());
        }
        public inline Instruction* Next() const
        {
            return cast<Instruction*>(NextSibling());
        }
        public inline Instruction* Prev() const
        {
            return cast<Instruction*>(PrevSibling());
        }
        public inline OpCode GetOpCode() const
        {
            return opCode;
        }
        public inline int Index() const
        {
            return index;
        }
        public inline void SetIndex(int index_)
        {
            index = index_;
        }
        public inline int SourceLineNumber() const
        {
            return sourceLineNumber;
        }
        public inline void SetSourceLineNumber(int sourceLineNumber_)
        {
            sourceLineNumber = sourceLineNumber_;
        }
        public inline int RegValueIndex() const
        {
            return regValueIndex;
        }
        public inline void SetRegValueIndex(int regValueIndex_)
        {
            regValueIndex = regValueIndex_;
        }
        public inline int AssemblyIndex() const
        {
            return assemblyIndex;
        }
        public inline void SetAssemblyIndex(int assemblyIndex_)
        {
            assemblyIndex = assemblyIndex_;
        }
        public inline const List<Instruction*>& Users() const
        {
            return users;
        }
        public List<StoreInstruction*> Stores() const
        {
            List<StoreInstruction*> stores;
            for (Instruction* user : users)
            {
                if (user->IsStoreInstruction())
                {
                    stores.Add(cast<StoreInstruction*>(user));
                }
            }
            return stores;
        }
        public List<LoadInstruction*> Loads() const
        {
            List<LoadInstruction*> loads;
            for (Instruction* user : users)
            {
                if (user->IsLoadInstruction())
                {
                    loads.Add(cast<LoadInstruction*>(user));
                }
            }
            return loads;
        }
        public List<ArgInstruction*> Args() const
        {
            List<ArgInstruction*> args;
            for (Instruction* user : users)
            {
                if (user->IsArgInstruction())
                {
                    args.Add(cast<ArgInstruction*>(user));
                }
            }
            return args;
        }
        public bool IsValueInstruction() const
        {
            switch (opCode)
            {
                case OpCode.not_:
                case OpCode.neg:
                case OpCode.signextend:
                case OpCode.zeroextend:
                case OpCode.fpextend:
                case OpCode.truncate:
                case OpCode.bitcast:
                case OpCode.inttofloat:
                case OpCode.floattoint:
                case OpCode.inttoptr:
                case OpCode.ptrtoint:
                case OpCode.add:
                case OpCode.sub:
                case OpCode.mul:
                case OpCode.div_:
                case OpCode.mod:
                case OpCode.and_:
                case OpCode.or_:
                case OpCode.xor_:
                case OpCode.shl:
                case OpCode.shr:
                case OpCode.equal:
                case OpCode.less:
                case OpCode.param:
                case OpCode.local:
                case OpCode.load:
                case OpCode.elemaddr:
                case OpCode.ptroffset:
                case OpCode.ptrdiff:
                case OpCode.function_call:
                {
                    return true;
                }
            }
            return false;
        }
        public bool IsUnaryInstruction()
        {
            switch (opCode)
            {
                case OpCode.not_:
                case OpCode.neg:
                case OpCode.signextend:
                case OpCode.zeroextend:
                case OpCode.fpextend:
                case OpCode.truncate:
                case OpCode.bitcast:
                case OpCode.inttofloat:
                case OpCode.floattoint:
                case OpCode.inttoptr:
                case OpCode.ptrtoint:
                {
                    return true;
                }
            }
            return false;
        }
        public bool IsBinaryInstruction()
        {
            switch (opCode)
            {
                case OpCode.add:
                case OpCode.sub:
                case OpCode.mul:
                case OpCode.div_:
                case OpCode.mod:
                case OpCode.and_:
                case OpCode.or_:
                case OpCode.xor_:
                case OpCode.shl:
                case OpCode.shr:
                case OpCode.equal:
                case OpCode.less:
                {
                    return true;
                }
            }
            return false;
        }
        public bool RequiresLocalRegister() const
        {
            switch (opCode)
            {
                case OpCode.arg:
                case OpCode.procedure_call:
                case OpCode.not_:
                case OpCode.neg:
                case OpCode.signextend:
                case OpCode.zeroextend:
                case OpCode.fpextend:
                case OpCode.truncate:
                case OpCode.bitcast:
                case OpCode.inttofloat:
                case OpCode.floattoint:
                case OpCode.inttoptr:
                case OpCode.ptrtoint:
                case OpCode.add:
                case OpCode.sub:
                case OpCode.mul:
                case OpCode.div_:
                case OpCode.mod:
                case OpCode.and_:
                case OpCode.or_:
                case OpCode.xor_:
                case OpCode.shl:
                case OpCode.shr:
                case OpCode.equal:
                case OpCode.less:
                case OpCode.param:
                case OpCode.load:
                case OpCode.elemaddr:
                case OpCode.ptroffset:
                case OpCode.ptrdiff:
                case OpCode.function_call:
                {
                    return true;
                }
            }
            return false;
        }
        public inline bool IsSwitchInstruction() const
        {
            return opCode == OpCode.switch_;
        }
        public inline bool IsParamInstruction() const
        {
            return opCode == OpCode.param;
        }
        public inline bool IsLocalInstruction() const
        {
            return opCode == OpCode.local;
        }
        public inline bool IsLoadInstruction() const
        {
            return opCode == OpCode.load;
        }
        public inline bool IsStoreInstruction() const
        {
            return opCode == OpCode.store;
        }
        public inline bool IsElemAddrInstruction() const
        {
            return opCode == OpCode.elemaddr;
        }
        public inline bool IsArgInstruction() const
        {
            return opCode == OpCode.arg;
        }
        public inline bool IsFunctionCallInstruction() const
        {
            return opCode == OpCode.function_call;
        }
        public inline bool IsProcedureCallInstruction() const
        {
            return opCode == OpCode.procedure_call;
        }
        public inline bool IsRetInstruction() const
        {
            return opCode == OpCode.ret;
        }
        public inline bool IsNopInstruction() const
        {
            return opCode == OpCode.nop;
        }
        public inline bool IsJumpInstruction() const
        {
            return opCode == OpCode.jmp;
        }
        public inline bool IsBranchInstruction() const
        {
            return opCode == OpCode.branch;
        }
        public bool IsRetVoid() const
        {
            if (IsRetInstruction())
            {
                RetInstruction* ret = cast<RetInstruction*>(this);
                return ret->ReturnValue() == null;
            }
            return false;
        }
        public bool IsTerminator() const
        {
            switch (opCode)
            {
                case OpCode.jmp:
                case OpCode.branch:
                case OpCode.ret:
                case OpCode.switch_:
                {
                    return true;
                }
            }
            return false;
        }
        public virtual bool IsFloatingPointInstruction() const
        {
            return false;
        }
        public void AddUser(Instruction* user)
        {
            AddInstToInstructionSet(user, users);
        }
        public void RemoveUser(Instruction* user)
        {
            RemoveInstFromInstructionSet(user, users);
        }
        public virtual List<Instruction*> Uses() const
        {
            return List<Instruction*>();
        }
        public virtual void AddToUses()
        {
        }
        public void RemoveFromUses()
        {
            List<Instruction*> uses = Uses();
            for (Instruction* use : uses)
            {
                use->RemoveUser(this);
            }
        }
        [nodiscard]
        public Result<bool> ReplaceUsesWith(Value* value)
        {
            Function* fn = Parent()->Parent();
            RegValue* use = fn->GetRegValue(RegValueIndex());
            if (use != null)
            {
                List<Instruction*> copiedUsers = users;
                for (Instruction* user : copiedUsers)
                {
                    user->ReplaceValue(use, value);
                }
            }
            else
            {
                Code* code = fn->Parent();
                Context* context = code->GetContext();
                int errorId = Error("reg value " + ToString(RegValueIndex()) + "not found", Span(), context);
                return Result<bool>(ErrorId(errorId));
            }
            return Result<bool>(true);
        }
        public virtual void ReplaceValue(Value* use, Value* value)
        {
        }
        private OpCode opCode;
        private int index;
        private int sourceLineNumber;
        private int regValueIndex;
        private int assemblyIndex;
        private List<Instruction*> users;
    }

    public class StoreInstruction : Instruction
    {
        public StoreInstruction(const System.Lex.Span& span_, Value* value_, Value* ptr_) : base(span_, null, OpCode.store), value(value_), ptr(ptr_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "store ";
            value->Dump();
            Console.Out() << " : ";
            ptr->Dump();
            Console.Out() << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<Value*> clonedValueResult = value->Clone(cloneContext);
            if (clonedValueResult.Error()) return  clonedValueResult;
            Value* clonedValue = clonedValueResult.Value();
            Result<Value*> clonedPtrResult = ptr->Clone(cloneContext);
            if (clonedPtrResult.Error()) return  clonedPtrResult;
            Value* clonedPtr = clonedPtrResult.Value();
            StoreInstruction* clone = new StoreInstruction(Span(), clonedValue, clonedPtr);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = formatter.Write(Format("store ", 8));
            if (result.Error()) return result;
            result = formatter.Write(value->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(value->ToString());
            if (result.Error()) return result;
            result = formatter.Write(", ");
            if (result.Error()) return result;
            result = formatter.Write(ptr->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(ptr->ToString());
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline Value* GetValue() const
        {
            return value;
        }
        public inline Value* Ptr() const
        {
            return ptr;
        }
        public override bool IsFloatingPointInstruction() const
        {
            return value->GetType()->IsFloatingPointType();
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, value);
            intermediate.AddUser(this, ptr);
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            AddToUsesList(uses, value);
            AddToUsesList(uses, ptr);
            return uses;
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (this->value == use)
            {
                intermediate.RemoveUser(this, this->value);
                this->value = value;
                intermediate.AddUser(this, this->value);
            }
            if (ptr == use)
            {
                intermediate.RemoveUser(this, ptr);
                ptr = value;
                intermediate.AddUser(this, ptr);
            }
        }
        private Value* value;
        private Value* ptr;
    }

    public class ArgInstruction : Instruction
    {
        public ArgInstruction(const System.Lex.Span& span_, Value* arg_) : base(span_, null, OpCode.arg), arg(arg_)
        {
            #assert(arg != null);
            #assert(arg->GetType() != null);
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "arg ";
            arg->Dump();
            Console.Out() << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<Value*> clonedArgResult = arg->Clone(cloneContext);
            if (clonedArgResult.Error()) return clonedArgResult;
            Value* clonedArg = clonedArgResult.Value();
            ArgInstruction* clone = new ArgInstruction(Span(), clonedArg);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = formatter.Write(Format("arg ", 8));
            if (result.Error()) return result;
            result = formatter.Write(arg->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(arg->ToString());
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline Value* Arg() const
        {
            return arg;
        }
        public override bool IsFloatingPointInstruction() const
        {
            return arg->GetType()->IsFloatingPointType();
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            AddToUsesList(uses, arg);
            return uses;
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, arg);
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (arg == use)
            {
                intermediate.RemoveUser(this, arg);
                arg = value;
                intermediate.AddUser(this, arg);
            }
        }
        private Value* arg;
    }

    public class JmpInstruction : Instruction
    {
        public JmpInstruction(const System.Lex.Span& span_, int targetLabelId_) : base(span_, null, OpCode.jmp), targetLabelId(targetLabelId_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "jmp @" << TargetBasicBlock()->Id() << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            JmpInstruction* clone = new JmpInstruction(Span(), targetBasicBlock->Id());
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            BasicBlock* bb = cloneContext.GetMappedBasicBlock(targetBasicBlock);
            if (bb != null)
            {
                clone->SetTargetBasicBlock(bb);
            }
            else
            {
                int errorId = Error("mapped basic block not found", Span(), cloneContext.GetContext());
                return Result<Value*>(ErrorId(errorId));
            }
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = formatter.Write(Format("jmp", 8));
            if (result.Error()) return result;
            result = formatter.Write("@" + ToString(targetBasicBlock->Id()));
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline int TargetLabelId() const
        {
            return targetLabelId;
        }
        public inline BasicBlock* TargetBasicBlock() const
        {
            return targetBasicBlock;
        }
        public inline void SetTargetBasicBlock(BasicBlock* targetBasicBlock_)
        {
            targetBasicBlock = targetBasicBlock_;
        }
        private int targetLabelId;
        private BasicBlock* targetBasicBlock;
    }

    public class BranchInstruction : Instruction
    {
        public BranchInstruction(const System.Lex.Span& span_, Value* cond_, int trueTargetLabelId_, int falseTargetLabelId_) :
            base(span_, null, OpCode.branch), cond(cond_), trueTargetLabelId(trueTargetLabelId_), falseTargetLabelId(falseTargetLabelId_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "branch ";
            cond->Dump();
            Console.Out() << " : @" << trueTargetBasicBlock->Id() << " : @" << falseTargetBasicBlock->Id() << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<Value*> clonedCondResult = cond->Clone(cloneContext);
            if (clonedCondResult.Error()) return clonedCondResult;
            Value* clonedCond = clonedCondResult.Value();
            BranchInstruction* clone = new BranchInstruction(Span(), clonedCond, trueTargetBasicBlock->Id(), falseTargetBasicBlock->Id());
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            BasicBlock* trueBB = cloneContext.GetMappedBasicBlock(trueTargetBasicBlock);
            if (trueBB != null)
            {
                clone->SetTrueTargetBasicBlock(trueBB);
            }
            else
            {
                int errorId = Error("mapped basic block not found", trueTargetBasicBlock->Span(), cloneContext.GetContext());
                return Result<Value*>(ErrorId(errorId));
            }
            BasicBlock* falseBB = cloneContext.GetMappedBasicBlock(falseTargetBasicBlock);
            if (falseBB != null)
            {
                clone->SetFalseTargetBasicBlock(falseBB);
            }
            else
            {
                int errorId = Error("mapped basic block not found", falseTargetBasicBlock->Span(), cloneContext.GetContext());
                return Result<Value*>(ErrorId(errorId));
           }
           clone->AddToUses();
           return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = formatter.Write(Format("branch", 8));
            if (result.Error()) return result;
            result = formatter.Write(cond->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(cond->ToString());
            if (result.Error()) return result;
            result = formatter.Write(", ");
            if (result.Error()) return result;
            result = formatter.Write("@" + ToString(trueTargetBasicBlock->Id()));
            if (result.Error()) return result;
            result = formatter.Write(", ");
            if (result.Error()) return result;
            result = formatter.Write("@" + ToString(falseTargetBasicBlock->Id()));
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline Value* Cond() const
        {
            return cond;
        }
        public inline int TrueTargetLabelId() const
        {
            return trueTargetLabelId;
        }
        public inline BasicBlock* TrueTargetBasicBlock() const
        {
            return trueTargetBasicBlock;
        }
        public inline void SetTrueTargetBasicBlock(BasicBlock* trueTargetBasicBlock_)
        {
            trueTargetBasicBlock = trueTargetBasicBlock_;
        }
        public inline int FalseTargetLabelId() const
        {
            return falseTargetLabelId;
        }
        public inline BasicBlock* FalseTargetBasicBlock() const
        {
            return falseTargetBasicBlock;
        }
        public inline void SetFalseTargetBasicBlock(BasicBlock* falseTargetBasicBlock_)
        {
            falseTargetBasicBlock = falseTargetBasicBlock_;
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            AddToUsesList(uses, cond);
            return uses;
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, cond);
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (cond == use)
            {
                intermediate.RemoveUser(this, cond);
                cond = value;
                intermediate.AddUser(this, cond);
            }
        }
        private Value* cond;
        private int trueTargetLabelId;
        private BasicBlock* trueTargetBasicBlock;
        private int falseTargetLabelId;
        private BasicBlock* falseTargetBasicBlock;
    }

    public class ProcedureCallInstruction : Instruction
    {
        ProcedureCallInstruction(const System.Lex.Span& span_, Value* callee_) : base(span_, null, OpCode.procedure_call), callee(callee_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "procedure call ";
            callee->Dump();
            Console.Out() << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<Value*> clonedCalleeResult = callee->Clone(cloneContext);
            if (clonedCalleeResult.Error()) return clonedCalleeResult;
            Value* clonedCallee = clonedCalleeResult.Value();
            ProcedureCallInstruction* clone = new ProcedureCallInstruction(Span(), clonedCallee);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = formatter.Write(Format("call", 8));
            if (result.Error()) return result;
            result = formatter.Write(callee->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(callee->ToString());
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline Value* Callee() const
        {
            return callee;
        }
        public Function* CalleeFn() const
        {
            if (callee->IsSymbolValue())
            {
                SymbolValue* symbolValue = cast<SymbolValue*>(callee);
                return symbolValue->GetFunction();
            }
            return null;
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            AddToUsesList(uses, callee);
            return uses;
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, callee);
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (callee == use)
            {
                intermediate.RemoveUser(this, callee);
                callee = value;
                intermediate.AddUser(this, callee);
            }
        }
        private Value* callee;
    }

    public class RetInstruction : Instruction
    {
        public RetInstruction(const System.Lex.Span& span_, Value* returnValue_) : base(span_, null, OpCode.ret), returnValue(returnValue_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            if (returnValue != null)
            {
                Console.Out() << "ret ";
                returnValue->Dump();
                Console.Out() << endl();
            }
            else
            {
                Console.Out() << "ret void" << endl();
            }
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Value* clonedReturnValue = null;
            if (returnValue != null)
            {
                Result<Value*> clonedReturnValueResult = returnValue->Clone(cloneContext);
                if (clonedReturnValueResult.Error()) return clonedReturnValueResult;
                clonedReturnValue = clonedReturnValueResult.Value();
            }
            RetInstruction* clone = new RetInstruction(Span(), clonedReturnValue);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = formatter.Write(Format("ret", 8));
            if (result.Error()) return result;
            if (returnValue != null)
            {
                result = formatter.Write(returnValue->GetType()->Name());
                if (result.Error()) return result;
                result = formatter.Write(" ");
                if (result.Error()) return result;
                result = formatter.Write(returnValue->ToString());
                if (result.Error()) return result;
            }
            else
            {
                result = formatter.Write("void");
                if (result.Error()) return result;
            }
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline Value* ReturnValue() const
        {
            return returnValue;
        }
        public override bool IsFloatingPointInstruction() const
        {
            if (returnValue != null)
            {
                return returnValue->GetType()->IsFloatingPointType();
            }
            return false;
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            if (returnValue != null)
            {
                AddToUsesList(uses, returnValue);
            }
            return uses;
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, returnValue);
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (returnValue == use)
            {
                intermediate.RemoveUser(this, returnValue);
                returnValue = value;
                intermediate.AddUser(this, returnValue);
            }
        }
        private Value* returnValue;
    }

    public class CaseTarget
    {
        public CaseTarget() : caseValue(null), targetLabelId(-1), targetBlock(null)
        {
        }
        public CaseTarget(Value* caseValue_, int targetLabelId_) : caseValue(caseValue_), targetLabelId(targetLabelId_), targetBlock(null)
        {
        }
        public Value* caseValue;
        public int targetLabelId;
        public BasicBlock* targetBlock;
    }

    public class SwitchInstruction : Instruction
    {
        public SwitchInstruction(const System.Lex.Span& span_, Value* cond_, int defaultTargetLabelId_) :
            base(span_, null, OpCode.switch_), cond(cond_), defaultTargetLabelId(defaultTargetLabelId_), defaultTargetBlock(null)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "switch ";
            cond->Dump();
            Console.Out() << " : @" << defaultTargetBlock->Id() << endl();
            for (const auto& caseTarget : caseTargets)
            {
                Console.Out() << "case ";
                caseTarget.caseValue->Dump();
                Console.Out() << " : @" << caseTarget.targetBlock->Id() << endl();
            }
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<Value*> clonedCondResult = cond->Clone(cloneContext);
            if (clonedCondResult.Error()) return clonedCondResult;
            Value* clonedCond = clonedCondResult.Value();
            SwitchInstruction* clone = new SwitchInstruction(Span(), clonedCond, defaultTargetBlock->Id());
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            BasicBlock* bb = cloneContext.GetMappedBasicBlock(defaultTargetBlock);
            if (bb != null)
            {
                clone->SetDefaultTargetBlock(bb);
            }
            else
            {
                int errorId = Error("mapped basic block not found", defaultTargetBlock->Span(), cloneContext.GetContext());
                return Result<Value*>(ErrorId(errorId));
            }
            for (const auto& caseTarget : caseTargets)
            {
                CaseTarget clonedCaseTarget;
                Result<Value*> clonedCaseValueResult = caseTarget.caseValue->Clone(cloneContext);
                if (clonedCaseValueResult.Error()) return clonedCaseValueResult;
                Value* clonedCaseValue = clonedCaseValueResult.Value();
                clonedCaseTarget.caseValue = clonedCaseValue;
                BasicBlock* bb = cloneContext.GetMappedBasicBlock(caseTarget.targetBlock);
                if (bb != null)
                {
                    clonedCaseTarget.targetBlock = bb;
                }
                else
                {
                    int errorId = Error("mapped basic block not found", caseTarget.targetBlock->Span(), cloneContext.GetContext());
                    return Result<Value*>(ErrorId(errorId));
                }
                clone->AddCaseTarget(clonedCaseTarget);
            }
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = formatter.Write(Format("switch", 8));
            if (result.Error()) return result;
            result = formatter.Write(cond->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(cond->ToString());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write("@" + ToString(defaultTargetBlock->Id()));
            if (result.Error()) return result;
            result = formatter.Write(", [");
            if (result.Error()) return result;
            bool first = true;
            for (const auto& p : caseTargets)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    result = formatter.Write(" : ");
                    if (result.Error()) return result;
                }
                Value* value = p.caseValue;
                BasicBlock* dest = p.targetBlock;
                result = formatter.Write(value->GetType()->Name());
                if (result.Error()) return result;
                result = formatter.Write(" ");
                if (result.Error()) return result;
                result = formatter.Write(value->ToString());
                if (result.Error()) return result;
                result = formatter.Write(", ");
                if (result.Error()) return result;
                result = formatter.Write("@" + ToString(dest->Id()));
                if (result.Error()) return result;
            }
            result = formatter.Write("]");
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline Value* Cond() const
        {
            return cond;
        }
        public inline int DefaultTargetLabelId() const
        {
            return defaultTargetLabelId;
        }
        public void AddCaseTarget(const CaseTarget& caseTarget)
        {
            caseTargets.Add(caseTarget);
        }
        public inline const List<CaseTarget>& CaseTargets() const
        {
            return caseTargets;
        }
        public inline List<CaseTarget>& CaseTargets()
        {
            return caseTargets;
        }
        public inline BasicBlock* DefaultTargetBlock() const
        {
            return defaultTargetBlock;
        }
        public inline void SetDefaultTargetBlock(BasicBlock* defaultTargetBlock_)
        {
            defaultTargetBlock = defaultTargetBlock_;
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            AddToUsesList(uses, cond);
            for (const CaseTarget& target : caseTargets)
            {
                AddToUsesList(uses, target.caseValue);
            }
            return uses;
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, cond);
            for (const auto& caseTarget : caseTargets)
            {
                intermediate.AddUser(this, caseTarget.caseValue);
            }
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (cond == use)
            {
                intermediate.RemoveUser(this, cond);
                cond = value;
                intermediate.AddUser(this, cond);
            }
            for (CaseTarget& caseTarget : caseTargets)
            {
                if (caseTarget.caseValue == use)
                {
                    intermediate.RemoveUser(this, caseTarget.caseValue);
                    caseTarget.caseValue = value;
                    intermediate.AddUser(this, caseTarget.caseValue);
                }
            }
        }
        private Value* cond;
        private int defaultTargetLabelId;
        private BasicBlock* defaultTargetBlock;
        private List<CaseTarget> caseTargets;
    }

    public abstract class ValueInstruction : Instruction
    {
        public ValueInstruction(const System.Lex.Span& span_, RegValue* result_, OpCode opCode_) : base(span_, result_->GetType(), opCode_), result(result_)
        {
            #assert(GetType() != null);
            result->SetInst(this);
        }
        public override ~ValueInstruction()
        {
            if (result != null)
            {
                result->SetInst(null);
            }
        }
        public inline RegValue* GetResult() const
        {
            return result;
        }
        public inline void ResetResult()
        {
            result = null;
        }
        [nodiscard]
        public Result<bool> WriteResult(System.Text.CodeFormatter& formatter)
        {
            auto writeResult = formatter.Write(Format(result->GetType()->Name(), 7, FormatWidth.min));
            if (writeResult.Error()) return writeResult;
            writeResult = formatter.Write(" ");
            if (writeResult.Error()) return writeResult;
            writeResult = formatter.Write(result->ToString());
            if (writeResult.Error()) return writeResult;
            return Result<bool>(true);
        }
        public override bool IsFloatingPointInstruction() const
        {
            return result->GetType()->IsFloatingPointType();
        }
        public override string ToString() const
        {
            return result->ToString();
        }
        private RegValue* result;
    }

    public abstract class UnaryInstruction : ValueInstruction
    {
        public UnaryInstruction(const System.Lex.Span& span_, RegValue* result_, Value* operand_, OpCode opCode_) :
            base(span_, result_, opCode_), operand(operand_)
        {
        }
        public inline Value* Operand() const
        {
            return operand;
        }
        public override void Dump()
        {
            Console.Out() << Name() << " ";
            GetResult()->Dump();
            Console.Out() << " : ";
            Operand()->Dump();
            Console.Out() << endl();
        }
        [nodiscard]
        public Result<bool> WriteArg(System.Text.CodeFormatter& formatter)
        {
            auto result = formatter.Write(operand->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(operand->ToString());
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            AddToUsesList(uses, operand);
            return uses;
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, operand);
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (operand == use)
            {
                intermediate.RemoveUser(this, operand);
                operand = value;
                intermediate.AddUser(this, operand);
            }
        }
        private Value* operand;
    }

    public class NotInstruction : UnaryInstruction
    {
        public NotInstruction(const System.Lex.Span& span_, RegValue* result_, Value* operand_) : base(span_, result_, operand_, OpCode.not_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedOperandResult = Operand()->Clone(cloneContext);
            if (clonedOperandResult.Error()) return clonedOperandResult;
            Value* clonedOperand = clonedOperandResult.Value();
            NotInstruction* clone = new NotInstruction(Span(), regValue, clonedOperand);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = not ");
            if (result.Error()) return result;
            result = WriteArg(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class NegInstruction : UnaryInstruction
    {
        public NegInstruction(const System.Lex.Span& span_, RegValue* result_, Value* operand_) : base(span_, result_, operand_, OpCode.neg)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedOperandResult = Operand()->Clone(cloneContext);
            if (clonedOperandResult.Error()) return clonedOperandResult;
            Value* clonedOperand = clonedOperandResult.Value();
            NegInstruction* clone = new NegInstruction(Span(), regValue, clonedOperand);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        public override bool IsFloatingPointInstruction() const
        {
            return Operand()->GetType()->IsFloatingPointType();
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = neg ");
            if (result.Error()) return result;
            result = WriteArg(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class SignExtendInstruction : UnaryInstruction
    {
        public SignExtendInstruction(const System.Lex.Span& span_, RegValue* result_, Value* operand_) : base(span_, result_, operand_, OpCode.signextend)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedOperandResult = Operand()->Clone(cloneContext);
            if (clonedOperandResult.Error()) return clonedOperandResult;
            Value* clonedOperand = clonedOperandResult.Value();
            SignExtendInstruction* clone = new SignExtendInstruction(Span(), regValue, clonedOperand);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = signextend ");
            if (result.Error()) return result;
            result = WriteArg(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class ZeroExtendInstruction : UnaryInstruction
    {
        public ZeroExtendInstruction(const System.Lex.Span& span_, RegValue* result_, Value* operand_) : base(span_, result_, operand_, OpCode.zeroextend)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedOperandResult = Operand()->Clone(cloneContext);
            if (clonedOperandResult.Error()) return clonedOperandResult;
            Value* clonedOperand = clonedOperandResult.Value();
            ZeroExtendInstruction* clone = new ZeroExtendInstruction(Span(), regValue, clonedOperand);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = zeroextend ");
            if (result.Error()) return result;
            result = WriteArg(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class FloatingPointExtendInstruction : UnaryInstruction
    {
        public FloatingPointExtendInstruction(const System.Lex.Span& span_, RegValue* result_, Value* operand_) : base(span_, result_, operand_, OpCode.fpextend)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedOperandResult = Operand()->Clone(cloneContext);
            if (clonedOperandResult.Error()) return clonedOperandResult;
            Value* clonedOperand = clonedOperandResult.Value();
            FloatingPointExtendInstruction* clone = new FloatingPointExtendInstruction(Span(), regValue, clonedOperand);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = fpextend ");
            if (result.Error()) return result;
            result = WriteArg(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class TruncateInstruction : UnaryInstruction
    {
        public TruncateInstruction(const System.Lex.Span& span_, RegValue* result_, Value* operand_) : base(span_, result_, operand_, OpCode.truncate)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedOperandResult = Operand()->Clone(cloneContext);
            if (clonedOperandResult.Error()) return clonedOperandResult;
            Value* clonedOperand = clonedOperandResult.Value();
            TruncateInstruction* clone = new TruncateInstruction(Span(), regValue, clonedOperand);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = truncate ");
            if (result.Error()) return result;
            result = WriteArg(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class BitcastInstruction : UnaryInstruction
    {
        public BitcastInstruction(const System.Lex.Span& span_, RegValue* result_, Value* operand_) : base(span_, result_, operand_, OpCode.bitcast)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedOperandResult = Operand()->Clone(cloneContext);
            if (clonedOperandResult.Error()) return clonedOperandResult;
            Value* clonedOperand = clonedOperandResult.Value();
            BitcastInstruction* clone = new BitcastInstruction(Span(), regValue, clonedOperand);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = bitcast ");
            if (result.Error()) return result;
            result = WriteArg(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class IntToFloatInstruction : UnaryInstruction
    {
        public IntToFloatInstruction(const System.Lex.Span& span_, RegValue* result_, Value* operand_) : base(span_, result_, operand_, OpCode.inttofloat)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedOperandResult = Operand()->Clone(cloneContext);
            if (clonedOperandResult.Error()) return clonedOperandResult;
            Value* clonedOperand = clonedOperandResult.Value();
            IntToFloatInstruction* clone = new IntToFloatInstruction(Span(), regValue, clonedOperand);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = inttofloat ");
            if (result.Error()) return result;
            result = WriteArg(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public override bool IsFloatingPointInstruction() const
        {
            return true;
        }
    }

    public class FloatToIntInstruction : UnaryInstruction
    {
        public FloatToIntInstruction(const System.Lex.Span& span_, RegValue* result_, Value* operand_) : base(span_, result_, operand_, OpCode.floattoint)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedOperandResult = Operand()->Clone(cloneContext);
            if (clonedOperandResult.Error()) return clonedOperandResult;
            Value* clonedOperand = clonedOperandResult.Value();
            FloatToIntInstruction* clone = new FloatToIntInstruction(Span(), regValue, clonedOperand);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = floattoint ");
            if (result.Error()) return result;
            result = WriteArg(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public override bool IsFloatingPointInstruction() const
        {
            return false;
        }
    }

    public class IntToPtrInstruction : UnaryInstruction
    {
        public IntToPtrInstruction(const System.Lex.Span& span_, RegValue* result_, Value* operand_) : base(span_, result_, operand_, OpCode.inttoptr)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedOperandResult = Operand()->Clone(cloneContext);
            if (clonedOperandResult.Error()) return clonedOperandResult;
            Value* clonedOperand = clonedOperandResult.Value();
            IntToPtrInstruction* clone = new IntToPtrInstruction(Span(), regValue, clonedOperand);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = inttoptr ");
            if (result.Error()) return result;
            result = WriteArg(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class PtrToIntInstruction : UnaryInstruction
    {
        public PtrToIntInstruction(const System.Lex.Span& span_, RegValue* result_, Value* operand_) : base(span_, result_, operand_, OpCode.ptrtoint)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedOperandResult = Operand()->Clone(cloneContext);
            if (clonedOperandResult.Error()) return clonedOperandResult;
            Value* clonedOperand = clonedOperandResult.Value();
            PtrToIntInstruction* clone = new PtrToIntInstruction(Span(), regValue, clonedOperand);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = ptrtoint ");
            if (result.Error()) return result;
            result = WriteArg(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public abstract class BinaryInstruction : ValueInstruction
    {
        public BinaryInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_, OpCode opCode_) :
            base(span_, result_, opCode_), left(left_), right(right_)
        {
        }
        public override void Dump()
        {
            Console.Out() << Name() << " ";
            GetResult()->Dump();
            Console.Out() << " : ";
            Left()->Dump();
            Console.Out() << " : ";
            Right()->Dump();
            Console.Out() << endl();
        }
        public inline Value* Left() const
        {
            return left;
        }
        public inline Value* Right() const
        {
            return right;
        }
        public override bool IsFloatingPointInstruction() const
        {
            return Left()->GetType()->IsFloatingPointType();
        }
        [nodiscard]
        public Result<bool> WriteArgs(System.Text.CodeFormatter& formatter)
        {
            auto result = formatter.Write(left->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(left->ToString());
            if (result.Error()) return result;
            result = formatter.Write(", ");
            if (result.Error()) return result;
            result = formatter.Write(right->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(right->ToString());
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            AddToUsesList(uses, left);
            AddToUsesList(uses, right);
            return uses;
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, left);
            intermediate.AddUser(this, right);
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (left == use)
            {
                intermediate.RemoveUser(this, left);
                left = value;
                intermediate.AddUser(this, left);
            }
            if (right == use)
            {
                intermediate.RemoveUser(this, right);
                right = value;
                intermediate.AddUser(this, right);
            }
        }
        private Value* left;
        private Value* right;
    }

    public class AddInstruction : BinaryInstruction
    {
        public AddInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_) :
            base(span_, result_, left_, right_, OpCode.add)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftResult = Left()->Clone(cloneContext);
            if (clonedLeftResult.Error()) return clonedLeftResult;
            Value* clonedLeft = clonedLeftResult.Value();
            Result<Value*> clonedRightResult = Right()->Clone(cloneContext);
            if (clonedRightResult.Error()) return clonedRightResult;
            Value* clonedRight = clonedRightResult.Value();
            AddInstruction* clone = new AddInstruction(Span(), regValue, clonedLeft, clonedRight);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = add ");
            if (result.Error()) return result;
            result = WriteArgs(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class SubInstruction : BinaryInstruction
    {
        public SubInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_) :
            base(span_, result_, left_, right_, OpCode.sub)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftResult = Left()->Clone(cloneContext);
            if (clonedLeftResult.Error()) return clonedLeftResult;
            Value* clonedLeft = clonedLeftResult.Value();
            Result<Value*> clonedRightResult = Right()->Clone(cloneContext);
            if (clonedRightResult.Error()) return clonedRightResult;
            Value* clonedRight = clonedRightResult.Value();
            SubInstruction* clone = new SubInstruction(Span(), regValue, clonedLeft, clonedRight);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = sub ");
            if (result.Error()) return result;
            result = WriteArgs(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class MulInstruction : BinaryInstruction
    {
        public MulInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_) :
            base(span_, result_, left_, right_, OpCode.mul)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftResult = Left()->Clone(cloneContext);
            if (clonedLeftResult.Error()) return clonedLeftResult;
            Value* clonedLeft = clonedLeftResult.Value();
            Result<Value*> clonedRightResult = Right()->Clone(cloneContext);
            if (clonedRightResult.Error()) return clonedRightResult;
            Value* clonedRight = clonedRightResult.Value();
            MulInstruction* clone = new MulInstruction(Span(), regValue, clonedLeft, clonedRight);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = mul ");
            if (result.Error()) return result;
            result = WriteArgs(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class DivInstruction : BinaryInstruction
    {
        public DivInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_) :
            base(span_, result_, left_, right_, OpCode.div_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftResult = Left()->Clone(cloneContext);
            if (clonedLeftResult.Error()) return clonedLeftResult;
            Value* clonedLeft = clonedLeftResult.Value();
            Result<Value*> clonedRightResult = Right()->Clone(cloneContext);
            if (clonedRightResult.Error()) return clonedRightResult;
            Value* clonedRight = clonedRightResult.Value();
            DivInstruction* clone = new DivInstruction(Span(), regValue, clonedLeft, clonedRight);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = div ");
            if (result.Error()) return result;
            result = WriteArgs(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class ModInstruction : BinaryInstruction
    {
        public ModInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_) :
            base(span_, result_, left_, right_, OpCode.mod)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftResult = Left()->Clone(cloneContext);
            if (clonedLeftResult.Error()) return clonedLeftResult;
            Value* clonedLeft = clonedLeftResult.Value();
            Result<Value*> clonedRightResult = Right()->Clone(cloneContext);
            if (clonedRightResult.Error()) return clonedRightResult;
            Value* clonedRight = clonedRightResult.Value();
            ModInstruction* clone = new ModInstruction(Span(), regValue, clonedLeft, clonedRight);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = mod ");
            if (result.Error()) return result;
            result = WriteArgs(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class AndInstruction : BinaryInstruction
    {
        public AndInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_) :
            base(span_, result_, left_, right_, OpCode.and_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftResult = Left()->Clone(cloneContext);
            if (clonedLeftResult.Error()) return clonedLeftResult;
            Value* clonedLeft = clonedLeftResult.Value();
            Result<Value*> clonedRightResult = Right()->Clone(cloneContext);
            if (clonedRightResult.Error()) return clonedRightResult;
            Value* clonedRight = clonedRightResult.Value();
            AndInstruction* clone = new AndInstruction(Span(), regValue, clonedLeft, clonedRight);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = and ");
            if (result.Error()) return result;
            result = WriteArgs(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class OrInstruction : BinaryInstruction
    {
        public OrInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_) :
            base(span_, result_, left_, right_, OpCode.or_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftResult = Left()->Clone(cloneContext);
            if (clonedLeftResult.Error()) return clonedLeftResult;
            Value* clonedLeft = clonedLeftResult.Value();
            Result<Value*> clonedRightResult = Right()->Clone(cloneContext);
            if (clonedRightResult.Error()) return clonedRightResult;
            Value* clonedRight = clonedRightResult.Value();
            OrInstruction* clone = new OrInstruction(Span(), regValue, clonedLeft, clonedRight);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = or ");
            if (result.Error()) return result;
            result = WriteArgs(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class XorInstruction : BinaryInstruction
    {
        public XorInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_) :
            base(span_, result_, left_, right_, OpCode.xor_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftResult = Left()->Clone(cloneContext);
            if (clonedLeftResult.Error()) return clonedLeftResult;
            Value* clonedLeft = clonedLeftResult.Value();
            Result<Value*> clonedRightResult = Right()->Clone(cloneContext);
            if (clonedRightResult.Error()) return clonedRightResult;
            Value* clonedRight = clonedRightResult.Value();
            XorInstruction* clone = new XorInstruction(Span(), regValue, clonedLeft, clonedRight);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = xor ");
            if (result.Error()) return result;
            result = WriteArgs(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class ShlInstruction : BinaryInstruction
    {
         ShlInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_) :
            base(span_, result_, left_, right_, OpCode.shl)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftResult = Left()->Clone(cloneContext);
            if (clonedLeftResult.Error()) return clonedLeftResult;
            Value* clonedLeft = clonedLeftResult.Value();
            Result<Value*> clonedRightResult = Right()->Clone(cloneContext);
            if (clonedRightResult.Error()) return clonedRightResult;
            Value* clonedRight = clonedRightResult.Value();
            ShlInstruction* clone = new ShlInstruction(Span(), regValue, clonedLeft, clonedRight);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = shl ");
            if (result.Error()) return result;
            result = WriteArgs(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class ShrInstruction : BinaryInstruction
    {
         ShrInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_) :
            base(span_, result_, left_, right_, OpCode.shr)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftResult = Left()->Clone(cloneContext);
            if (clonedLeftResult.Error()) return clonedLeftResult;
            Value* clonedLeft = clonedLeftResult.Value();
            Result<Value*> clonedRightResult = Right()->Clone(cloneContext);
            if (clonedRightResult.Error()) return clonedRightResult;
            Value* clonedRight = clonedRightResult.Value();
            ShrInstruction* clone = new ShrInstruction(Span(), regValue, clonedLeft, clonedRight);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = shr ");
            if (result.Error()) return result;
            result = WriteArgs(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class EqualInstruction : BinaryInstruction
    {
         EqualInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_) :
            base(span_, result_, left_, right_, OpCode.equal)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftResult = Left()->Clone(cloneContext);
            if (clonedLeftResult.Error()) return clonedLeftResult;
            Value* clonedLeft = clonedLeftResult.Value();
            Result<Value*> clonedRightResult = Right()->Clone(cloneContext);
            if (clonedRightResult.Error()) return clonedRightResult;
            Value* clonedRight = clonedRightResult.Value();
            EqualInstruction* clone = new EqualInstruction(Span(), regValue, clonedLeft, clonedRight);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = equal ");
            if (result.Error()) return result;
            result = WriteArgs(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public override bool IsFloatingPointInstruction() const
        {
            return false;
        }
    }

    public class LessInstruction : BinaryInstruction
    {
         LessInstruction(const System.Lex.Span& span_, RegValue* result_, Value* left_, Value* right_) :
            base(span_, result_, left_, right_, OpCode.less)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftResult = Left()->Clone(cloneContext);
            if (clonedLeftResult.Error()) return clonedLeftResult;
            Value* clonedLeft = clonedLeftResult.Value();
            Result<Value*> clonedRightResult = Right()->Clone(cloneContext);
            if (clonedRightResult.Error()) return clonedRightResult;
            Value* clonedRight = clonedRightResult.Value();
            LessInstruction* clone = new LessInstruction(Span(), regValue, clonedLeft, clonedRight);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = less ");
            if (result.Error()) return result;
            result = WriteArgs(formatter);
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public override bool IsFloatingPointInstruction() const
        {
            return false;
        }
    }

    public class ParamInstruction : ValueInstruction
    {
        public ParamInstruction(const System.Lex.Span& span_, RegValue* result_) : base(span_, result_, OpCode.param)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "param ";
            GetResult()->Dump();
            Console.Out() << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            ParamInstruction* clone = new ParamInstruction(Span(), regValue);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = param");
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class LocalInstruction : ValueInstruction
    {
        public LocalInstruction(const System.Lex.Span& span_, RegValue* result_, Type* localType_) : base(span_, result_, OpCode.local), localType(localType_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "local ";
            GetResult()->Dump();
            Console.Out() << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            LocalInstruction* clone = new LocalInstruction(Span(), regValue, localType);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        public inline Type* LocalType() const
        {
            return localType;
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = local ");
            if (result.Error()) return result;
            result = formatter.Write(localType->Name());
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        private Type* localType;
    }

    public class LoadInstruction : ValueInstruction
    {
        public LoadInstruction(const System.Lex.Span& span_, RegValue* result_, Value* ptr_) : base(span_, result_, OpCode.load), ptr(ptr_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "load ";
            GetResult()->Dump();
            Console.Out() << " : ";
            ptr->Dump();
            Console.Out() << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedPtrResult = ptr->Clone(cloneContext);
            if (clonedPtrResult.Error()) return clonedPtrResult;
            Value* clonedPtr = clonedPtrResult.Value();
            LoadInstruction* clone = new LoadInstruction(Span(), regValue, clonedPtr);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = load ");
            if (result.Error()) return result;
            result = formatter.Write(ptr->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(ptr->ToString());
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline Value* Ptr() const
        {
            return ptr;
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            AddToUsesList(uses, ptr);
            return uses;
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, ptr);
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (ptr == use)
            {
                intermediate.RemoveUser(this, ptr);
                ptr = value;
                intermediate.AddUser(this, ptr);
            }
        }
        private Value* ptr;
    }

    public enum ElemAddrKind
    {
        none, array, structure
    }

    public class ElemAddrInstruction : ValueInstruction
    {
        public ElemAddrInstruction(const System.Lex.Span& span_, RegValue* result_, Value* ptr_, Value* indexValue_) :
            base(span_, result_, OpCode.elemaddr), ptr(ptr_), indexValue(indexValue_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "elemaddr ";
            GetResult()->Dump();
            Console.Out() << " : ";
            ptr->Dump();
            Console.Out() << " : ";
            indexValue->Dump();
            Console.Out() << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedPtrResult = ptr->Clone(cloneContext);
            if (clonedPtrResult.Error()) return clonedPtrResult;
            Value* clonedPtr = clonedPtrResult.Value();
            Result<Value*> clonedIndexValueResult = indexValue->Clone(cloneContext);
            if (clonedIndexValueResult.Error()) return clonedIndexValueResult;
            Value* clonedIndexValue = clonedIndexValueResult.Value();
            ElemAddrInstruction* clone = new ElemAddrInstruction(Span(), regValue, clonedPtr, clonedIndexValue);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = elemaddr ");
            if (result.Error()) return result;
            result = formatter.Write(ptr->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(ptr->ToString());
            if (result.Error()) return result;
            result = formatter.Write(", ");
            if (result.Error()) return result;
            result = formatter.Write(indexValue->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(indexValue->ToString());
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline Value* Ptr() const
        {
            return ptr;
        }
        public inline Value* IndexValue() const
        {
            return indexValue;
        }
        public inline Result<ElemAddrKind> GetElemAddrKind(Context* context) const
        {
            if (ptr->GetType()->IsPointerType())
            {
                PointerType* ptrType = cast<PointerType*>(ptr->GetType());
                Result<Type*> pointeeTypeResult = ptrType->RemovePointer(context);
                if (pointeeTypeResult.Error()) return Result<ElemAddrKind>(ErrorId(pointeeTypeResult.GetErrorId()));
                Type* pointeeType = pointeeTypeResult.Value();
                if (pointeeType->IsArrayType())
                {
                    return Result<ElemAddrKind>(ElemAddrKind.array);
                }
                else if (pointeeType->IsStructureType())
                {
                    return Result<ElemAddrKind>(ElemAddrKind.structure);
                }
            }
            int errorId = AllocateError("invalid elemaddr kind");
            return Result<ElemAddrKind>(ErrorId(errorId));
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            AddToUsesList(uses, ptr);
            AddToUsesList(uses, indexValue);
            return uses;
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, ptr);
            intermediate.AddUser(this, indexValue);
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (ptr == use)
            {
                intermediate.RemoveUser(this, ptr);
                ptr = value;
                intermediate.AddUser(this, ptr);
            }
            if (indexValue == use)
            {
                intermediate.RemoveUser(this, indexValue);
                indexValue = value;
                intermediate.AddUser(this, indexValue);
            }
        }
        private Value* ptr;
        private Value* indexValue;
    }

    public class PtrOffsetInstruction : ValueInstruction
    {
        public PtrOffsetInstruction(const System.Lex.Span& span_, RegValue* result_, Value* ptr_, Value* offset_) :
            base(span_, result_, OpCode.ptroffset), ptr(ptr_), offset(offset_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "ptroffset ";
            GetResult()->Dump();
            Console.Out() << " : ";
            ptr->Dump();
            Console.Out() << " : ";
            offset->Dump();
            Console.Out() << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedPtrResult = ptr->Clone(cloneContext);
            if (clonedPtrResult.Error()) return clonedPtrResult;
            Value* clonedPtr = clonedPtrResult.Value();
            Result<Value*> clonedOffsetResult = offset->Clone(cloneContext);
            if (clonedOffsetResult.Error()) return clonedOffsetResult;
            Value* clonedOffset = clonedOffsetResult.Value();
            PtrOffsetInstruction* clone = new PtrOffsetInstruction(Span(), regValue, clonedPtr, clonedOffset);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = ptroffset ");
            if (result.Error()) return result;
            result = formatter.Write(ptr->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(ptr->ToString());
            if (result.Error()) return result;
            result = formatter.Write(", ");
            if (result.Error()) return result;
            result = formatter.Write(offset->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(offset->ToString());
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline Value* Ptr() const
        {
            return ptr;
        }
        public inline Value* Offset() const
        {
            return offset;
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            AddToUsesList(uses, ptr);
            AddToUsesList(uses, offset);
            return uses;
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, ptr);
            intermediate.AddUser(this, offset);
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (ptr == use)
            {
                intermediate.RemoveUser(this, ptr);
                ptr = value;
                intermediate.AddUser(this, ptr);
            }
            if (offset == use)
            {
                intermediate.RemoveUser(this, offset);
                offset = value;
                intermediate.AddUser(this, offset);
            }
        }
        private Value* ptr;
        private Value* offset;
    }

    public class PtrDiffInstruction : ValueInstruction
    {
        public PtrDiffInstruction(const System.Lex.Span& span_, RegValue* result_, Value* leftPtr_, Value* rightPtr_) :
            base(span_, result_, OpCode.ptrdiff), leftPtr(leftPtr_), rightPtr(rightPtr_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "ptrdiff ";
            GetResult()->Dump();
            Console.Out() << " : ";
            leftPtr->Dump();
            Console.Out() << " : ";
            rightPtr->Dump();
            Console.Out() << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedLeftPtrResult = leftPtr->Clone(cloneContext);
            if (clonedLeftPtrResult.Error()) return clonedLeftPtrResult;
            Value* clonedLeftPtr = clonedLeftPtrResult.Value();
            Result<Value*> clonedRightPtrResult = rightPtr->Clone(cloneContext);
            if (clonedRightPtrResult.Error()) return clonedRightPtrResult;
            Value* clonedRightPtr = clonedRightPtrResult.Value();
            PtrDiffInstruction* clone = new PtrDiffInstruction(Span(), regValue, clonedLeftPtr, clonedRightPtr);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            regValue->SetInst(clone);
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = ptrdiff ");
            if (result.Error()) return result;
            result = formatter.Write(leftPtr->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(leftPtr->ToString());
            if (result.Error()) return result;
            result = formatter.Write(", ");
            if (result.Error()) return result;
            result = formatter.Write(rightPtr->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(rightPtr->ToString());
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline Value* LeftPtr() const
        {
            return leftPtr;
        }
        public inline Value* RightPtr() const
        {
            return rightPtr;
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            AddToUsesList(uses, leftPtr);
            AddToUsesList(uses, rightPtr);
            return uses;
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, leftPtr);
            intermediate.AddUser(this, rightPtr);
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (leftPtr == use)
            {
                intermediate.RemoveUser(this, leftPtr);
                leftPtr = value;
                intermediate.AddUser(this, leftPtr);
            }
            if (rightPtr == use)
            {
                intermediate.RemoveUser(this, rightPtr);
                rightPtr = value;
                intermediate.AddUser(this, rightPtr);
            }
        }
        private Value* leftPtr;
        private Value* rightPtr;
    }

    public class FunctionCallInstruction : ValueInstruction
    {
        public FunctionCallInstruction(const System.Lex.Span& span_, RegValue* result_, Value* callee_) :
            base(span_, result_, OpCode.function_call), callee(callee_)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "functionCall ";
            GetResult()->Dump();
            Console.Out() << " : ";
            callee->Dump();
            Console.Out() << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Result<RegValue*> regValueResult = cloneContext.CurrentFunction()->MakeRegValue(Span(), GetType(), GetResult()->Reg());
            if (regValueResult.Error()) return Result<Value*>(ErrorId(regValueResult.GetErrorId()));
            RegValue* regValue = regValueResult.Value();
            Result<Value*> clonedCalleeResult = callee->Clone(cloneContext);
            if (clonedCalleeResult.Error()) return clonedCalleeResult;
            Value* clonedCallee = clonedCalleeResult.Value();
            FunctionCallInstruction* clone = new FunctionCallInstruction(Span(), regValue, clonedCallee);
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = WriteResult(formatter);
            if (result.Error()) return result;
            result = formatter.Write(" = call ");
            if (result.Error()) return result;
            result = formatter.Write(callee->GetType()->Name());
            if (result.Error()) return result;
            result = formatter.Write(" ");
            if (result.Error()) return result;
            result = formatter.Write(callee->ToString());
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        public inline Value* Callee() const
        {
            return callee;
        }
        public Function* CalleeFn() const
        {
            if (callee->IsSymbolValue())
            {
                SymbolValue* symbolValue = cast<SymbolValue*>(callee);
                return symbolValue->GetFunction();
            }
            return null;
        }
        public override List<Instruction*> Uses() const
        {
            List<Instruction*> uses;
            AddToUsesList(uses, callee);
            return uses;
        }
        public override void AddToUses()
        {
            intermediate.AddUser(this, callee);
        }
        public override void ReplaceValue(Value* use, Value* value)
        {
            if (callee == use)
            {
                intermediate.RemoveUser(this, callee);
                callee = value;
                intermediate.AddUser(this, callee);
            }
        }
        private Value* callee;
    }

    public class NoOperationInstruction : Instruction
    {
        public NoOperationInstruction(const System.Lex.Span& span_) : base(span_, null, OpCode.nop)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public override void Dump()
        {
            Console.Out() << "nop" << endl();
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            NoOperationInstruction* clone = new NoOperationInstruction(Span());
            clone->SetIndex(Index());
            clone->SetRegValueIndex(RegValueIndex());
            clone->AddToUses();
            return Result<Value*>(clone);
        }
        [nodiscard]
        public override Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            auto result = formatter.Write("nop");
            if (result.Error()) return result;
            result = WriteComment(formatter);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class BasicBlock : Component
    {
        public BasicBlock(const System.Lex.Span& span_, int id_) : base(ValueKind.basic_block, span_, null), id(id_), instructions(this)
        {
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public inline int Id() const
        {
            return id;
        }
        public inline void SetId(int id_)
        {
            id = id_;
        }
        public inline bool IsEmpty() const
        {
            return instructions.IsEmpty();
        }
        public inline Function* Parent() const
        {
            #assert(GetContainer() != null);
            return cast<Function*>(GetContainer()->Parent());
        }
        public void VisitInstructions(Visitor& visitor)
        {
            Instruction* inst = FirstInstruction();
            while (inst != null)
            {
                inst->Accept(visitor);
                inst = inst->Next();
            }
        }
        public inline BasicBlock* Next() const
        {
             return cast<BasicBlock*>(NextSibling());
        }
        public inline BasicBlock* Prev() const
        {
             return cast<BasicBlock*>(PrevSibling());
        }
        public inline Instruction* FirstInstruction() const
        {
            return cast<Instruction*>(instructions.FirstChild());
        }
        public inline Instruction* LastInstruction() const
        {
            return cast<Instruction*>(instructions.LastChild());
        }
        public inline ComponentContainer* Instructions() const
        {
            return &instructions;
        }
        public Instruction* Leader() const
        {
            Instruction* leader = FirstInstruction();
            while (leader != null && leader->IsNopInstruction())
            {
                leader = leader->Next();
            }
            #assert(leader != null);
            return leader;
        }
        public bool ContainsOnlyNops() const
        {
            Instruction* inst = FirstInstruction();
            while (inst != null && !inst->IsTerminator())
            {
                if (!inst->IsNopInstruction())
                {
                    return false;
                }
                inst = inst->Next();
            }
            return true;
        }
        public bool IsLast() const
        {
            Function* fn = Parent();
            return this == fn->LastBasicBlock();
        }
        public void AddInstruction(Instruction* instruction, bool mapInstruction)
        {
            instructions.AddChild(instruction);
            Function* fn = Parent();
            int nextRegNumber = fn->NextRegNumber();
            if (mapInstruction && instruction->IsValueInstruction())
            {
                ValueInstruction* valueInstruction = cast<ValueInstruction*>(instruction);
                fn->MapInstruction(valueInstruction->GetResult()->Reg(), valueInstruction);
                nextRegNumber = Max(valueInstruction->GetResult()->Reg() + 1, nextRegNumber);
            }
            fn->SetNextRegNumber(nextRegNumber);
        }
        public void AddInstruction(Instruction* instruction)
        {
            AddInstruction(instruction, true);
        }
        public UniquePtr<Instruction> RemoveInstruction(Instruction* instruction)
        {
            return UniquePtr<Instruction>(cast<Instruction*>(instructions.RemoveChild(instruction).Release()));
        }
        public void InsertInstructionAfter(Instruction* instruction, Instruction* after)
        {
            instructions.InsertAfter(instruction, after);
            Function* fn = Parent();
            int nextRegNumber = fn->NextRegNumber();
            if (instruction->IsValueInstruction())
            {
                ValueInstruction* valueInstruction = cast<ValueInstruction*>(instruction);
                fn->MapInstruction(valueInstruction->GetResult()->Reg(), valueInstruction);
                nextRegNumber = Max(valueInstruction->GetResult()->Reg() + 1, nextRegNumber);
            }
            fn->SetNextRegNumber(nextRegNumber);
        }
        public BasicBlock* SplitAfter(Instruction* instruction)
        {
            Function* fn = Parent();
            UniquePtr<BasicBlock> newBB(new BasicBlock(Span(), fn->NextBBNumber()));
            BasicBlock* nbb = newBB.Get();
            fn->InsertBasicBlockAfter(newBB.Release(), instruction->Parent());
            instruction = instruction->Next();
            while (instruction != null)
            {
                Instruction* next = instruction->Next();
                UniquePtr<Instruction> removedInst = instruction->Parent()->RemoveInstruction(instruction);
                if (removedInst->IsValueInstruction())
                {
                    ValueInstruction* valueInst = cast<ValueInstruction*>(removedInst.Get());
                    valueInst->SetRegValueIndex(fn->GetNextRegNumber());
                    valueInst->GetResult()->SetReg(valueInst->RegValueIndex());
                    fn->MapRegValue(valueInst->GetResult());
                }
                nbb->AddInstruction(removedInst.Release(), false);
                instruction = next;
            }
            return nbb;
        }
        public void InsertFront(Instruction* instruction)
        {
            Function* fn = Parent();
            int nextRegNumber = fn->NextRegNumber();
            if (instructions.IsEmpty())
            {
                instructions.AddChild(instruction);
            }
            else
            {
                instructions.InsertBefore(instruction, instructions.FirstChild());
            }
            if (instruction->IsValueInstruction())
            {
                ValueInstruction* valueInstruction = cast<ValueInstruction*>(instruction);
                fn->MapInstruction(valueInstruction->GetResult()->Reg(), valueInstruction);
                nextRegNumber = Max(valueInstruction->GetResult()->Reg() + 1, nextRegNumber);
            }
            fn->SetNextRegNumber(nextRegNumber);
        }
        [nodiscard]
        public Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            int indent = formatter.IndentSize();
            bool indentDecremented = false;
            if (formatter.CurrentIndent() > 0)
            {
                formatter.DecIndent();
                indentDecremented = true;
            }
            Result<bool> result = formatter.Write(Format("@" + ToString(id), indent, FormatWidth.min));
            if (result.Error()) return result;
            bool first = true;
            Instruction* inst = FirstInstruction();
            while (inst != null)
            {
                result = inst->Write(formatter);
                if (result.Error()) return result;
                result = formatter.WriteLine();
                if (result.Error()) return result;
                if (first)
                {
                    if (indentDecremented)
                    {
                        formatter.IncIndent();
                    }
                    first = false;
                }
                inst = inst->Next();
            }
            return Result<bool>(true);
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            BasicBlock* clone = new BasicBlock(Span(), id);
            cloneContext.MapBasicBlock(this, clone);
            return Result<Value*>(clone);
        }
        [nodiscard]
        public Result<bool> CloneInstructions(CloneContext& cloneContext, BasicBlock* to)
        {
            Instruction* inst = FirstInstruction();
            while (inst != null)
            {
                Result<Value*> cloneResult = inst->Clone(cloneContext);
                if (cloneResult.Error()) return Result<bool>(ErrorId(cloneResult.GetErrorId()));
                Value* clone = cloneResult.Value();
                Instruction* clonedInst = cast<Instruction*>(clone);
                cloneContext.MapInstruction(inst, clonedInst);
                to->AddInstruction(clonedInst);
                inst = inst->Next();
            }
            return Result<bool>(true);
        }
        private int id;
        private ComponentContainer instructions;
    }

    public enum FunctionFlags : byte
    {
        none = 0u, defined = 1u << 0u, inline_ = 1u << 1u
    }

    public class Function : Component
    {
        public Function(Context* context, ComponentContainer* container, const System.Lex.Span& span_, Type* type_, const string& name_, bool definition_,
            MetadataRef* metadataRef_, bool parsing) :
            base(ValueKind.function, span_, type_), flags(FunctionFlags.none), name(name_), metadataRef(metadataRef_), comment(),
                basicBlocks(this), nextRegNumber(0), nextBBNumber(0), mdId(-1), errorId(0)
        {
            Type* t = GetType();
            if (t->IsPointerType())
            {
                t = cast<PointerType*>(t)->BaseType();
            }
            functionType = null;
            if (t->IsFunctionType())
            {
                functionType = cast<FunctionType*>(t);
            }
            else
            {
                int errorId = Error("function type or function pointer type expected", Span(), Parent()->GetContext());
                SetErrorId(errorId);
            }
            SetContainer(container);
            if (definition_)
            {
                SetDefined();
            }
            if (!parsing)
            {
                entryBlock.Reset(new BasicBlock(span_, NextBBNumber()));
                entryBlock->SetContainer(&basicBlocks);
                for (int i = 0; i < functionType->Arity(); ++i)
                {
                    Type* paramType = functionType->ParamType(i);
                    #assert(paramType != null);
                    Instruction* paramInst = new ParamInstruction(span_, MakeNextRegValue(paramType));
                    entryBlock->AddInstruction(paramInst);
                    params.Add(paramInst);
                }
            }
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        public inline const string& Name() const
        {
            return name;
        }
        public inline const FunctionType* FnType() const
        {
            return functionType;
        }
        public override string ToString() const
        {
            return name;
        }
        public void SetMetadataRef(MetadataRef* metadataRef_)
        {
            metadataRef = metadataRef_;
        }
        [nodiscard]
        public Result<bool> Write(System.Text.CodeFormatter& formatter)
        {
            if (!comment.IsEmpty())
            {
                Result<bool> result = formatter.WriteLine("// " + comment);
                if (result.Error()) return result;
                result = formatter.WriteLine();
                if (result.Error()) return result;
            }
            if (basicBlocks.IsEmpty())
            {
                Result<bool> result = formatter.Write("extern ");
                if (result.Error()) return result;
            }
            else if (IsInline())
            {
                Result<bool> result = formatter.Write("inline ");
                if (result.Error()) return result;
            }
            Context* context = Parent()->GetContext();
            if (metadataRef != null)
            {
                mdId = metadataRef->NodeId();
            }
            string mdIdStr;
            if (mdId != -1)
            {
                mdIdStr.Append(" !").Append(ToString(mdId));
            }
            Result<bool> result = formatter.WriteLine("function " + GetType()->Name() + " " + name + mdIdStr);
            if (result.Error()) return result;
            if (basicBlocks.IsEmpty())
            {
                return Result<bool>(false);
            }
            result = SetNumbers();
            if (result.Error()) return result;
            result = formatter.WriteLine("{");
            if (result.Error()) return result;
            formatter.IncIndent();
            bool first = true;
            BasicBlock* bb = FirstBasicBlock();
            while (bb != null)
            {
                if (bb->IsEmpty())
                {
                    bb = bb->Next();
                    continue;
                }
                if (first)
                {
                    first = false;
                }
                else
                {
                    result = formatter.WriteLine();
                    if (result.Error()) return result;
                }
                result = bb->Write(formatter);
                if (result.Error()) return result;
                bb = bb->Next();
            }
            formatter.DecIndent();
            result = formatter.WriteLine("}");
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> SetNumbers()
        {
            Context* context = Parent()->GetContext();
            basicBlockMap.Clear();
            regValueMap.Clear();
            instructionMap.Clear();
            nextBBNumber = 0;
            BasicBlock* bb = FirstBasicBlock();
            while (bb != null)
            {
                bb->SetId(nextBBNumber++);
                basicBlockMap[bb->Id()] = bb;
                bb = bb->Next();
            }
            int instructionIndex = 0;
            nextRegNumber = 0;
            bb = FirstBasicBlock();
            while (bb != null)
            {
                Instruction* inst = bb->FirstInstruction();
                while (inst != null)
                {
                    inst->SetIndex(instructionIndex++);
                    if (inst->IsValueInstruction())
                    {
                        ValueInstruction* valueInst = cast<ValueInstruction*>(inst);
                        valueInst->SetRegValueIndex(nextRegNumber++);
                        valueInst->GetResult()->SetReg(valueInst->RegValueIndex());
                        MapRegValue(valueInst->GetResult());
                        MapInstruction(valueInst->RegValueIndex(), valueInst);
                    }
                    inst = inst->Next();
                }
                bb = bb->Next();
            }
            return Result<bool>(true);
        }
        public Result<Value*> ResolveRegValue(Value* value)
        {
            if (value == null)
            {
                return Result<Value*>(cast<Value*>(null));
            }
            else if (value->IsRegValue())
            {
                RegValue* regValue = cast<RegValue*>(value);
                RegValue* rv = GetRegValue(regValue->Reg());
                if (rv != null)
                {
                    return Result<Value*>(rv);
                }
                else
                {
                    int errorId = Error("value for reg " + regValue->Reg() + " not resolved", value->Span(), Parent()->GetContext());
                    return Result<Value*>(ErrorId(errorId));
                }
            }
            return Result<Value*>(value);
        }
        public inline Code* Parent() const
        {
            #assert(GetContainer() != null);
            return cast<Code*>(GetContainer()->Parent());
        }
        public inline Function* Next() const
        {
            return cast<Function*>(NextSibling());
        }
        public inline Function* Prev() const
        {
            return cast<Function*>(PrevSibling());
        }
        public inline bool IsEmpty() const
        {
            return basicBlocks.IsEmpty();
        }
        [nodiscard]
        public Result<bool> VisitBasicBlocks(Visitor& visitor)
        {
            BasicBlock* bb = FirstBasicBlock();
            while (bb != null)
            {
                bb->Accept(visitor);
                if (visitor.Error())
                {
                    return Result<bool>(ErrorId(visitor.GetErrorId()));
                }
                bb = bb->Next();
            }
            return Result<bool>(true);
        }
        public inline BasicBlock* FirstBasicBlock() const
        {
            return cast<BasicBlock*>(basicBlocks.FirstChild());
        }
        public inline BasicBlock* LastBasicBlock() const
        {
            return cast<BasicBlock*>(basicBlocks.LastChild());
        }
        public inline ComponentContainer* BasicBlocks() const
        {
            return &basicBlocks;
        }
        public BasicBlock* GetBasicBlock(int id) const
        {
            auto it = basicBlockMap.Find(id);
            if (it != basicBlockMap.End())
            {
                return it->second;
            }
            else
            {
                return null;
            }
        }
        public Result<BasicBlock*> AddBasicBlock(const System.Lex.Span& span, int id)
        {
            BasicBlock* prev = GetBasicBlock(id);
            if (prev != null)
            {
                Context* context = Parent()->GetContext();
                return Result<BasicBlock*>(ErrorId(Error("error adding basic block: basic block id not unique", span, prev->Span(), context)));
            }
            BasicBlock* basicBlock = new BasicBlock(span, id);
            basicBlocks.AddChild(basicBlock);
            basicBlockMap[id] = basicBlock;
            nextBBNumber = Max(id + 1, nextBBNumber);
            return Result<BasicBlock*>(basicBlock);
        }
        public void AddBasicBlock(BasicBlock* basicBlock)
        {
            basicBlocks.AddChild(basicBlock);
            basicBlockMap[basicBlock->Id()] = basicBlock;
            nextBBNumber = Max(basicBlock->Id() + 1, nextBBNumber);
        }
        public UniquePtr<BasicBlock> RemoveBasicBlock(BasicBlock* basicBlock)
        {
            return UniquePtr<BasicBlock>(cast<BasicBlock*>(basicBlocks.RemoveChild(basicBlock).Release()));
        }
        public void InsertBasicBlockBefore(BasicBlock* bb, BasicBlock* before)
        {
            basicBlocks.InsertBefore(bb, before);
            nextBBNumber = Max(bb->Id() + 1, nextBBNumber);
        }
        public void InsertBasicBlockAfter(BasicBlock* bb, BasicBlock* after)
        {
            basicBlocks.InsertAfter(bb, after);
            nextBBNumber = Max(bb->Id() + 1, nextBBNumber);
        }
        public Value* Param(int index) const
        {
            return params[index];
        }
        public BasicBlock* CreateBasicBlock()
        {
            if (basicBlocks.IsEmpty())
            {
                BasicBlock* bb = entryBlock.Release();
                basicBlocks.AddChild(bb);
                return bb;
            }
            BasicBlock* bb = new BasicBlock(Span(), NextBBNumber());
            basicBlocks.AddChild(bb);
            return bb;
        }
        public inline int NextRegNumber() const
        {
            return nextRegNumber;
        }
        public inline void SetNextRegNumber(int nextRegNumber_)
        {
            nextRegNumber = nextRegNumber_;
        }
        public inline int GetNextRegNumber()
        {
            return nextRegNumber++;
        }
        public RegValue* MakeNextRegValue(Type* type)
        {
            #assert(type != null);
            RegValue* regValue = new RegValue(System.Lex.Span(), type, GetNextRegNumber());
            regValues.Add(UniquePtr<RegValue>(regValue));
            regValueMap[regValue->Reg()] = regValue;
            return regValue;
        }
        public Result<RegValue*> MakeRegValue(const System.Lex.Span& span, Type* type, int reg)
        {
            RegValue* prev = GetRegValue(reg);
            if (prev != null)
            {
                Context* context = Parent()->GetContext();
                int errorId = Error("error adding register " + ToString(reg) + ": register not unique", span, prev->Span(), context);
                return Result<RegValue*>(ErrorId(errorId));
            }
            #assert(type != null);
            RegValue* regValue = new RegValue(span, type, reg);
            regValues.Add(UniquePtr<RegValue>(regValue));
            regValueMap[regValue->Reg()] = regValue;
            return Result<RegValue*>(regValue);
        }
        public RegValue* GetRegValue(int reg) const
        {
            auto it = regValueMap.Find(reg);
            if (it != regValueMap.End())
            {
                return it->second;
            }
            else
            {
                return null;
            }
        }
        public Result<RegValue*> GetRegRef(const System.Lex.Span& span, Type* type, int reg) const
        {
            RegValue* regValue = GetRegValue(reg);
            if (regValue != null)
            {
                if (regValue->GetType() == type)
                {
                    return Result<RegValue*>(regValue);
                }
                else
                {
                    Context* context = Parent()->GetContext();
                    int errorId = Error("error referencing register value " + ToString(reg) + ": type conflict", span, regValue->Span(), context);
                    return Result<RegValue*>(ErrorId(errorId));
                }
            }
            else
            {
                Context* context = Parent()->GetContext();
                int errorId = Error("error referencing register: register " + ToString(reg) + " not found", span, context);
                return Result<RegValue*>(ErrorId(errorId));
            }
        }
        public void MapRegValue(RegValue* regValue)
        {
            regValueMap[regValue->Reg()] = regValue;
        }
        public void MoveRegValuesTo(Function* toFunction)
        {
            for (auto& regValue : regValues)
            {
                if (regValue->Inst() == null) continue;
                regValue->SetReg(toFunction->GetNextRegNumber());
                toFunction->MapRegValue(regValue.Get());
                toFunction->regValues.Add(Rvalue(regValue));
            }
        }
        public Instruction* GetInstruction(int reg) const
        {
            auto it = instructionMap.Find(reg);
            if (it != instructionMap.End())
            {
                return it->second;
            }
            else
            {
                return null;
            }
        }
        public void MapInstruction(int reg, ValueInstruction* inst)
        {
            instructionMap[reg] = inst;
        }
        public inline FunctionFlags Flags() const
        {
            return flags;
        }
        public inline bool GetFlag(FunctionFlags flag) const
        {
            return (flags & flag) != FunctionFlags.none;
        }
        public inline void SetFlag(FunctionFlags flag)
        {
            flags = cast<FunctionFlags>(flags | flag);
        }
        public inline void ResetFlag(FunctionFlags flag)
        {
            flags = cast<FunctionFlags>(flags & ~flag);
        }
        public inline bool IsInline() const
        {
            return GetFlag(FunctionFlags.inline_);
        }
        public inline void SetInline()
        {
            SetFlag(FunctionFlags.inline_);
        }
        public inline bool IsDefined() const
        {
            return GetFlag(FunctionFlags.defined);
        }
        public inline void SetDefined()
        {
            SetFlag(FunctionFlags.defined);
        }
        public inline bool IsExternal() const
        {
            return !IsDefined();
        }
        public inline int Arity() const
        {
            return functionType->Arity();
        }
        public inline int MdId() const
        {
            return mdId;
        }
        public inline void SetMdId(int mdId_)
        {
            mdId = mdId_;
        }
        public inline const string& Comment() const
        {
            return comment;
        }
        public void SetComment(const string& comment_)
        {
            comment = comment_;
        }
        public string ResolveFullName() const
        {
            if (metadataRef != null)
            {
                MetadataStruct* metadataStruct = metadataRef->GetMetadataStruct();
                if (metadataStruct != null)
                {
                    MetadataItem* metadataItem = metadataStruct->GetItem("fullName");
                    if (metadataItem != null)
                    {
                        if (metadataItem->IsMetadataString())
                        {
                            MetadataString* metadataString = cast<MetadataString*>(metadataItem);
                            return metadataString->GetValue();
                        }
                    }
                }
            }
            return string();
        }
        public inline int NextBBNumber()
        {
            return nextBBNumber++;
        }
        public inline bool Error() const
        {
            return errorId != 0;
        }
        public inline int GetErrorId() const
        {
            return errorId;
        }
        public inline void SetErrorId(int errorId_)
        {
            errorId = errorId_;
        }
        public inline int NumBasicBlocks() const
        {
            return cast<int>(basicBlockMap.Count());
        }
        public override Result<Value*> Clone(CloneContext& cloneContext) const
        {
            Code* code = Parent();
            Context* context = code->GetContext();
            Function* clone = new Function(context, code->Functions(), Span(), GetType(), name, IsDefined(), metadataRef, true);
            clone->SetMdId(mdId);
            string fullName = ResolveFullName();
            if (!fullName.IsEmpty())
            {
                clone->SetComment(fullName);
            }
            cloneContext.SetContext(code->GetContext());
            cloneContext.SetCurrentFunction(clone);
            BasicBlock* bb = FirstBasicBlock();
            while (bb != null)
            {
                Result<Value*> cloneResult = bb->Clone(cloneContext);
                if (cloneResult.Error()) return cloneResult;
                Value* clonedValue = cloneResult.Value();
                BasicBlock* clonedBB = cast<BasicBlock*>(clonedValue);
                clone->AddBasicBlock(clonedBB);
                bb = bb->Next();
            }
            bb = FirstBasicBlock();
            while (bb != null)
            {
                BasicBlock* clonedBB = cloneContext.GetMappedBasicBlock(bb);
                if (clonedBB != null)
                {
                    Result<bool> result = bb->CloneInstructions(cloneContext, clonedBB);
                    if (result.Error())
                    {
                        string errorMessage = "error cloning instructions of function '" + name + "': " + RtmGetErrorMessageWithoutStackTrace(result.GetErrorId());
                        int errorId = AllocateError(errorMessage);
                        return Result<Value*>(ErrorId(errorId));
                    }
                }
                else
                {
                    int errorId = Error("mapped basic block not found", bb->Span(), context);
                    return Result<Value*>(ErrorId(errorId));
                }
                bb = bb->Next();
            }
            for (const auto& instRegValuePair : cloneContext.UnmappedInstructions())
            {
                Instruction* inst = instRegValuePair.first;
                RegValue* regValue = instRegValuePair.second;
                Instruction* mappedInst = cloneContext.GetMappedInstruction(inst);
                if (mappedInst != null)
                {
                    regValue->SetInst(mappedInst);
                }
                else
                {
                    int errorId = Error("mapped instruction not found", inst->Span(), context);
                    return Result<Value*>(ErrorId(errorId));
                }
            }
            return Result<Value*>(clone);
        }
        public override void Dump()
        {
            Console.Out() << "FUNCTION " << name << endl();
            for (const auto& regValuePtr : regValues)
            {
                RegValue* regValue = regValuePtr.Get();
                Console.Out() << "REG VALUE " << regValue->Reg() << " : " << cast<ulong>(regValue) << endl();
            }
            BasicBlock* bb = FirstBasicBlock();
            while (bb != null)
            {
                Console.Out() << "BASIC BLOCK " << bb->Id() << endl();
                Instruction* inst = bb->FirstInstruction();
                while (inst != null)
                {
                    inst->Dump();
                    inst = inst->Next();
                }
                bb = bb->Next();
            }
        }
        private FunctionFlags flags;
        private string name;
        private FunctionType* functionType;
        private MetadataRef* metadataRef;
        private List<Value*> params;
        private string comment;
        private ComponentContainer basicBlocks;
        private int nextRegNumber;
        private int nextBBNumber;
        private UniquePtr<BasicBlock> entryBlock;
        private Map<int, Instruction*> instructionMap;
        private Map<int, BasicBlock*> basicBlockMap;
        private List<UniquePtr<RegValue>> regValues;
        private Map<int, RegValue*> regValueMap;
        private int mdId;
        private int errorId;
    }

    public class Code : Component
    {
        public explicit Code(Context* context_) : base(ValueKind.code, System.Lex.Span(), null), context(context_), functions(this)
        {
        }
        public inline Context* GetContext() const
        {
            return context;
        }
        public inline ComponentContainer* Functions() const
        {
            return &functions;
        }
        [nodiscard]
        public Result<bool> VisitFunctions(Visitor& visitor)
        {
            Function* function = FirstFunction();
            while (function != null)
            {
                function->Accept(visitor);
                if (visitor.Error()) return Result<bool>(ErrorId(visitor.GetErrorId()));
                function = function->Next();
            }
            return Result<bool>(true);
        }
        public Function* FirstFunction() const
        {
            return cast<Function*>(functions.FirstChild());
        }
        public Function* LastFunction() const
        {
            return cast<Function*>(functions.LastChild());
        }
        public Function* GetFunction(const string& functionName) const
        {
            auto it = functionMap.Find(functionName);
            if (it != functionMap.End())
            {
                return it->second;
            }
            else
            {
                return null;
            }
        }
        public Result<Function*> GetOrInsertFunction(const string& functionName, FunctionType* functionType)
        {
            auto it = functionMap.Find(functionName);
            if (it != functionMap.End())
            {
                return Result<Function*>(it->second);
            }
            else
            {
                Result<Type*> typeResult = functionType->AddPointer(context);
                if (typeResult.Error()) return Result<Function*>(ErrorId(typeResult.GetErrorId()));
                Type* type = typeResult.Value();
                Function* function = new Function(context, &functions, System.Lex.Span(), type, functionName, false, null, false);
                if (function->Error())
                {
                    return Result<Function*>(ErrorId(function->GetErrorId()));
                }
                functionMap[functionName] = function;
                functions.AddChild(function);
                return Result<Function*>(function);
            }
        }
        public Result<Function*> AddFunctionDefinition(const System.Lex.Span& span, Type* type, const string& functionId, bool inline_, MetadataRef* metadataRef)
        {
            Function* prev = GetFunction(functionId);
            if (prev != null)
            {
                if (prev->IsDefined())
                {
                    return Result<Function*>(ErrorId(Error("error adding function '" + functionId + "': function id not unique", span, prev->Span(), context)));
                }
                else
                {
                    if (prev->GetType() != type)
                    {
                        return Result<Function*>(ErrorId(Error("error adding function '" + functionId + "': type '" + type->Name() +
                            "' conflicts with earlier declaration", span, prev->Span(), context)));
                    }
                    prev->SetDefined();
                    if (inline_)
                    {
                        prev->SetInline();
                    }
                    return Result<Function*>(prev);
                }
            }
            Function* function = new Function(context, &functions, span, type, functionId, true, metadataRef, true);
            if (function->Error()) return Result<Function*>(ErrorId(function->GetErrorId()));
            if (inline_)
            {
                function->SetInline();
            }
            functions.AddChild(function);
            functionMap[function->Name()] = function;
            return Result<Function*>(function);
        }
        public Result<Function*> AddFunctionDeclaration(const System.Lex.Span& span, Type* type, const string& functionId)
        {
            Function* prev = GetFunction(functionId);
            if (prev != null)
            {
                if (prev->GetType() != type)
                {
                    return Result<Function*>(ErrorId(Error("error adding function '" + functionId + "': type '" + type->Name() +
                        "' conflicts with earlier declaration", span, prev->Span(), context)));
                }
                return Result<Function*>(prev);
            }
            Function* function = new Function(context, &functions, span, type, functionId, false, null, true);
            if (function->Error()) return Result<Function*>(ErrorId(function->GetErrorId()));
            functions.AddChild(function);
            functionMap[function->Name()] = function;
            return Result<Function*>(function);
        }
        private Context* context;
        private ComponentContainer functions;
        private Map<string, Function*> functionMap;
    }
}

