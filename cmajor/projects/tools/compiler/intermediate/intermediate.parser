// =================================
// Copyright (c) 2024 Seppo Laakko
// Distributed under the MIT license
// =================================

using intermediate.token;

parser intermediate.parser.intermediate_parser
{
    lexer intermediate_lexer;
    main;

    IntermediateFile(intermediate.Context* context)
        ::= empty{ context->GetCompileUnit()->SetFilePath(lexer.FileName()); }
            TypeDeclarations(context):types?
            DataDefinitions(context):data?
            Functions(context):functions?
            Metadata(context):metadata?
        ;

    TypeDeclarations(intermediate.Context* context) : bool
        ::= TYPES LBRACE TypeDeclaration(context):typeDeclaration* RBRACE
        {
            Result<bool> result = context->GetTypes()->ResolveReferences();
            if (result.Error()) return ErrorId(result.GetErrorId());
            return true;
        }
        ;

    TypeDeclaration(intermediate.Context* context, var int tid)
        ::= TypeId:typeId{ tid = typeId;} ASSIGN TYPE
        (   StructureType(context, tid):structureType
        |   ArrayType(context, tid):arrayType
        |   FunctionType(context, tid):functionType
        )
        ;

    TypeId : int
        ::=
        (
            TYPEID
            {
                ustring s = lexer.GetMatch(pos);
                Result<string> result = ToUtf8(s);
                if (result.Error()) return ErrorId(result.GetErrorId());
                Result<int> userTypeIdResult = intermediate.MakeUserTypeId(result.Value());
                if (userTypeIdResult.Error()) return ErrorId(userTypeIdResult.GetErrorId());
                return userTypeIdResult.Value();
            }
        )
        ;

    FundamentalTypeId : int
        ::= VOID{ return intermediate.voidTypeId; }
        |   BOOL{ return intermediate.boolTypeId; }
        |   SBYTE{ return intermediate.sbyteTypeId; }
        |   BYTE{ return intermediate.byteTypeId; }
        |   SHORT{ return intermediate.shortTypeId; }
        |   USHORT{ return intermediate.ushortTypeId; }
        |   INT{ return intermediate.intTypeId; }
        |   UINT{ return intermediate.uintTypeId; }
        |   LONG{ return intermediate.longTypeId; }
        |   ULONG{ return intermediate.ulongTypeId; }
        |   FLOAT{ return intermediate.floatTypeId; }
        |   DOUBLE{ return intermediate.doubleTypeId; }
        ;

    TypeRef(var System.Lex.Span span, var int baseTypeId, var sbyte pointerCount) : intermediate.TypeRef
        ::=
        (
            (   TypeId:typeId{ span = lexer.GetSpan(pos); baseTypeId = typeId; }
            |   FundamentalTypeId:fundamentalTypeId{ span = lexer.GetSpan(pos); baseTypeId = fundamentalTypeId; }
            )
            (AST{ ++pointerCount; })*
        )
        {
            return MakeTypeRef(span, baseTypeId, pointerCount);
        }
        ;

    StructureType(intermediate.Context* context, int typeId, var System.Lex.Span span, var List<intermediate.TypeRef> fieldTypeRefs)
        ::= LBRACE{ span = lexer.GetSpan(pos); }
            (TypeRef:first{ fieldTypeRefs.Add(first); }
            (COMMA TypeRef:next{ fieldTypeRefs.Add(next); })*)?
            RBRACE
        {
            context->AddStructureType(span, typeId, fieldTypeRefs);
        }
        ;

    ArrayType(intermediate.Context* context, int typeId, var System.Lex.Span span, var long size) : bool
        ::= LBRACKET { span = lexer.GetSpan(pos); }
            NUMBER{ auto result = intermediate.GetLong(lexer.GetMatch(pos)); if (result.Error()) return ErrorId(result.GetErrorId()); else size = result.Value(); }
            ID{ pass = lexer.GetChar(pos) == 'x'; }
            TypeRef:elementTypeRef
            RBRACKET
        {
            context->AddArrayType(span, typeId, size, elementTypeRef);
            return true;
        }
        ;

    FunctionType(intermediate.Context* context, int typeId, var System.Lex.Span span, var List<intermediate.TypeRef> paramTypeRefs)
        ::= FUNCTION{ span = lexer.GetSpan(pos); }
            TypeRef:returnTypeRef
            LPAREN
            (TypeRef:first{ paramTypeRefs.Add(first); }
            (COMMA TypeRef:next{ paramTypeRefs.Add(next); })*)?
            RPAREN
        {
            context->AddFunctionType(span, typeId, returnTypeRef, paramTypeRefs);
        }
        ;

    DataDefinitions(intermediate.Context* context) : bool
        ::= DATA LBRACE DataDefinition(context):dataDefinition* RBRACE
        {
            Result<bool> result = context->GetData()->ResolveAddressValues();
            if (result.Error()) return ErrorId(result.GetErrorId());
            return true;
        }
        ;

    DataDefinition(intermediate.Context* context, var intermediate.TypeRef tref, var System.Lex.Span span, var string variableName) : bool
        ::= TypeRef:typeRef
            {
                tref = typeRef;
                auto result = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos)); if (result.Error()) return ErrorId(result.GetErrorId());
            }
            ID
            {
                span = lexer.GetSpan(pos);
                ustring s = lexer.GetMatch(pos);
                auto result = intermediate.GetString(s);
                if (result.Error()) return ErrorId(result.GetErrorId()); else variableName = result.Value();
            }
            (   SEMICOLON
                {
                    Result<bool> result = context->AddGlobalVariable(span, tref.GetType(), variableName, null);
                    if (result.Error()) return ErrorId(result.GetErrorId());
                }
            |   ASSIGN Constant(context, tref.GetType()):initializer
                {
                    Result<bool> result = context->AddGlobalVariable(span, tref.GetType(), variableName, initializer);
                    if (result.Error()) return ErrorId(result.GetErrorId());
                }
            )
            {
                return true;
            }
            ;

    Constant(intermediate.Context* context, Type* type) : intermediate.Value*
        ::= BoolConstant(context):boolConstant{ return boolConstant; }
        |   SByteConstant(context):sbyteConstant{ return sbyteConstant; }
        |   ByteConstant(context):byteConstant{ return byteConstant; }
        |   ShortConstant(context):shortConstant{ return shortConstant; }
        |   UShortConstant(context):ushortConstant{ return ushortConstant; }
        |   IntConstant(context):intConstant{ return intConstant; }
        |   UIntConstant(context):uintConstant{ return uintConstant; }
        |   LongConstant(context):longConstant{ return longConstant; }
        |   ULongConstant(context):ulongConstant{ return ulongConstant; }
        |   FloatConstant(context):floatConstant{ return floatConstant; }
        |   DoubleConstant(context):doubleConstant{ return doubleConstant; }
        |   AddressConstant(context):addressConstant{ return addressConstant; }
        |   ArrayConstant(context, type):arrayConstant{ return arrayConstant; }
        |   StructureConstant(context, type):structureConstant{ return structureConstant; }
        |   StringConstant(context):stringConstant{ return stringConstant; }
        |   StringArrayConstant(context):stringArrayConstant{ return stringArrayConstant; }
        |   ConversionConstant(context):conversionConstant{ return conversionConstant; }
        |   SymbolConstant(context):symbolConstant{ return symbolConstant; }
        ;

    BoolConstant(intermediate.Context* context) : intermediate.Value*
        ::= BOOL
        (   TRUE{ return context->GetData()->GetBoolValue(true); }
        |   FALSE{ return context->GetData()->GetBoolValue(false); }
        )
        ;

    SByteConstant(Context* context) : intermediate.Value*
        ::= SBYTE NUMBER
        {
            Result<sbyte> result = intermediate.GetSByte(lexer.GetMatch(pos));
            if (result.Error()) return ErrorId(result.GetErrorId());
            return context->GetData()->GetSByteValue(result.Value());
        }
        ;

    ByteConstant(Context* context) : intermediate.Value*
        ::= BYTE NUMBER
        {
            Result<byte> result = intermediate.GetByte(lexer.GetMatch(pos));
            if (result.Error()) return ErrorId(result.GetErrorId());
            return context->GetData()->GetByteValue(result.Value());
        }
        ;

    ShortConstant(Context* context) : intermediate.Value*
        ::= SHORT NUMBER
        {
            Result<short> result = intermediate.GetShort(lexer.GetMatch(pos));
            if (result.Error()) return ErrorId(result.GetErrorId());
            return context->GetData()->GetShortValue(result.Value());
        }
        ;

    UShortConstant(Context* context) : intermediate.Value*
        ::= USHORT NUMBER
        {
            Result<ushort> result = intermediate.GetUShort(lexer.GetMatch(pos));
            if (result.Error()) return ErrorId(result.GetErrorId());
            return context->GetData()->GetUShortValue(result.Value());
        }
        ;

    IntConstant(Context* context) : intermediate.Value*
        ::= INT NUMBER
        {
            Result<int> result = intermediate.GetInt(lexer.GetMatch(pos));
            if (result.Error()) return ErrorId(result.GetErrorId());
            return context->GetData()->GetIntValue(result.Value());
        }
        ;

    UIntConstant(Context* context) : intermediate.Value*
        ::= UINT NUMBER
        {
            Result<uint> result = intermediate.GetUInt(lexer.GetMatch(pos));
            if (result.Error()) return ErrorId(result.GetErrorId());
            return context->GetData()->GetUIntValue(result.Value());
        }
        ;

    LongConstant(Context* context) : intermediate.Value*
        ::= LONG NUMBER
        {
            Result<long> result = intermediate.GetLong(lexer.GetMatch(pos));
            if (result.Error()) return ErrorId(result.GetErrorId());
            return context->GetData()->GetLongValue(result.Value());
        }
        ;

    ULongConstant(Context* context) : intermediate.Value*
        ::= ULONG NUMBER
        {
            Result<ulong> result = intermediate.GetULong(lexer.GetMatch(pos));
            if (result.Error()) return ErrorId(result.GetErrorId());
            return context->GetData()->GetULongValue(result.Value());
        }
        ;

    FloatConstant(Context* context) : intermediate.Value*
        ::= FLOAT NUMBER
        {
            Result<float> result = intermediate.GetFloat(lexer.GetMatch(pos));
            if (result.Error()) return ErrorId(result.GetErrorId());
            return context->GetData()->GetFloatValue(result.Value());
        }
        ;

    DoubleConstant(Context* context) : intermediate.Value*
        ::= DOUBLE NUMBER
        {
            Result<double> result = intermediate.GetDouble(lexer.GetMatch(pos));
            if (result.Error()) return ErrorId(result.GetErrorId());
            return context->GetData()->GetDoubleValue(result.Value());
        }
        ;

    AddressConstant(Context* context, var intermediate.TypeRef tref) : intermediate.Value*
        ::= TypeRef:typeRef
        {
            tref = typeRef;
            auto result = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos)); if (result.Error()) return ErrorId(result.GetErrorId());
        }
        (   NULL_TOKEN
            {
                return context->GetData()->GetNullValue(lexer.GetSpan(pos), tref.GetType());
            }
        |   ID
            {
                ustring s = lexer.GetMatch(pos);
                auto result = intermediate.GetString(s);
                string id;
                if (result.Error()) return ErrorId(result.GetErrorId());
                id = result.Value();
                Result<intermediate.Value*> addressValueResult = context->GetData()->MakeAddressValue(lexer.GetSpan(pos), tref.GetType(), id, false);
                if (addressValueResult.Error()) return ErrorId(addressValueResult.GetErrorId());
                return addressValueResult.Value();
            }
        )
        ;

    ArrayConstant(Context* context, Type* type, var intermediate.ArrayType* arrayType, var intermediate.Type* elementType, var System.Lex.Span span,
        var List<intermediate.Value*> elements) : intermediate.Value*
        ::= LBRACKET
            {
                span = lexer.GetSpan(pos);
                #assert(type->IsArrayType());
                arrayType = cast<intermediate.ArrayType*>(type);
                elementType = arrayType->ElementType();
            }
            (Constant(context, elementType):first{ elements.Add(first); }
            (COMMA Constant(context, elementType):next{ elements.Add(next); })*)?
            RBRACKET
        {
            return context->GetData()->MakeArrayValue(span, elements, arrayType);
        }
        ;

    StructureConstant(Context* context, Type* type, var int index, var intermediate.StructureType* structureType, var System.Lex.Span span, var List<intermediate.Value*> fieldValues) :
        intermediate.Value*
        ::= LBRACE
            {
                span = lexer.GetSpan(pos);
                #assert(type->IsStructureType());
                structureType = cast<intermediate.StructureType*>(type);
            }
            (Constant(context, structureType->FieldType(index++)):first{ fieldValues.Add(first); }
            (COMMA Constant(context, structureType->FieldType(index++)):next{ fieldValues.Add(next); })*)?
            RBRACE
        {
            return context->GetData()->MakeStructureValue(span, fieldValues, structureType);
        }
        ;

    StringConstant(Context* context, var System.Lex.Span span) : intermediate.Value*
        ::=
        (
            STRING{ span = lexer.GetSpan(pos); }
        )
        {
            Result<string> stringValue = ToUtf8(lexer.GetToken(pos).ToString());
            if (stringValue.Error()) return ErrorId(stringValue.GetErrorId());
            string s = Rvalue(stringValue.Value());
            Result<intermediate.Value*> valueResult = context->GetData()->MakeStringValue(span, s.Substring(1, s.Length() - 2));
            if (valueResult.Error()) return ErrorId(valueResult.GetErrorId());
            return valueResult.Value();
        }
        ;

    StringArrayConstant(Context* context, var System.Lex.Span span, var List<intermediate.Value*> strings) : intermediate.Value*
        ::= StringArrayPrefix:prefix{ span = lexer.GetSpan(pos); }
            LBRACKET
            (Constant(context, null):first{ strings.Add(first); }
            (COMMA Constant(context, null):next{ strings.Add(next); })*)?
            RBRACKET
        {
            return context->GetData()->MakeStringArrayValue(span, prefix, strings);
        }
        ;

    StringArrayPrefix : char
        ::= ID{ char prefix = lexer.GetChar(pos); pass = prefix == 'u' || prefix == 'w' || prefix == 'b'; if (pass) return prefix; }
        ;

    ConversionConstant(Context* context, var System.Lex.Span span, var intermediate.TypeRef tref) : intermediate.Value*
        ::= TypeRef:typeRef
        {
            tref = typeRef;
            span = lexer.GetSpan(pos);
            auto result = context->GetTypes()->ResolveType(tref, span); if (result.Error()) return ErrorId(result.GetErrorId());
        }
            CONV LPAREN Constant(context, null):from RPAREN
        {
            return context->GetData()->MakeConversionValue(span, tref.GetType(), from);
        }
        ;

    SymbolConstant(Context* context, var System.Lex.Span span, var intermediate.TypeRef tref) : intermediate.Value*
        ::= TypeRef:typeRef
        {
            tref = typeRef;
            auto result = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos)); if (result.Error()) return ErrorId(result.GetErrorId());
        }
        SymbolValue(context, tref.GetType()):symbolValue
        {
            return symbolValue;
        }
        ;

    Value(Context* context, Type* type) : intermediate.Value*
        ::= RegValue(context, type):regValue{ return regValue; }
        |   SymbolValue(context, type):symbolValue{ return symbolValue; }
        |   LiteralValue(context, type):literalValue{ return literalValue; }
        ;

    RegValue(Context* context, Type* type, var System.Lex.Span span) : intermediate.Value*
        ::= DOLLAR{ span = lexer.GetSpan(pos); }
            NUMBER
            {
                span.Union(lexer.GetSpan(pos));
                Result<int> regResult = lexer.GetInt(pos);
                if (regResult.Error()) return ErrorId(regResult.GetErrorId());
                int reg = regResult.Value();
                Result<intermediate.RegValue*> result = context->CurrentFunction()->GetRegRef(span, type, reg);
                if (result.Error()) return ErrorId(result.GetErrorId());
                return result.Value();
            }
        ;

    ResultRegValue(Context* context, Type* type, var System.Lex.Span span) : intermediate.RegValue*
        ::= DOLLAR{ span = lexer.GetSpan(pos); }
            NUMBER
            {
                span.Union(lexer.GetSpan(pos));
                Result<int> regResult = lexer.GetInt(pos);
                if (regResult.Error()) return ErrorId(regResult.GetErrorId());
                int reg = regResult.Value();
                Result<intermediate.RegValue*> regValueResult = context->CurrentFunction()->MakeRegValue(span, type, reg);
                if (regValueResult.Error()) return ErrorId(regValueResult.GetErrorId());
                return regValueResult.Value();
            }
        ;

    SymbolValue(Context* context, Type* type, var System.Lex.Span span) : intermediate.Value*
        ::= AT{ span = lexer.GetSpan(pos); }
            ID
            {
                Result<string> symbolResult = ToUtf8(lexer.GetToken(pos).ToString());
                if (symbolResult.Error()) return ErrorId(symbolResult.GetErrorId());
                string symbol = Rvalue(symbolResult.Value());
                span.Union(lexer.GetSpan(pos));
                return context->GetData()->MakeSymbolValue(span, type, symbol);
            }
        ;

    LiteralValue(Context* context, Type* type) : intermediate.Value*
        ::= TRUE{ return context->GetData()->GetBoolValue(true); }
        |   FALSE{ return context->GetData()->GetBoolValue(false); }
        |   NULL_TOKEN{ return context->GetData()->GetNullValue(lexer.GetSpan(pos), type); }
        |   NUMBER
            {
                Result<string> strResult = ToUtf8(lexer.GetMatch(pos));
                if (strResult.Error()) return ErrorId(strResult.GetErrorId());
                string str = Rvalue(strResult.Value());
                Result<intermediate.Value*> result = context->GetData()->MakeNumericLiteral(lexer.GetSpan(pos), type, str);
                if (result.Error()) return ErrorId(result.GetErrorId());
                return result.Value();
            }
        |   ID
            {
                Result<string> idResult = ToUtf8(lexer.GetToken(pos).ToString());
                if (idResult.Error()) return ErrorId(idResult.GetErrorId());
                string id = Rvalue(idResult.Value());
                Result<intermediate.Value*> addressValueResult = context->GetData()->MakeAddressValue(lexer.GetSpan(pos), type, id, true);
                if (addressValueResult.Error()) return ErrorId(addressValueResult.GetErrorId());
                return addressValueResult.Value();
            }
        ;

    Functions(intermediate.Context* context)
        ::=
        (   FunctionDeclaration(context):declaration
        |   FunctionDefinition(context):function
        )*
        ;

    FunctionDeclaration(intermediate.Context* context, var intermediate.TypeRef functionTypeRef, var Span span, var string functionId) : bool
        ::=
        (
            EXTERN{ span = lexer.GetSpan(pos); }
            FUNCTION
            TypeRef:typeRef
            {
                functionTypeRef = typeRef;
                auto result = context->GetTypes()->ResolveType(functionTypeRef, lexer.GetSpan(pos));
                if (result.Error()) return ErrorId(result.GetErrorId());
            }
            ID
            {
                Result<string> functionIdResult = ToUtf8(lexer.GetToken(pos).ToString());
                if (functionIdResult.Error()) return ErrorId(functionIdResult.GetErrorId());
                functionId = Rvalue(functionIdResult.Value());
            }
        )
        {
            context->GetCode()->AddFunctionDeclaration(span, functionTypeRef.GetType(), functionId);
            return true;
        }
        ;

    FunctionDefinition(intermediate.Context* context, var intermediate.Function* function)
        ::= FunctionHeader(context):header{ function = header; context->SetCurrentFunction(function); } LBRACE BasicBlock(context, function):basicBlock* RBRACE
        ;

    FunctionHeader(intermediate.Context* context, var intermediate.TypeRef functionTypeRef, var System.Lex.Span span, var string functionId, var bool inline_) : intermediate.Function*
        ::= (INLINE{ inline_ = true; })?
        (
            FUNCTION{ span = lexer.GetSpan(pos); }
            TypeRef:typeRef
            {
                functionTypeRef = typeRef;
                auto result = context->GetTypes()->ResolveType(functionTypeRef, lexer.GetSpan(pos));
                if (result.Error()) return ErrorId(result.GetErrorId());
            }
            ID
            {
                Result<string> functionIdResult = ToUtf8(lexer.GetToken(pos).ToString());
                if (functionIdResult.Error()) return ErrorId(functionIdResult.GetErrorId());
                functionId = Rvalue(functionIdResult.Value());
            }
            MetadataRef(context):mdRef?
        )
        {
            Result<intermediate.Function*> functionResult = context->GetCode()->AddFunctionDefinition(span, functionTypeRef.GetType(), functionId, inline_, mdRef);
            if (functionResult.Error()) return ErrorId(functionResult.GetErrorId());
            return functionResult.Value();
        }
        ;

    BasicBlock(intermediate.Context* context, intermediate.Function* function, var intermediate.BasicBlock* basicBlock, var System.Lex.Span span) : bool
        ::=
        (
            Label:id
            {
                span = lexer.GetSpan(pos);
                Result<intermediate.BasicBlock*> basicBlockResult = function->AddBasicBlock(span, id);
                if (basicBlockResult.Error()) return ErrorId(basicBlockResult.GetErrorId());
                basicBlock = basicBlockResult.Value();
            }
            Instructions(context, basicBlock):instructions
        )
        {
            return true;
        }
        ;

    Label : int
        ::= AT NUMBER{ Result<int> labelResult = lexer.GetInt(pos); if (labelResult.Error()) return ErrorId(labelResult.GetErrorId()); int label = labelResult.Value(); return label; }
        ;

    Operand(intermediate.Context* context, var intermediate.TypeRef tref) : intermediate.Value*
        ::= TypeRef:typeRef
            {
                tref = typeRef;
                auto result = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos));
                if (result.Error()) return ErrorId(result.GetErrorId());
            }
            Value(context, tref.GetType()):value
        {
            return value;
        }
        ;

    Instructions(intermediate.Context* context, intermediate.BasicBlock* basicBlock) : bool
        ::=
        (
            Instruction(context):instruction
            {
                auto result = basicBlock->AddInstruction(instruction);
                if (result.Error()) return ErrorId(result.GetErrorId());
            }
            (
                Instruction(context):next
                {
                    auto result = basicBlock->AddInstruction(next);
                    if (result.Error()) return ErrorId(result.GetErrorId());
                }
            )*
        )
        {
            return true;
        }
        ;

    Instruction(intermediate.Context* context) : intermediate.Instruction*
        ::= StoreInstruction(context):store{ return store; }
        |   ArgInstruction(context):arg{ return arg; }
        |   JmpInstruction(context):jmp{ return jmp; }
        |   BranchInstruction(context):branch{ return branch; }
        |   ProcedureCallInstruction(context):procedureCall{ return procedureCall; }
        |   RetInstruction(context):ret{ return ret; }
        |   SwitchInstruction(context):switch_{ return switch_; }
        |   ValueInstruction(context):valueInst{ return valueInst; }
        |   NoOperationInstruction(context):nopInst{ return nopInst; }
        ;

    StoreInstruction(intermediate.Context* context, var System.Lex.Span span, var intermediate.TypeRef tref, var intermediate.TypeRef ptref) : intermediate.Instruction*
        ::= STORE{ span = lexer.GetSpan(pos); }
            TypeRef:typeRef
            {
                tref = typeRef;
                auto result = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos)); if (result.Error()) return ErrorId(result.GetErrorId());
            }
            Value(context, tref.GetType()):value
            COMMA
            TypeRef:ptrTypeRef
            {
                ptref = ptrTypeRef;
                auto result = context->GetTypes()->ResolveType(ptref, lexer.GetSpan(pos)); if (result.Error()) return ErrorId(result.GetErrorId());
            }
            Value(context, ptref.GetType()):ptr
        {
            return new intermediate.StoreInstruction(span, value, ptr);
        }
        ;

    ArgInstruction(intermediate.Context* context, var System.Lex.Span span, var intermediate.TypeRef tref) : intermediate.Instruction*
        ::= ARG{ span = lexer.GetSpan(pos); }
            TypeRef:typeRef
            {
                tref = typeRef;
                auto result = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos)); if (result.Error()) return ErrorId(result.GetErrorId());
            }
            Value(context, tref.GetType()):arg
        {
            return new intermediate.ArgInstruction(span, arg);
        }
        ;

    JmpInstruction(intermediate.Context* context, var System.Lex.Span span) : intermediate.Instruction*
        ::= JMP{ span = lexer.GetSpan(pos); }
            Label:target
        {
            return new intermediate.JmpInstruction(span, target);
        }
        ;

    BranchInstruction(intermediate.Context* context, var System.Lex.Span span, var intermediate.TypeRef tref) : intermediate.Instruction*
        ::= BRANCH{ span = lexer.GetSpan(pos); }
            TypeRef:typeRef
            {
                tref = typeRef;
                auto result = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos)); if (result.Error()) return ErrorId(result.GetErrorId());
            }
            Value(context, tref.GetType()):cond
            COMMA
            Label:trueTarget
            COMMA
            Label:falseTarget
        {
            return new intermediate.BranchInstruction(span, cond, trueTarget, falseTarget);
        }
        ;

    ProcedureCallInstruction(intermediate.Context* context, var System.Lex.Span span, var intermediate.TypeRef tref) : intermediate.Instruction*
        ::= CALL{ span = lexer.GetSpan(pos); }
            TypeRef:typeRef
            {
                tref = typeRef;
                auto result = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos)); if (result.Error()) return ErrorId(result.GetErrorId());
            }
            Value(context, tref.GetType()):callee
        {
            return new intermediate.ProcedureCallInstruction(span, callee);
        }
        ;

    RetInstruction(intermediate.Context* context, var System.Lex.Span span, var intermediate.TypeRef tref) : intermediate.Instruction*
        ::= RET{ span = lexer.GetSpan(pos); }
        (   (VOID - (VOID AST)){ return new intermediate.RetInstruction(span, null); }
        |   TypeRef:typeRef
            {
                tref = typeRef;
                auto result = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos)); if (result.Error()) return ErrorId(result.GetErrorId());
            }
            Value(context, tref.GetType()):returnValue{ return new intermediate.RetInstruction(span, returnValue); }
        )
        ;

    Case(intermediate.Context* context, intermediate.SwitchInstruction* inst, var intermediate.TypeRef caseTref) : bool
        ::= TypeRef:caseTypeRef
            {
                caseTref = caseTypeRef;
                auto result = context->GetTypes()->ResolveType(caseTref, lexer.GetSpan(pos)); if (result.Error()) return ErrorId(result.GetErrorId());
            }
            Value(context, caseTref.GetType()):caseValue
            COMMA
            Label:caseTarget
            {
                inst->AddCaseTarget(intermediate.CaseTarget(caseValue, caseTarget));
                return true;
            }
        ;

    SwitchInstruction(intermediate.Context* context, var System.Lex.Span span, var intermediate.TypeRef tref,
        var intermediate.SwitchInstruction* inst) : intermediate.Instruction*
        ::= SWITCH{ span = lexer.GetSpan(pos); }
            TypeRef:typeRef
            {
                tref = typeRef;
                auto result = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos)); if (result.Error()) return ErrorId(result.GetErrorId());
            }
            Value(context, tref.GetType()):cond
            Label:defaultTarget{ inst = new intermediate.SwitchInstruction(span, cond, defaultTarget); }
            COMMA
            LBRACKET
            (
                Case(context, inst):first
                (
                    COLON
                    Case(context, inst):next
                )*
            )
            RBRACKET
        {
            return inst;
        }
        ;

    ValueInstruction(intermediate.Context* context, var System.Lex.Span span, var intermediate.TypeRef tref, var intermediate.RegValue* rslt) : intermediate.Instruction*
        ::= TypeRef:typeRef
            {
                tref = typeRef;
                auto result = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos)); if (result.Error()) return ErrorId(result.GetErrorId());
            }
            ResultRegValue(context, tref.GetType()):res{ rslt = res; }
            ASSIGN
            Operation(context, rslt):inst
        {
            return inst;
        }
        ;

    Operation(intermediate.Context* context, intermediate.RegValue* result) : intermediate.Instruction*
        ::= UnaryInstruction(context, result):unaryInst{ return unaryInst; }
        |   BinaryInstruction(context, result):binaryInst{ return binaryInst; }
        |   ParamInstruction(context, result):paramInst{ return paramInst; }
        |   LocalInstruction(context, result):localInst{ return localInst; }
        |   LoadInstruction(context, result):loadInst{ return loadInst; }
        |   ElemAddrInstruction(context, result):elemAddrInst{ return elemAddrInst; }
        |   PtrOffsetInstruction(context, result):ptrOffsetInst{ return ptrOffsetInst; }
        |   PtrDifftInstruction(context, result):ptrDifftInst{ return ptrDifftInst; }
        |   FunctionCallInstruction(context, result):functionCallInst{ return functionCallInst; }
        ;

    UnaryInstruction(intermediate.Context* context, intermediate.RegValue* result, var System.Lex.Span span) : intermediate.Instruction*
        ::= NOT{ span = lexer.GetSpan(pos); } Operand(context):notOp{ return new intermediate.NotInstruction(span, result, notOp); }
        |   NEG{ span = lexer.GetSpan(pos); } Operand(context):negOp{ return new intermediate.NegInstruction(span, result, negOp); }
        |   SIGNEXTEND{ span = lexer.GetSpan(pos); } Operand(context):sextOp{ return new intermediate.SignExtendInstruction(span, result, sextOp); }
        |   ZEROEXTEND{ span = lexer.GetSpan(pos); } Operand(context):zextOp{ return new intermediate.ZeroExtendInstruction(span, result, zextOp); }
        |   FPEXTEND{ span = lexer.GetSpan(pos); } Operand(context):fpextOp{ return new intermediate.FloatingPointExtendInstruction(span, result, fpextOp); }
        |   TRUNCATE{ span = lexer.GetSpan(pos); } Operand(context):truncOp{ return new intermediate.TruncateInstruction(span, result, truncOp); }
        |   BITCAST{ span = lexer.GetSpan(pos); } Operand(context):bcOp{ return new intermediate.BitcastInstruction(span, result, bcOp); }
        |   INTTOFLOAT{ span = lexer.GetSpan(pos); } Operand(context):ifOp{ return new intermediate.IntToFloatInstruction(span, result, ifOp); }
        |   FLOATTOINT{ span = lexer.GetSpan(pos); } Operand(context):fiOp{ return new intermediate.FloatToIntInstruction(span, result, fiOp); }
        |   INTTOPTR{ span = lexer.GetSpan(pos); } Operand(context):ipOp{ return new intermediate.IntToPtrInstruction(span, result, ipOp); }
        |   PTRTOINT{ span = lexer.GetSpan(pos); } Operand(context):piOp{ return new intermediate.PtrToIntInstruction(span, result, piOp); }
        ;

    BinaryInstruction(intermediate.Context* context, intermediate.RegValue* result, var System.Lex.Span span) : intermediate.Instruction*
        ::=
        (   ADD{ span = lexer.GetSpan(pos); }
            Operand(context):leftAdd
            COMMA
            Operand(context):rightAdd
        )
        {
            return new intermediate.AddInstruction(span, result, leftAdd, rightAdd);
        }
        |
        (   SUB{ span = lexer.GetSpan(pos); }
            Operand(context):leftSub
            COMMA
            Operand(context):rightSub
        )
        {
            return new intermediate.SubInstruction(span, result, leftSub, rightSub);
        }
        |
        (   MUL{ span = lexer.GetSpan(pos); }
            Operand(context):leftMul
            COMMA
            Operand(context):rightMul
        )
        {
            return new intermediate.MulInstruction(span, result, leftMul, rightMul);
        }
        |
        (   DIV{ span = lexer.GetSpan(pos); }
            Operand(context):leftDiv
            COMMA
            Operand(context):rightDiv
        )
        {
            return new intermediate.DivInstruction(span, result, leftDiv, rightDiv);
        }
        |
        (   MOD{ span = lexer.GetSpan(pos); }
            Operand(context):leftMod
            COMMA
            Operand(context):rightMod
        )
        {
            return new intermediate.ModInstruction(span, result, leftMod, rightMod);
        }
        |
        (   AND{ span = lexer.GetSpan(pos); }
            Operand(context):leftAnd
            COMMA
            Operand(context):rightAnd
        )
        {
            return new intermediate.AndInstruction(span, result, leftAnd, rightAnd);
        }
        |
        (   OR{ span = lexer.GetSpan(pos); }
            Operand(context):leftOr
            COMMA
            Operand(context):rightOr
        )
        {
            return new intermediate.OrInstruction(span, result, leftOr, rightOr);
        }
        |
        (   XOR{ span = lexer.GetSpan(pos); }
            Operand(context):leftXor
            COMMA
            Operand(context):rightXor
        )
        {
            return new intermediate.XorInstruction(span, result, leftXor, rightXor);
        }
        |
        (   SHL{ span = lexer.GetSpan(pos); }
            Operand(context):leftShl
            COMMA
            Operand(context):rightShl
        )
        {
            return new intermediate.ShlInstruction(span, result, leftShl, rightShl);
        }
        |
        (   SHR{ span = lexer.GetSpan(pos); }
            Operand(context):leftShr
            COMMA
            Operand(context):rightShr
        )
        {
            return new intermediate.ShrInstruction(span, result, leftShr, rightShr);
        }
        |
        (   EQUAL{ span = lexer.GetSpan(pos); }
            Operand(context):leftEqual
            COMMA
            Operand(context):rightEqual
        )
        {
            return new intermediate.EqualInstruction(span, result, leftEqual, rightEqual);
        }
        |
        (   LESS{ span = lexer.GetSpan(pos); }
            Operand(context):leftLess
            COMMA
            Operand(context):rightLess
        )
        {
            return new intermediate.LessInstruction(span, result, leftLess, rightLess);
        }
        ;

    ParamInstruction(intermediate.Context* context, intermediate.RegValue* result, var System.Lex.Span span) : intermediate.Instruction*
        ::= PARAM{ span = lexer.GetSpan(pos); return new intermediate.ParamInstruction(span, result); }
        ;

    LocalInstruction(intermediate.Context* context, intermediate.RegValue* result, var System.Lex.Span span, var intermediate.TypeRef tref) : intermediate.Instruction*
        ::= LOCAL{ span = lexer.GetSpan(pos); }
            TypeRef:typeRef
            {
                tref = typeRef;
                auto res = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos)); if (res.Error()) return ErrorId(res.GetErrorId());
                return new intermediate.LocalInstruction(span, result, tref.GetType());
            }
        ;

    LoadInstruction(intermediate.Context* context, intermediate.RegValue* result, var System.Lex.Span span) : intermediate.Instruction*
        ::= LOAD{ span = lexer.GetSpan(pos); }
            Operand(context):ptr{ return new intermediate.LoadInstruction(span, result, ptr); }
        ;

    ElemAddrInstruction(intermediate.Context* context, intermediate.RegValue* result, var System.Lex.Span span) : intermediate.Instruction*
        ::= ELEMADDR{ span = lexer.GetSpan(pos); }
            Operand(context):ptr
            COMMA
            Operand(context):index
        {
            return new intermediate.ElemAddrInstruction(span, result, ptr, index);
        }
        ;

    PtrOffsetInstruction(intermediate.Context* context, intermediate.RegValue* result, var System.Lex.Span span) : intermediate.Instruction*
        ::= PTROFFSET{ span = lexer.GetSpan(pos); }
            Operand(context):ptr
            COMMA
            Operand(context):offset
        {
            return new intermediate.PtrOffsetInstruction(span, result, ptr, offset);
        }
        ;

    PtrDifftInstruction(intermediate.Context* context, intermediate.RegValue* result, var System.Lex.Span span) : intermediate.Instruction*
        ::= PTRDIFF{ span = lexer.GetSpan(pos); }
            Operand(context):leftPtr
            COMMA
            Operand(context):rightPtr
        {
            return new intermediate.PtrDiffInstruction(span, result, leftPtr, rightPtr);
        }
        ;

    FunctionCallInstruction(intermediate.Context* context, intermediate.RegValue* result, var System.Lex.Span span, var intermediate.TypeRef tref) : intermediate.Instruction*
        ::= CALL{ span = lexer.GetSpan(pos); }
            TypeRef:typeRef
            {
                tref = typeRef;
                auto res = context->GetTypes()->ResolveType(tref, lexer.GetSpan(pos)); if (res.Error()) return ErrorId(res.GetErrorId());
            }
            Value(context, tref.GetType()):callee
        {
            return new intermediate.FunctionCallInstruction(span, result, callee);
        }
        ;

    NoOperationInstruction(intermediate.Context* context, var System.Lex.Span span) : intermediate.Instruction*
        ::= NOP{ span = lexer.GetSpan(pos); return new intermediate.NoOperationInstruction(span); }
        ;

    Metadata(intermediate.Context* context) : bool
        ::= METADATA LBRACE MetadataStruct(context):mds* RBRACE
        {
            Result<bool> result = context->GetMetadata()->ResolveReferences();
            if (result.Error()) return ErrorId(result.GetErrorId());
            return true;
        }
        ;

    MetadataStruct(intermediate.Context* context, var intermediate.MetadataStruct* value) : bool
        ::=
        (
            EXCLAMATION NUMBER
            {
                Result<int> nodeIdResult = lexer.GetInt(pos);
                if (nodeIdResult.Error()) return ErrorId(nodeIdResult.GetErrorId());
                int nodeId = nodeIdResult.Value();
                Result<intermediate.MetadataStruct*> result = context->GetMetadata()->AddMetadataStruct(lexer.GetSpan(pos), nodeId);
                if (result.Error()) return ErrorId(result.GetErrorId());
                value = result.Value();
            }
            ASSIGN
            LBRACE
            (MetadataField(context, value):first (COMMA MetadataField(context, value):next)*)?
            RBRACE
        )
        {
            return true;
        }
        ;

    MetadataField(intermediate.Context* context, intermediate.MetadataStruct* parent, var string fieldName) : bool
        ::=
        (
            ID
            {
                Result<string> fieldNameResult = ToUtf8(lexer.GetMatch(pos));
                if (fieldNameResult.Error()) return ErrorId(fieldNameResult.GetErrorId());
                fieldName = Rvalue(fieldNameResult.Value());
            }
            COLON
            MetadataItem(context):item{ parent->AddItem(fieldName, item); }
        )
        {
            return true;
        }
        ;

    MetadataItem(intermediate.Context* context) : intermediate.MetadataItem*
        ::= MetadataBool(context):mdBool{ return mdBool; }
        |   MetadataLong(context):mdLong{ return mdLong; }
        |   MetadataString(context):mdString{ return mdString; }
        |   MetadataRef(context):mdRef{ return mdRef; }
        ;

    MetadataBool(intermediate.Context* context) : intermediate.MetadataItem*
        ::= TRUE{ return context->GetMetadata()->CreateMetadataBool(true); }
        |   FALSE{ return context->GetMetadata()->CreateMetadataBool(false); }
        ;

    MetadataLong(intermediate.Context* context) : intermediate.MetadataItem*
        ::= NUMBER
            {
                Result<long> result = intermediate.GetLong(lexer.GetMatch(pos));
                if (result.Error()) return ErrorId(result.GetErrorId());
                long value = result.Value();
                return context->GetMetadata()->CreateMetadataLong(value);
            }
        ;

    MetadataString(intermediate.Context* context) : intermediate.MetadataItem*
        ::= STRING
            {
                Result<string> result = intermediate.GetString(lexer.GetMatch(pos));
                if (result.Error()) return ErrorId(result.GetErrorId());
                string value = Rvalue(result.Value());
                return context->GetMetadata()->CreateMetadataString(value, true);
            }
        ;

    MetadataRef(intermediate.Context* context) : intermediate.MetadataRef*
        ::= EXCLAMATION NUMBER
        {
            Result<int> nodeIdResult = lexer.GetInt(pos);
            if (nodeIdResult.Error()) return ErrorId(nodeIdResult.GetErrorId());
            int nodeId = nodeIdResult.Value();
            return context->GetMetadata()->CreateMetadataRef(lexer.GetSpan(pos), nodeId);
        }
        ;
}
