// =================================
// Copyright (c) 2024 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using symbols;
using cm.ast;

namespace binder
{
    public const int maxGeneratedInlineFunctionMembers = 4;

    public enum CollectFlags : byte
    {
        none = 0u, noRvalueRef = 1u << 0u, dontInstantiate = 1u << 1u
    }

    public inline bool GetCollectFlag(CollectFlags flags, CollectFlags flag)
    {
        return cast<CollectFlags>(flags & flag) != CollectFlags.none;
    }

    public inline void SetCollectFlag(CollectFlags& flags, CollectFlags flag)
    {
        flags = cast<CollectFlags>(flags | flag);
    }

    public abstract class Operation
    {
        public Operation(const ustring& groupName_, int arity_, BoundCompileUnit* boundCompileUnit_) :
            groupName(groupName_), arity(arity_), boundCompileUnit(boundCompileUnit_), symbolTable(boundCompileUnit->GetSymbolTable())
        {
        }
        public inline const ustring& GroupName() const
        {
            return groupName;
        }
        public inline int Arity() const
        {
            return arity;
        }
        public inline BoundCompileUnit* GetBoundCompileUnit() const
        {
            return boundCompileUnit;
        }
        public inline SymbolTable* GetSymbolTable() const
        {
            return symbolTable;
        }
        public inline SymbolsContext& Context()
        {
            return boundCompileUnit->Context();
        }
        public inline Module* GetModule() const
        {
            return symbolTable->GetModule();
        }
        [nodiscard]
        public abstract Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions);
        private ustring groupName;
        private int arity;
        private BoundCompileUnit* boundCompileUnit;
        private SymbolTable* symbolTable;
    }

    public class PointerDefaultCtor : FunctionSymbol
    {
        public PointerDefaultCtor(const System.Lex.Span& span_, TypeSymbol* type_, SymbolsContext& context) : base(span_, u"@constructor"), type(type_)
        {
            #assert(type->IsPointerType());
            SetGroupName(u"@constructor");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(type->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 1);
            Result<intermediate.Type*> irTypeResult = type->IrType(emitter);
            if (irTypeResult.Error()) return Result<bool>(ErrorId(irTypeResult.GetErrorId()));
            intermediate.Type* irType = irTypeResult.Value();
            intermediate.Value* nullValue = emitter.GetNullValue(cast<intermediate.PointerType*>(irType));
            IrObject* target = irObjects[0];
            Result<bool> result = target->Store(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        private TypeSymbol* type;
    }

    public class PointerDefaultConstructorOperation : Operation
    {
        public PointerDefaultConstructorOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@constructor", 1, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (type->PointerCount() <= 1) return Result<bool>(false);
            if (type->IsReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            SymbolsContext& context = Context();
            TypeSymbol* pointerType = type->RemovePointer(context);
            FunctionSymbol* function = functionMap[pointerType];
            if (function == null)
            {
                function = new PointerDefaultCtor(node->GetSpan(), pointerType, context);
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[pointerType] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class PointerCopyCtor : FunctionSymbol
    {
        public PointerCopyCtor(const System.Lex.Span& span_, TypeSymbol* type, SymbolsContext& context) :  base(span_, u"@constructor")
        {
            #assert(type->IsPointerType());
            SetGroupName(u"@constructor");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(type->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(type);
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* source = irObjects[1];
            Result<bool> result = source->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            if (GetFlag(flags, OperationFlags.leaveFirstArg))
            {
                emitter.Stack().Dup();
                intermediate.Value* ptr = emitter.Stack().Pop();
                emitter.SaveObjectPointer(ptr);
            }
            IrObject* target = irObjects[0];
            result = target->Store(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class PointerCopyConstructorOperation : Operation
    {
        public PointerCopyConstructorOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@constructor", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (type->PointerCount() <= 1) return Result<bool>(false);
            if (type->IsReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            SymbolsContext& context = Context();
            TypeSymbol* pointerType = type->RemovePointer(context);
            if (GetCollectFlag(flags, CollectFlags.noRvalueRef) ||
                !TypesEqual(arguments[1]->Type(), pointerType->AddRvalueReference(context)) && !arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference))
            {
                FunctionSymbol* function = functionMap[pointerType];
                if (function == null)
                {
                    function = new PointerCopyCtor(node->GetSpan(), pointerType, context);
                    if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                    function->SetModule(GetModule());
                    function->SetParent(&GetSymbolTable()->GlobalNs());
                    functionMap[pointerType] = function;
                    functions.Add(UniquePtr<FunctionSymbol>(function));
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class PointerMoveCtor : FunctionSymbol
    {
        public PointerMoveCtor(const System.Lex.Span& span_, TypeSymbol* type, SymbolsContext& context) :  base(span_, u"@constructor")
        {
            #assert(type->IsPointerType());
            SetGroupName(u"@constructor");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(type->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(type->AddRvalueReference(context));
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* source = irObjects[1];
            Result<bool> result = source->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* rvalueRefValue = emitter.Stack().Pop();
            Result<intermediate.Value*> loadResult = emitter.CreateLoad(rvalueRefValue);
            if (loadResult.Error()) return Result<bool>(ErrorId(loadResult.GetErrorId()));
            intermediate.Value* ptr = loadResult.Value();
            emitter.Stack().Push(ptr);
            if (GetFlag(flags, OperationFlags.leaveFirstArg))
            {
                emitter.Stack().Dup();
                intermediate.Value* ptr = emitter.Stack().Pop();
                emitter.SaveObjectPointer(ptr);
            }
            IrObject* target = irObjects[0];
            result = target->Store(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class PointerMoveConstructorOperation : Operation
    {
        public PointerMoveConstructorOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@constructor", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (type->PointerCount() <= 1) return Result<bool>(false);
            if (type->IsReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            SymbolsContext& context = Context();
            TypeSymbol* pointerType = type->RemovePointer(context);
            if (TypesEqual(arguments[1]->Type(), pointerType->AddRvalueReference(context)) || arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference))
            {
                FunctionSymbol* function = functionMap[pointerType];
                if (function == null)
                {
                    function = new PointerMoveCtor(node->GetSpan(), pointerType, context);
                    if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                    function->SetModule(GetModule());
                    function->SetParent(&GetSymbolTable()->GlobalNs());
                    functionMap[pointerType] = function;
                    functions.Add(UniquePtr<FunctionSymbol>(function));
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class PointerCopyAssignment : FunctionSymbol
    {
        public PointerCopyAssignment(const System.Lex.Span& span_, TypeSymbol* type, TypeSymbol* voidType, SymbolsContext& context) :  base(span_, u"operator=")
        {
            #assert(type->IsPointerType());
            SetGroupName(u"operator=");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(type->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(type);
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(voidType);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* source = irObjects[1];
            Result<bool> result = source->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            IrObject* target = irObjects[0];
            result = target->Store(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class PointerCopyAssignmentOperation : Operation
    {
        public PointerCopyAssignmentOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator=", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (type->PointerCount() <= 1) return Result<bool>(false);
            if (type->IsReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            SymbolsContext& context = Context();
            TypeSymbol* pointerType = type->RemovePointer(context);
            if (GetCollectFlag(flags, CollectFlags.noRvalueRef) ||
                !TypesEqual(arguments[1]->Type(), pointerType->AddRvalueReference(context)) && !arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference))
            {
                FunctionSymbol* function = functionMap[pointerType];
                if (function == null)
                {
                    Result<TypeSymbol*> voidTypeResult = GetSymbolTable()->GetTypeByName(u"void");
                    if (voidTypeResult.Error()) return Result<bool>(ErrorId(voidTypeResult.GetErrorId()));
                    TypeSymbol* voidType = voidTypeResult.Value();
                    function = new PointerCopyAssignment(node->GetSpan(), pointerType, voidType, context);
                    if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                    function->SetModule(GetModule());
                    function->SetParent(&GetSymbolTable()->GlobalNs());
                    functionMap[pointerType] = function;
                    functions.Add(UniquePtr<FunctionSymbol>(function));
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class PointerMoveAssignment : FunctionSymbol
    {
        public PointerMoveAssignment(const System.Lex.Span& span_, TypeSymbol* type, TypeSymbol* voidType, SymbolsContext& context) :  base(span_, u"operator=")
        {
            #assert(type->IsPointerType());
            SetGroupName(u"operator=");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(type->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(type->AddRvalueReference(context));
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(voidType);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* source = irObjects[1];
            Result<bool> result = source->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* rvalueRefValue = emitter.Stack().Pop();
            Result<intermediate.Value*> loadResult = emitter.CreateLoad(rvalueRefValue);
            if (loadResult.Error()) return Result<bool>(ErrorId(loadResult.GetErrorId()));
            intermediate.Value* ptr = loadResult.Value();
            emitter.Stack().Push(ptr);
            IrObject* target = irObjects[0];
            result = target->Store(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class PointerMoveAssignmentOperation : Operation
    {
        public PointerMoveAssignmentOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator=", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (type->PointerCount() <= 1) return Result<bool>(false);
            if (type->IsReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            SymbolsContext& context = Context();
            TypeSymbol* pointerType = type->RemovePointer(context);
            if (TypesEqual(arguments[1]->Type(), pointerType->AddRvalueReference(context)) || arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference))
            {
                FunctionSymbol* function = functionMap[pointerType];
                if (function == null)
                {
                    Result<TypeSymbol*> voidTypeResult = GetSymbolTable()->GetTypeByName(u"void");
                    if (voidTypeResult.Error()) return Result<bool>(ErrorId(voidTypeResult.GetErrorId()));
                    TypeSymbol* voidType = voidTypeResult.Value();
                    function = new PointerMoveAssignment(node->GetSpan(), pointerType, voidType, context);
                    if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                    function->SetModule(GetModule());
                    function->SetParent(&GetSymbolTable()->GlobalNs());
                    functionMap[pointerType] = function;
                    functions.Add(UniquePtr<FunctionSymbol>(function));
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class PointerReturn : FunctionSymbol
    {
        public PointerReturn(const System.Lex.Span& span_, TypeSymbol* type, SymbolsContext& context) : base(span_, u"@return")
        {
            SetGroupName(u"@return");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* valueParam = new ParameterSymbol(span_, u"value");
            valueParam->SetType(type);
            Result<bool> result = AddMember(valueParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(type);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 1);
            IrObject* source = irObjects[0];
            Result<bool> result = source->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            if (GetFlag(flags, OperationFlags.leaveFirstArg))
            {
                emitter.Stack().Dup();
                intermediate.Value* ptr = emitter.Stack().Pop();
                emitter.SaveObjectPointer(ptr);
            }
            return Result<bool>(true);
        }
    }

    public class PointerReturnOperation : Operation
    {
        public PointerReturnOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@return", 1, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (!type->IsPointerType()) return Result<bool>(false);
            if (type->IsReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            FunctionSymbol* function = functionMap[type];
            if (function == null)
            {
                SymbolsContext& context = Context();
                function = new PointerReturn(node->GetSpan(), type, context);
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[type] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class PointerPlusOffset : FunctionSymbol
    {
        public PointerPlusOffset(const System.Lex.Span& span_, TypeSymbol* type, TypeSymbol* longType, SymbolsContext& context) : base(span_, u"operator+")
        {
            SetGroupName(u"operator+");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* leftParam = new ParameterSymbol(span_, u"left");
            leftParam->SetType(type);
            Result<bool> result = AddMember(leftParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* rightParam = new ParameterSymbol(span_, u"right");
            rightParam->SetType(longType);
            result = AddMember(rightParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(type);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* leftObject = irObjects[0];
            Result<bool> result = leftObject->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* left = emitter.Stack().Pop();
            IrObject* rightObject = irObjects[1];
            result = rightObject->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* right = emitter.Stack().Pop();
            Result<intermediate.Value*> valueResult = emitter.CreatePtrOffset(left, right);
            if (valueResult.Error()) return Result<bool>(ErrorId(valueResult.GetErrorId()));
            intermediate.Value* value = valueResult.Value();
            emitter.Stack().Push(value);
            return Result<bool>(true);
        }
    }

    public class PointerPlusOffsetOperation : Operation
    {
        public PointerPlusOffsetOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator+", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* leftType = arguments[0]->Type();
            if (!leftType->IsPointerType()) return Result<bool>(false);
            SymbolsContext& context = Context();
            leftType = leftType->PlainType(context);
            TypeSymbol* rightType = arguments[1]->Type();
            Result<TypeSymbol*> longTypeResult = GetSymbolTable()->GetTypeByName(u"long");
            if (longTypeResult.Error()) return Result<bool>(ErrorId(longTypeResult.GetErrorId()));
            TypeSymbol* longType = longTypeResult.Value();
            if (!rightType->PlainType(context)->IsIntegralType())
            {
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> conversionResult = GetConversion(rightType, longType, containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (conversionResult.Error()) return Result<bool>(ErrorId(conversionResult.GetErrorId()));
            }
            if (leftType->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(leftType->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            FunctionSymbol* function = functionMap[leftType];
            if (function == null)
            {
                function = new PointerPlusOffset(node->GetSpan(), leftType, longType, context);
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[leftType] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class OffsetPlusPointer : FunctionSymbol
    {
        public OffsetPlusPointer(const System.Lex.Span& span_, TypeSymbol* type, TypeSymbol* longType, SymbolsContext& context) : base(span_, u"operator+")
        {
            SetGroupName(u"operator+");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* leftParam = new ParameterSymbol(span_, u"left");
            leftParam->SetType(longType);
            Result<bool> result = AddMember(leftParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* rightParam = new ParameterSymbol(span_, u"right");
            rightParam->SetType(type);
            result = AddMember(rightParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(type);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* leftObject = irObjects[0];
            Result<bool> result = leftObject->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* left = emitter.Stack().Pop();
            IrObject* rightObject = irObjects[1];
            result = rightObject->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* right = emitter.Stack().Pop();
            Result<intermediate.Value*> valueResult = emitter.CreatePtrOffset(right, left);
            if (valueResult.Error()) return Result<bool>(ErrorId(valueResult.GetErrorId()));
            intermediate.Value* value = valueResult.Value();
            emitter.Stack().Push(value);
            return Result<bool>(true);
        }
    }

    public class OffsetPlusPointerOperation : Operation
    {
        public OffsetPlusPointerOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator+", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            Result<TypeSymbol*> longTypeResult = GetSymbolTable()->GetTypeByName(u"long");
            if (longTypeResult.Error()) return Result<bool>(ErrorId(longTypeResult.GetErrorId()));
            TypeSymbol* longType = longTypeResult.Value();
            TypeSymbol* leftType = arguments[0]->Type();
            if (!leftType->PlainType(context)->IsIntegralType())
            {
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> conversionResult = GetConversion(leftType, longType, containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (conversionResult.Error()) return Result<bool>(ErrorId(conversionResult.GetErrorId()));
            }
            SymbolsContext& context = Context();
            TypeSymbol* rightType = arguments[1]->Type();
            if (!rightType->IsPointerType()) return Result<bool>(false);
            rightType = rightType->PlainType(context);
            if (rightType->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(rightType->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            FunctionSymbol* function = functionMap[rightType];
            if (function == null)
            {
                function = new OffsetPlusPointer(node->GetSpan(), rightType, longType, context);
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[rightType] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class PointerMinusOffset : FunctionSymbol
    {
        public PointerMinusOffset(const System.Lex.Span& span_, TypeSymbol* type, TypeSymbol* longType, SymbolsContext& context) : base(span_, u"operator-")
        {
            SetGroupName(u"operator-");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* leftParam = new ParameterSymbol(span_, u"left");
            leftParam->SetType(type);
            Result<bool> result = AddMember(leftParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* rightParam = new ParameterSymbol(span_, u"right");
            rightParam->SetType(longType);
            result = AddMember(rightParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(type);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* leftObject = irObjects[0];
            Result<bool> result = leftObject->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* left = emitter.Stack().Pop();
            IrObject* rightObject = irObjects[1];
            result = rightObject->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* right = emitter.Stack().Pop();
            Result<intermediate.Value*> negResult = emitter.CreateNeg(right);
            if (negResult.Error()) return Result<bool>(ErrorId(negResult.GetErrorId()));
            intermediate.Value* offset = negResult.Value();
            Result<intermediate.Value*> valueResult = emitter.CreatePtrOffset(left, offset);
            if (valueResult.Error()) return Result<bool>(ErrorId(valueResult.GetErrorId()));
            intermediate.Value* value = valueResult.Value();
            emitter.Stack().Push(value);
            return Result<bool>(true);
        }
    }

    public class PointerMinusOffsetOperation : Operation
    {
        public PointerMinusOffsetOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator-", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* leftType = arguments[0]->Type();
            if (!leftType->IsPointerType()) return Result<bool>(false);
            SymbolsContext& context = Context();
            leftType = leftType->PlainType(context);
            TypeSymbol* rightType = arguments[1]->Type();
            Result<TypeSymbol*> longTypeResult = GetSymbolTable()->GetTypeByName(u"long");
            if (longTypeResult.Error()) return Result<bool>(ErrorId(longTypeResult.GetErrorId()));
            TypeSymbol* longType = longTypeResult.Value();
            if (!rightType->PlainType(context)->IsIntegralType())
            {
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> conversionResult = GetConversion(rightType, longType, containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (conversionResult.Error()) return Result<bool>(ErrorId(conversionResult.GetErrorId()));
            }
            if (leftType->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(leftType->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            FunctionSymbol* function = functionMap[leftType];
            if (function == null)
            {
                function = new PointerMinusOffset(node->GetSpan(), leftType, longType, context);
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[leftType] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class PointerMinusPointer : FunctionSymbol
    {
        public PointerMinusPointer(const System.Lex.Span& span_, TypeSymbol* type, TypeSymbol* longType, SymbolsContext& context) : base(span_, u"operator-")
        {
            SetGroupName(u"operator-");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* leftParam = new ParameterSymbol(span_, u"left");
            leftParam->SetType(type);
            Result<bool> result = AddMember(leftParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* rightParam = new ParameterSymbol(span_, u"right");
            rightParam->SetType(type);
            result = AddMember(rightParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(longType);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* leftObject = irObjects[0];
            Result<bool> result = leftObject->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* left = emitter.Stack().Pop();
            IrObject* rightObject = irObjects[1];
            result = rightObject->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* right = emitter.Stack().Pop();
            Result<intermediate.Value*> ptrDiff = emitter.CreatePtrDiff(left, right);
            if (ptrDiff.Error()) return Result<bool>(ErrorId(ptrDiff.GetErrorId()));
            emitter.Stack().Push(ptrDiff.Value());
            return Result<bool>(true);
        }
    }

    public class PointerMinusPointerOperation : Operation
    {
        public PointerMinusPointerOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator-", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* leftType = arguments[0]->Type();
            if (!leftType->IsPointerType()) return Result<bool>(false);
            SymbolsContext& context = Context();
            leftType = leftType->PlainType(context);
            TypeSymbol* rightType = arguments[1]->Type();
            if (!rightType->IsPointerType()) return Result<bool>(false);
            rightType = rightType->PlainType(context);
            if (leftType->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(leftType->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            FunctionSymbol* function = functionMap[leftType];
            if (function == null)
            {
                Result<TypeSymbol*> longTypeResult = GetSymbolTable()->GetTypeByName(u"long");
                if (longTypeResult.Error()) return Result<bool>(ErrorId(longTypeResult.GetErrorId()));
                TypeSymbol* longType = longTypeResult.Value();
                function = new PointerMinusPointer(node->GetSpan(), leftType, longType, context);
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[leftType] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class PointerEqual : FunctionSymbol
    {
        public PointerEqual(const System.Lex.Span& span_, TypeSymbol* type, TypeSymbol* boolType, SymbolsContext& context) : base(span_, u"operator==")
        {
            SetGroupName(u"operator==");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* leftParam = new ParameterSymbol(span_, u"left");
            leftParam->SetType(type);
            Result<bool> result = AddMember(leftParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* rightParam = new ParameterSymbol(span_, u"right");
            rightParam->SetType(type);
            result = AddMember(rightParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(boolType);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* leftObject = irObjects[0];
            Result<bool> result = leftObject->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* left = emitter.Stack().Pop();
            IrObject* rightObject = irObjects[1];
            result = rightObject->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* right = emitter.Stack().Pop();
            Result<intermediate.Value*> equalResult = emitter.CreateEqual(left, right);
            if (equalResult.Error()) return Result<bool>(ErrorId(equalResult.GetErrorId()));
            emitter.Stack().Push(equalResult.Value());
            return Result<bool>(true);
        }
    }

    public class PointerEqualOperation : Operation
    {
        public PointerEqualOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator==", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* leftType = arguments[0]->Type();
            if (!leftType->IsPointerType()) return Result<bool>(false);
            SymbolsContext& context = Context();
            leftType = leftType->PlainType(context);
            TypeSymbol* rightType = arguments[1]->Type();
            if (!rightType->IsPointerType()) return Result<bool>(false);
            rightType = rightType->PlainType(context);
            if (leftType->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(leftType->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            FunctionSymbol* function = functionMap[leftType];
            if (function == null)
            {
                Result<TypeSymbol*> boolTypeResult = GetSymbolTable()->GetTypeByName(u"bool");
                if (boolTypeResult.Error()) return Result<bool>(ErrorId(boolTypeResult.GetErrorId()));
                TypeSymbol* boolType = boolTypeResult.Value();
                function = new PointerEqual(node->GetSpan(), leftType, boolType, context);
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[leftType] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class PointerLess : FunctionSymbol
    {
        public PointerLess(const System.Lex.Span& span_, TypeSymbol* type, TypeSymbol* boolType, SymbolsContext& context) : base(span_, u"operator<")
        {
            SetGroupName(u"operator<");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* leftParam = new ParameterSymbol(span_, u"left");
            leftParam->SetType(type);
            Result<bool> result = AddMember(leftParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* rightParam = new ParameterSymbol(span_, u"right");
            rightParam->SetType(type);
            result = AddMember(rightParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(boolType);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* leftObject = irObjects[0];
            Result<bool> result = leftObject->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* left = emitter.Stack().Pop();
            IrObject* rightObject = irObjects[1];
            result = rightObject->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* right = emitter.Stack().Pop();
            Result<intermediate.Value*> lessResult = emitter.CreateLess(left, right);
            if (lessResult.Error()) return Result<bool>(ErrorId(lessResult.GetErrorId()));
            emitter.Stack().Push(lessResult.Value());
            return Result<bool>(true);
        }
    }

    public class PointerLessOperation : Operation
    {
        public PointerLessOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator<", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* leftType = arguments[0]->Type();
            if (!leftType->IsPointerType()) return Result<bool>(false);
            SymbolsContext& context = Context();
            leftType = leftType->PlainType(context);
            TypeSymbol* rightType = arguments[1]->Type();
            if (!rightType->IsPointerType()) return Result<bool>(false);
            rightType = rightType->PlainType(context);
            if (leftType->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(leftType->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            FunctionSymbol* function = functionMap[leftType];
            if (function == null)
            {
                Result<TypeSymbol*> boolTypeResult = GetSymbolTable()->GetTypeByName(u"bool");
                if (boolTypeResult.Error()) return Result<bool>(ErrorId(boolTypeResult.GetErrorId()));
                TypeSymbol* boolType = boolTypeResult.Value();
                function = new PointerLess(node->GetSpan(), leftType, boolType, context);
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[leftType] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class PointerArrow : FunctionSymbol
    {
        public PointerArrow(const System.Lex.Span& span_, TypeSymbol* type, SymbolsContext& context) : base(span_, u"operator->")
        {
            SetGroupName(u"operator->");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* operandParam = new ParameterSymbol(span_, u"operand");
            operandParam->SetType(type->AddPointer(context));
            Result<bool> result = AddMember(operandParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(type);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 1);
            IrObject* source = irObjects[0];
            Result<bool> result = source->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class PointerArrowOperation : Operation
    {
        public PointerArrowOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator->", 1, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (type->PointerCount() <= 1) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            SymbolsContext& context = Context();
            TypeSymbol* pointerType = type->RemovePointer(context);
            FunctionSymbol* function = functionMap[pointerType];
            if (function == null)
            {
                function = new PointerArrow(node->GetSpan(), pointerType, context);
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[pointerType] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class LvalueRefefenceCopyCtor : FunctionSymbol
    {
        public LvalueRefefenceCopyCtor(const System.Lex.Span& span_, TypeSymbol* type, SymbolsContext& context) : base(span_, u"@constructor")
        {
            SetGroupName(u"@constructor");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(type->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(type);
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* source = irObjects[1];
            IrObject* target = irObjects[0];
            Result<bool> result = source->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            result = target->Store(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class LvalueReferenceCopyConstructorOperation : Operation
    {
        public LvalueReferenceCopyConstructorOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@constructor", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (type->PointerCount() < 1 || !type->IsLvalueReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            TypeSymbol* lvalueRefType = type->RemovePointer(Context());
            FunctionSymbol* function = functionMap[lvalueRefType];
            if (function == null)
            {
                function = new LvalueRefefenceCopyCtor(node->GetSpan(), lvalueRefType, Context());
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[lvalueRefType] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class LvalueReferenceCopyAssignment : FunctionSymbol
    {
        public LvalueReferenceCopyAssignment(const System.Lex.Span& span_, TypeSymbol* type, TypeSymbol* voidType, SymbolsContext& context) : base(span_, u"operator=")
        {
            SetGroupName(u"operator=");
            SetBasicTypeOperation();
            SetLvalueReferenceCopyAssignment();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(type->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(type);
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(voidType);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* source = irObjects[1];
            IrObject* target = irObjects[0];
            Result<bool> result = source->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            result = target->Store(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class LvalueReferenceCopyAssignmentOperation : Operation
    {
        public LvalueReferenceCopyAssignmentOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator=", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (type->PointerCount() < 1 || !type->IsLvalueReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            SymbolsContext& context = Context();
            TypeSymbol* lvalueRefType = type->RemovePointer(context);
            if (lvalueRefType->PlainType(context)->IsClassTypeSymbol()) return Result<bool>(false);
            if (GetCollectFlag(flags, CollectFlags.noRvalueRef) ||
                !TypesEqual(arguments[1]->Type()->RemoveConst(context), lvalueRefType->PlainType(context)->AddRvalueReference(context)) &&
                !arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference))
            {
                FunctionSymbol* function = functionMap[lvalueRefType];
                if (function == null)
                {
                    Result<TypeSymbol*> voidTypeResult = GetSymbolTable()->GetTypeByName(u"void");
                    if (voidTypeResult.Error()) return Result<bool>(ErrorId(voidTypeResult.GetErrorId()));
                    TypeSymbol* voidType = voidTypeResult.Value();
                    function = new LvalueReferenceCopyAssignment(node->GetSpan(), lvalueRefType, voidType, context);
                    if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                    function->SetModule(GetModule());
                    function->SetParent(&GetSymbolTable()->GlobalNs());
                    functionMap[lvalueRefType] = function;
                    functions.Add(UniquePtr<FunctionSymbol>(function));
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class LvalueReferenceMoveAssignment : FunctionSymbol
    {
        public LvalueReferenceMoveAssignment(const System.Lex.Span& span_, TypeSymbol* type, TypeSymbol* voidType, SymbolsContext& context) : base(span_, u"operator=")
        {
            SetGroupName(u"operator=");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(type->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(type->RemoveReference(context)->AddRvalueReference(context));
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(voidType);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* source = irObjects[1];
            IrObject* target = irObjects[0];
            Result<bool> result = source->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* rvalueRefValue = emitter.Stack().Pop();
            Result<intermediate.Value*> loadedValue = emitter.CreateLoad(rvalueRefValue);
            if (loadedValue.Error()) return Result<bool>(ErrorId(loadedValue.GetErrorId()));
            emitter.Stack().Push(loadedValue.Value());
            result = target->Store(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class LvalueReferenceMoveAssignmentOperation : Operation
    {
        public LvalueReferenceMoveAssignmentOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator=", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            if (GetCollectFlag(flags, CollectFlags.noRvalueRef)) return Result<bool>(false);
            TypeSymbol* type = arguments[0]->Type();
            if (type->PointerCount() < 1 || !type->IsLvalueReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            SymbolsContext& context = Context();
            TypeSymbol* lvalueRefType = type->RemovePointer(context);
            if (lvalueRefType->PlainType(context)->IsClassTypeSymbol()) return Result<bool>(false);
            if (lvalueRefType->PlainType(context)->IsArrayTypeSymbol()) return Result<bool>(false);
            if (TypesEqual(arguments[1]->Type()->RemoveConst(context), lvalueRefType->PlainType(context)->AddRvalueReference(context)) ||
                arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference))
            {
                FunctionSymbol* function = functionMap[lvalueRefType];
                if (function == null)
                {
                    Result<TypeSymbol*> voidTypeResult = GetSymbolTable()->GetTypeByName(u"void");
                    if (voidTypeResult.Error()) return Result<bool>(ErrorId(voidTypeResult.GetErrorId()));
                    TypeSymbol* voidType = voidTypeResult.Value();
                    function = new LvalueReferenceMoveAssignment(node->GetSpan(), lvalueRefType, voidType, context);
                    if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                    function->SetModule(GetModule());
                    function->SetParent(&GetSymbolTable()->GlobalNs());
                    functionMap[lvalueRefType] = function;
                    functions.Add(UniquePtr<FunctionSymbol>(function));
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class LvalueReferenceReturn : FunctionSymbol
    {
        public LvalueReferenceReturn(const System.Lex.Span& span_, TypeSymbol* type, SymbolsContext& context) : base(span_, u"@return")
        {
            SetGroupName(u"@return");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* valueParam = new ParameterSymbol(span_, u"value");
            valueParam->SetType(type);
            Result<bool> result = AddMember(valueParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(type);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 1);
            IrObject* value = irObjects[0];
            Result<bool> result = value->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class LvalueReferenceReturnOperation : Operation
    {
        public LvalueReferenceReturnOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@return", 1, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (!type->IsLvalueReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            FunctionSymbol* function = functionMap[type];
            if (function == null)
            {
                function = new LvalueReferenceReturn(node->GetSpan(), type, Context());
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[type] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class RvalueRefefenceCopyCtor : FunctionSymbol
    {
        public RvalueRefefenceCopyCtor(const System.Lex.Span& span_, TypeSymbol* type, SymbolsContext& context) : base(span_, u"@constructor")
        {
            SetGroupName(u"@constructor");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(type->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(type);
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* source = irObjects[1];
            IrObject* target = irObjects[0];
            Result<bool> result = source->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            result = target->Store(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class RvalueReferenceCopyConstructorOperation : Operation
    {
        public RvalueReferenceCopyConstructorOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@constructor", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (type->PointerCount() < 1 || !type->IsRvalueReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            SymbolsContext& context = Context();
            TypeSymbol* rvalueRefType = type->RemovePointer(context);
            if (rvalueRefType->PlainType(context)->IsClassTypeSymbol()) return Result<bool>(false);
            FunctionSymbol* function = functionMap[rvalueRefType];
            if (function == null)
            {
                function = new RvalueRefefenceCopyCtor(node->GetSpan(), rvalueRefType, context);
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[rvalueRefType] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class RvalueReferenceCopyAssignment : FunctionSymbol
    {
        public RvalueReferenceCopyAssignment(const System.Lex.Span& span_, TypeSymbol* type, TypeSymbol* voidType, SymbolsContext& context) : base(span_, u"operator=")
        {
            SetGroupName(u"operator=");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(type->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(type);
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(voidType);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 2);
            IrObject* source = irObjects[1];
            IrObject* target = irObjects[0];
            Result<bool> result = source->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            intermediate.Value* rvalueRefValue = emitter.Stack().Pop();
            Result<intermediate.Value*> loadedValue = emitter.CreateLoad(rvalueRefValue);
            if (loadedValue.Error()) return Result<bool>(ErrorId(loadedValue.GetErrorId()));
            emitter.Stack().Push(loadedValue.Value());
            result = target->Store(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class RvalueReferenceCopyAssignmentOperation : Operation
    {
        public RvalueReferenceCopyAssignmentOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator=", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (type->PointerCount() < 1 || !type->IsRvalueReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            SymbolsContext& context = Context();
            TypeSymbol* rvalueRefType = type->RemovePointer(context);
            if (rvalueRefType->PlainType(context)->IsClassTypeSymbol()) return Result<bool>(false);
            FunctionSymbol* function = functionMap[rvalueRefType];
            if (function == null)
            {
                Result<TypeSymbol*> voidTypeResult = GetSymbolTable()->GetTypeByName(u"void");
                if (voidTypeResult.Error()) return Result<bool>(ErrorId(voidTypeResult.GetErrorId()));
                TypeSymbol* voidType = voidTypeResult.Value();
                function = new RvalueReferenceCopyAssignment(node->GetSpan(), rvalueRefType, voidType, context);
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[rvalueRefType] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class RvalueReferenceReturn : FunctionSymbol
    {
        public RvalueReferenceReturn(const System.Lex.Span& span_, TypeSymbol* type, SymbolsContext& context) : base(span_, u"@return")
        {
            SetGroupName(u"@return");
            SetBasicTypeOperation();
            SetAccess(SymbolAccess.public_);
            ParameterSymbol* valueParam = new ParameterSymbol(span_, u"value");
            valueParam->SetType(type);
            Result<bool> result = AddMember(valueParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            SetReturnType(type);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public override Result<bool> GenerateCall(Emitter& emitter, const List<IrObject*>& irObjects, OperationFlags flags)
        {
            #assert(irObjects.Count() == 1);
            IrObject* value = irObjects[0];
            Result<bool> result = value->Load(emitter, OperationFlags.none);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
    }

    public class RvalueReferenceReturnOperation : Operation
    {
        public RvalueReferenceReturnOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@return", 1, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            if (!type->IsRvalueReferenceType()) return Result<bool>(false);
            if (type->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            FunctionSymbol* function = functionMap[type];
            if (function == null)
            {
                function = new RvalueReferenceReturn(node->GetSpan(), type, Context());
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[type] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class ArrayDefaultConstructorOperation : Operation
    {
        public ArrayDefaultConstructorOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@constructor", 1, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            SymbolsContext& context = Context();
            if (type->PointerCount() != 1 || !type->RemovePointer(context)->IsArrayTypeSymbol()) return Result<bool>(false);
            ArrayTypeSymbol* arrayType = cast<ArrayTypeSymbol*>(type->BaseType());
            if (arrayType->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(arrayType->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            FunctionSymbol* function = functionMap[arrayType->TypeId()];
            if (function == null)
            {
                List<FunctionScopeLookup> elementLookups;
                elementLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                Result<ContainerScope*> scopeResult = arrayType->ElementType()->BaseType()->ClassInterfaceEnumDelegateOrNsScope();
                if (scopeResult.Error()) return Result<bool>(ErrorId(scopeResult.GetErrorId()));
                ContainerScope* scope = scopeResult.Value();
                elementLookups.Add(FunctionScopeLookup(ScopeLookup.this_, scope));
                elementLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                List<UniquePtr<BoundExpression>> elementArguments;
                elementArguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(node->GetSpan(), arrayType->ElementType()->AddPointer(context))));
                Result<UniquePtr<BoundFunctionCall>> elementDefaultConstructorResult = ResolveOverload(u"@constructor", containerScope, elementLookups, elementArguments,
                    GetBoundCompileUnit(), currentFunction, node);
                if (elementDefaultConstructorResult.Error()) return Result<bool>(ErrorId(elementDefaultConstructorResult.GetErrorId()));
                FunctionSymbol* elementTypeDefaultConstructor = elementDefaultConstructorResult.Value()->GetFunctionSymbol();
                ArrayDefaultConstructor* arrayDefaultConstructor = new ArrayDefaultConstructor(context, arrayType, elementTypeDefaultConstructor);
                if (arrayDefaultConstructor->Error()) return Result<bool>(ErrorId(arrayDefaultConstructor->GetErrorId()));
                arrayDefaultConstructor->SetTemporariesForElementDefaultConstructor(elementDefaultConstructorResult.Value()->ReleaseTemporaries());
                function = arrayDefaultConstructor;
                function->SetModule(GetBoundCompileUnit()->GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[arrayType->TypeId()] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private HashMap<Uuid, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class ArrayCopyConstructorOperation : Operation
    {
        public ArrayCopyConstructorOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@constructor", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            SymbolsContext& context = Context();
            if (type->PointerCount() != 1 || !type->RemovePointer(context)->IsArrayTypeSymbol()) return Result<bool>(false);
            ArrayTypeSymbol* arrayType = cast<ArrayTypeSymbol*>(type->BaseType());
            if (arrayType->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(arrayType->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            TypeSymbol* rightType = arguments[1]->Type()->PlainType(context);
            bool typesEqual = TypesEqual(rightType, arrayType);
            bool bindToRvalueRef = arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference);
            if (typesEqual ||
                GetCollectFlag(flags, CollectFlags.noRvalueRef) ||
                (!TypesEqual(arguments[1]->Type(), arrayType->AddRvalueReference(context)) && !bindToRvalueRef))
            {
                FunctionSymbol* function = functionMap[arrayType->TypeId()];
                if (function == null)
                {
                    List<FunctionScopeLookup> elementLookups;
                    elementLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                    Result<ContainerScope*> scopeResult = arrayType->ElementType()->BaseType()->ClassInterfaceEnumDelegateOrNsScope();
                    if (scopeResult.Error()) return Result<bool>(ErrorId(scopeResult.GetErrorId()));
                    ContainerScope* scope = scopeResult.Value();
                    elementLookups.Add(FunctionScopeLookup(ScopeLookup.this_, scope));
                    elementLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                    List<UniquePtr<BoundExpression>> elementArguments;
                    elementArguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(node->GetSpan(), arrayType->ElementType()->AddPointer(context))));
                    elementArguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(node->GetSpan(),
                        arrayType->ElementType()->AddConst(context)->AddLvalueReference(context))));
                    Result<UniquePtr<BoundFunctionCall>> elementCopyConstructorResult = ResolveOverload(u"@constructor", containerScope, elementLookups, elementArguments,
                        GetBoundCompileUnit(), currentFunction, node);
                    if (elementCopyConstructorResult.Error()) return Result<bool>(ErrorId(elementCopyConstructorResult.GetErrorId()));
                    FunctionSymbol* elementTypeCopyConstructor = elementCopyConstructorResult.Value()->GetFunctionSymbol();
                    ArrayCopyConstructor* arrayCopyConstructor = new ArrayCopyConstructor(context, arrayType, elementTypeCopyConstructor);
                    if (arrayCopyConstructor->Error()) return Result<bool>(ErrorId(arrayCopyConstructor->GetErrorId()));
                    arrayCopyConstructor->SetTemporariesForElementCopyConstructor(elementCopyConstructorResult.Value()->ReleaseTemporaries());
                    function = arrayCopyConstructor;
                    function->SetModule(GetBoundCompileUnit()->GetModule());
                    function->SetParent(&GetSymbolTable()->GlobalNs());
                    functionMap[arrayType->TypeId()] = function;
                    functions.Add(UniquePtr<FunctionSymbol>(function));
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private HashMap<Uuid, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class ArrayMoveConstructorOperation : Operation
    {
        public ArrayMoveConstructorOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@constructor", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            SymbolsContext& context = Context();
            if (type->PointerCount() != 1 || !type->RemovePointer(context)->IsArrayTypeSymbol()) return Result<bool>(false);
            ArrayTypeSymbol* arrayType = cast<ArrayTypeSymbol*>(type->BaseType());
            if (arrayType->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(arrayType->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            bool bindToRvalueRef = arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference);
            if (TypesEqual(arguments[1]->Type(), arrayType->AddRvalueReference(context)) || bindToRvalueRef)
            {
                FunctionSymbol* function = functionMap[arrayType->TypeId()];
                if (function == null)
                {
                    List<FunctionScopeLookup> elementLookups;
                    elementLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                    Result<ContainerScope*> scopeResult = arrayType->ElementType()->BaseType()->ClassInterfaceEnumDelegateOrNsScope();
                    if (scopeResult.Error()) return Result<bool>(ErrorId(scopeResult.GetErrorId()));
                    ContainerScope* scope = scopeResult.Value();
                    elementLookups.Add(FunctionScopeLookup(ScopeLookup.this_, scope));
                    elementLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                    List<UniquePtr<BoundExpression>> elementArguments;
                    elementArguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(node->GetSpan(), arrayType->ElementType()->AddPointer(context))));
                    elementArguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(node->GetSpan(),
                        arrayType->ElementType()->AddRvalueReference(context))));
                    Result<UniquePtr<BoundFunctionCall>> elementMoveConstructorResult = ResolveOverload(u"@constructor", containerScope, elementLookups, elementArguments,
                        GetBoundCompileUnit(), currentFunction, node);
                    if (elementMoveConstructorResult.Error()) return Result<bool>(ErrorId(elementMoveConstructorResult.GetErrorId()));
                    FunctionSymbol* elementTypeMoveConstructor = elementMoveConstructorResult.Value()->GetFunctionSymbol();
                    ArrayMoveConstructor* arrayMoveConstructor = new ArrayMoveConstructor(context, arrayType, elementTypeMoveConstructor);
                    if (arrayMoveConstructor->Error()) return Result<bool>(ErrorId(arrayMoveConstructor->GetErrorId()));
                    arrayMoveConstructor->SetTemporariesForElementMoveConstructor(elementMoveConstructorResult.Value()->ReleaseTemporaries());
                    function = arrayMoveConstructor;
                    function->SetModule(GetBoundCompileUnit()->GetModule());
                    function->SetParent(&GetSymbolTable()->GlobalNs());
                    functionMap[arrayType->TypeId()] = function;
                    functions.Add(UniquePtr<FunctionSymbol>(function));
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private HashMap<Uuid, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class ArrayCopyAssignmentOperation : Operation
    {
        public ArrayCopyAssignmentOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator=", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            SymbolsContext& context = Context();
            if (type->PointerCount() != 1 || !type->RemovePointer(context)->IsArrayTypeSymbol()) return Result<bool>(false);
            ArrayTypeSymbol* arrayType = cast<ArrayTypeSymbol*>(type->BaseType());
            if (arrayType->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(arrayType->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            TypeSymbol* rightType = arguments[1]->Type()->PlainType(context);
            bool typesEqual = TypesEqual(rightType, arrayType);
            bool bindToRvalueRef = arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference);
            if (typesEqual ||
                GetCollectFlag(flags, CollectFlags.noRvalueRef) ||
                (!TypesEqual(arguments[1]->Type(), arrayType->AddRvalueReference(context)) && !bindToRvalueRef))
            {
                FunctionSymbol* function = functionMap[arrayType->TypeId()];
                if (function == null)
                {
                    List<FunctionScopeLookup> elementLookups;
                    elementLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                    Result<ContainerScope*> scopeResult = arrayType->ElementType()->BaseType()->ClassInterfaceEnumDelegateOrNsScope();
                    if (scopeResult.Error()) return Result<bool>(ErrorId(scopeResult.GetErrorId()));
                    ContainerScope* scope = scopeResult.Value();
                    elementLookups.Add(FunctionScopeLookup(ScopeLookup.this_, scope));
                    elementLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                    List<UniquePtr<BoundExpression>> elementArguments;
                    elementArguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(node->GetSpan(), arrayType->ElementType()->AddPointer(context))));
                    elementArguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(node->GetSpan(),
                        arrayType->ElementType()->AddConst(context)->AddLvalueReference(context))));
                    Result<UniquePtr<BoundFunctionCall>> elementCopyAssignmentResult = ResolveOverload(u"operator=", containerScope, elementLookups, elementArguments,
                        GetBoundCompileUnit(), currentFunction, node);
                    if (elementCopyAssignmentResult.Error()) return Result<bool>(ErrorId(elementCopyAssignmentResult.GetErrorId()));
                    FunctionSymbol* elementTypeCopyAssignment = elementCopyAssignmentResult.Value()->GetFunctionSymbol();
                    ArrayCopyAssignment* arrayCopyAssignment = new ArrayCopyAssignment(context, arrayType, elementTypeCopyAssignment);
                    if (arrayCopyAssignment->Error()) return Result<bool>(ErrorId(arrayCopyAssignment->GetErrorId()));
                    arrayCopyAssignment->SetTemporariesForElementCopyAssignment(elementCopyAssignmentResult.Value()->ReleaseTemporaries());
                    function = arrayCopyAssignment;
                    function->SetModule(GetBoundCompileUnit()->GetModule());
                    function->SetParent(&GetSymbolTable()->GlobalNs());
                    functionMap[arrayType->TypeId()] = function;
                    functions.Add(UniquePtr<FunctionSymbol>(function));
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private HashMap<Uuid, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class ArrayMoveAssignmentOperation : Operation
    {
        public ArrayMoveAssignmentOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator=", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            SymbolsContext& context = Context();
            if (type->PointerCount() != 1 || !type->RemovePointer(context)->IsArrayTypeSymbol()) return Result<bool>(false);
            ArrayTypeSymbol* arrayType = cast<ArrayTypeSymbol*>(type->BaseType());
            if (arrayType->BaseType()->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(arrayType->BaseType());
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            bool bindToRvalueRef = arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference);
            if (TypesEqual(arguments[1]->Type(), arrayType->AddRvalueReference(context)) || bindToRvalueRef)
            {
                FunctionSymbol* function = functionMap[arrayType->TypeId()];
                if (function == null)
                {
                    List<FunctionScopeLookup> elementLookups;
                    elementLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                    Result<ContainerScope*> scopeResult = arrayType->ElementType()->BaseType()->ClassInterfaceEnumDelegateOrNsScope();
                    if (scopeResult.Error()) return Result<bool>(ErrorId(scopeResult.GetErrorId()));
                    ContainerScope* scope = scopeResult.Value();
                    elementLookups.Add(FunctionScopeLookup(ScopeLookup.this_, scope));
                    elementLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                    List<UniquePtr<BoundExpression>> elementArguments;
                    elementArguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(node->GetSpan(), arrayType->ElementType()->AddPointer(context))));
                    elementArguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(node->GetSpan(),
                        arrayType->ElementType()->AddRvalueReference(context))));
                    Result<UniquePtr<BoundFunctionCall>> elementMoveAssignmentResult = ResolveOverload(u"operator=", containerScope, elementLookups, elementArguments,
                        GetBoundCompileUnit(), currentFunction, node);
                    if (elementMoveAssignmentResult.Error()) return Result<bool>(ErrorId(elementMoveAssignmentResult.GetErrorId()));
                    FunctionSymbol* elementTypeMoveAssignment = elementMoveAssignmentResult.Value()->GetFunctionSymbol();
                    ArrayMoveAssignment* arrayMoveAssignment = new ArrayMoveAssignment(context, arrayType, elementTypeMoveAssignment);
                    if (arrayMoveAssignment->Error()) return Result<bool>(ErrorId(arrayMoveAssignment->GetErrorId()));
                    arrayMoveAssignment->SetTemporariesForElementMoveAssignment(elementMoveAssignmentResult.Value()->ReleaseTemporaries());
                    function = arrayMoveAssignment;
                    function->SetModule(GetBoundCompileUnit()->GetModule());
                    function->SetParent(&GetSymbolTable()->GlobalNs());
                    functionMap[arrayType->TypeId()] = function;
                    functions.Add(UniquePtr<FunctionSymbol>(function));
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private HashMap<Uuid, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class ArrayElementAccessOperation : Operation
    {
        public ArrayElementAccessOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator[]", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            SymbolsContext& context = Context();
            TypeSymbol* leftType = arguments[0]->Type();
            if (!leftType->PlainType(context)->IsArrayTypeSymbol()) return Result<bool>(false);
            ArrayTypeSymbol* arrayType = cast<ArrayTypeSymbol*>(leftType->PlainType(context));
            TypeSymbol* rightType = arguments[1]->Type();
            Result<TypeSymbol*> longTypeResult = context.RootModule()->GetSymbolTable()->GetTypeByName(u"long");
            if (longTypeResult.Error()) return Result<bool>(ErrorId(longTypeResult.GetErrorId()));
            TypeSymbol* longType = longTypeResult.Value();
            if (!rightType->PlainType(context)->IsIntegralType())
            {
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> conversionResult = GetConversion(rightType, longType, containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (conversionResult.Error()) return Result<bool>(ErrorId(conversionResult.GetErrorId()));
            }
            FunctionSymbol* function = functionMap[arrayType->TypeId()];
            if (function == null)
            {
                function = new ArrayTypeElementAccess(context, arrayType);
                if (function->Error()) return Result<bool>(ErrorId(function->GetErrorId()));
                function->SetModule(GetBoundCompileUnit()->GetModule());
                function->SetParent(&GetSymbolTable()->GlobalNs());
                functionMap[arrayType->TypeId()] = function;
                functions.Add(UniquePtr<FunctionSymbol>(function));
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private HashMap<Uuid, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class ClassDefaultConstructor : ConstructorSymbol
    {
        public ClassDefaultConstructor(const System.Lex.Span& span_, ClassTypeSymbol* classType_, BoundCompileUnit* boundCompileUnit) :
            base(span_, u"@constructor"), classType(classType_)
        {
            SymbolsContext& context = boundCompileUnit->Context();
            SetGenerated();
            SetAccess(SymbolAccess.public_);
            SetParent(classType);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(classType->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            Result<string> sourceFileIdResult = boundCompileUnit->SourceFile()->Id();
            if (sourceFileIdResult.Error())
            {
                SetErrorId(sourceFileIdResult.GetErrorId());
                return;
            }
            SetSourceFileId(sourceFileIdResult.Value());
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public inline ClassTypeSymbol* ClassType() const
        {
            return classType;
        }
        private ClassTypeSymbol* classType;
    }

    public class ClassDefaultConstructorOperation : Operation
    {
        public ClassDefaultConstructorOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@constructor", 1, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            SymbolsContext& context = Context();
            TypeSymbol* baseType = type->RemovePointer(context)->PlainType(context);
            if (type->PointerCount() != 1 || !baseType->IsClassTypeSymbol()) return Result<bool>(false);
            ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type->BaseType());
            if (classType->IsStatic())
            {
                int errorId = MakeError("cannot create an instance of a static class", node->GetFullSpan(), classType->FullSpan());
                return Result<bool>(ErrorId(errorId));
            }
            if (classType->DefaultConstructor() != null)
            {
                viableFunctions.Add(classType->DefaultConstructor());
                return Result<bool>(true);
            }
            if (classType->IsClassTemplateSpecializationSymbol())
            {
                ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(classType);
                Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                if (result.Error()) return result;
            }
            FunctionSymbol* function = functionMap[classType];
            if (function == null)
            {
                UniquePtr<ClassDefaultConstructor> defaultConstructor(new ClassDefaultConstructor(node->GetSpan(), classType, GetBoundCompileUnit()));
                if (defaultConstructor->Error()) return Result<bool>(ErrorId(defaultConstructor->GetErrorId()));
                defaultConstructor->SetSourceFile(GetBoundCompileUnit()->SourceFile());
                if (GetCollectFlag(flags, CollectFlags.dontInstantiate))
                {
                    function = defaultConstructor.Get();
                    function->SetModule(GetModule());
                    functions.Add(UniquePtr<FunctionSymbol>(defaultConstructor.Release()));
                }
                else
                {
                    Result<bool> result = GenerateImplementation(defaultConstructor.Get(), containerScope, currentFunction, node);
                    if (result.Error()) return result;
                    function = defaultConstructor.Get();
                    function->SetModule(GetModule());
                    functionMap[classType] = function;
                    functions.Add(UniquePtr<FunctionSymbol>(defaultConstructor.Release()));
                }
            }
            viableFunctions.Add(function);
            return Result<bool>(true);
        }
        private Result<bool> GenerateImplementation(ClassDefaultConstructor* defaultConstructor, ContainerScope* containerScope, BoundFunction* currentFunction, Node* node)
        {
            ClassTypeSymbol* classType = defaultConstructor->ClassType();
            SymbolsContext& context = Context();
            UniquePtr<BoundFunction> boundFunction(new BoundFunction(node->GetSpan(), defaultConstructor, node->ModuleId(), node->FileIndex()));
            boundFunction->SetNode(node);
            boundFunction->SetBody(UniquePtr<BoundCompoundStatement>(new BoundCompoundStatement(node->GetSpan())));
            if (classType->StaticConstructor() != null)
            {
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(), UniquePtr<BoundExpression>(
                    new BoundFunctionCall(node->GetSpan(), classType->StaticConstructor())))));
                defaultConstructor->SetCannotInline();
            }
            if (classType->BaseClass() != null)
            {
                List<FunctionScopeLookup> baseConstructorCallLookups;
                baseConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                baseConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_, classType->BaseClass()->GetContainerScope()));
                baseConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                List<UniquePtr<BoundExpression>> baseConstructorCallArguments;
                ParameterSymbol* thisParam = defaultConstructor->Parameters()[0];
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> thisToBaseConversionResult = GetConversion(thisParam->Type(), classType->BaseClass()->AddPointer(context),
                    containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (thisToBaseConversionResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(thisToBaseConversionResult.GetErrorId());
                    int errorId = MakeError("Cannot create default constructor for class '" + classTypeFullName +
                        "'. Reason: base class conversion not found:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                FunctionSymbol* thisToBaseConversion = thisToBaseConversionResult.Value();
                UniquePtr<BoundExpression> baseClassPointerConversion(new BoundConversion(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)), thisToBaseConversion));
                baseConstructorCallArguments.Add(Rvalue(baseClassPointerConversion));
                Result<UniquePtr<BoundFunctionCall>> baseConstructorCallResult = ResolveOverload(u"@constructor", containerScope, baseConstructorCallLookups,
                    baseConstructorCallArguments, GetBoundCompileUnit(), boundFunction.Get(), node);
                if (baseConstructorCallResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(baseConstructorCallResult.GetErrorId());
                    int errorId = MakeError("Cannot create default constructor for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(),
                    UniquePtr<BoundExpression>(baseConstructorCallResult.Value().Release()))));
                defaultConstructor->SetCannotInline();
            }
            if (classType->IsPolymorphic())
            {
                ParameterSymbol* thisParam = defaultConstructor->Parameters()[0];
                UniquePtr<BoundExpression> classPtr;
                Result<ClassTypeSymbol*> vmtPtrHolderClassResult = classType->VmtPtrHolderClass();
                if (vmtPtrHolderClassResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(vmtPtrHolderClassResult.GetErrorId());
                    int errorId = MakeError("Cannot create default constructor for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                ClassTypeSymbol* vmtPtrHolderClass = vmtPtrHolderClassResult.Value();
                if (vmtPtrHolderClass == classType)
                {
                    classPtr.Reset(new BoundParameter(node->GetSpan(), thisParam));
                }
                else
                {
                    ArgumentMatch argumentMatch;
                    Result<FunctionSymbol*> thisToHolderConversionResult = GetConversion(thisParam->Type(), vmtPtrHolderClass->AddPointer(context),
                        containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                    if (thisToHolderConversionResult.Error())
                    {
                        Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                        if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                        string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                        string message = RtmGetErrorMessageWithoutStackTrace(thisToHolderConversionResult.GetErrorId());
                        int errorId = MakeError("Cannot create default constructor for class '" + classTypeFullName +
                            "'. Reason:\n" + message, node->GetFullSpan(), classType->FullSpan());
                        return Result<bool>(ErrorId(errorId));
                    }
                    FunctionSymbol* thisToHolderConversion = thisToHolderConversionResult.Value();
                    classPtr.Reset(new BoundConversion(node->GetSpan(), UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)), thisToHolderConversion));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundSetVmtPtrStatement(node->GetSpan(), Rvalue(classPtr), classType)));
                defaultConstructor->SetCannotInline();
            }
            int n = cast<int>(classType->MemberVariables().Count());
            if (n > maxGeneratedInlineFunctionMembers)
            {
                defaultConstructor->SetCannotInline();
            }
            for (int i = 0; i < n; ++i)
            {
                MemberVariableSymbol* memberVariableSymbol = classType->MemberVariables()[i];
                List<FunctionScopeLookup> memberConstructorCallLookups;
                memberConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                Result<ContainerScope*> scopeResult = memberVariableSymbol->Type()->BaseType()->ClassInterfaceEnumDelegateOrNsScope();
                if (scopeResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(scopeResult.GetErrorId());
                    int errorId = MakeError("Cannot create default constructor for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), memberVariableSymbol->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                ContainerScope* scope = scopeResult.Value();
                memberConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_, scope));
                memberConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                List<UniquePtr<BoundExpression>> memberConstructorCallArguments;
                UniquePtr<BoundMemberVariable> boundMemberVariable(new BoundMemberVariable(node->GetSpan(), memberVariableSymbol));
                ParameterSymbol* thisParam = defaultConstructor->GetThisParam();
                #assert(thisParam != null);
                boundMemberVariable->SetClassPtr(UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)));
                TypeSymbol* type = boundMemberVariable->Type()->AddPointer(context);
                memberConstructorCallArguments.Add(UniquePtr<BoundExpression>(new BoundAddressOfExpression(node->GetSpan(),
                    UniquePtr<BoundExpression>(boundMemberVariable.Release()), type)));
                Result<UniquePtr<BoundFunctionCall>> memberConstructorCallResult = ResolveOverload(u"@constructor", containerScope,
                    memberConstructorCallLookups, memberConstructorCallArguments, GetBoundCompileUnit(), boundFunction.Get(), node);
                if (memberConstructorCallResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(memberConstructorCallResult.GetErrorId());
                    int errorId = MakeError("Cannot create default constructor for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), memberVariableSymbol->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(),
                    UniquePtr<BoundExpression>(memberConstructorCallResult.Value().Release()))));
            }
            GetBoundCompileUnit()->AddBoundNode(UniquePtr<BoundNode>(boundFunction.Release()));
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class ClassCopyConstructor : ConstructorSymbol
    {
        public ClassCopyConstructor(const System.Lex.Span& span_, ClassTypeSymbol* classType_, BoundCompileUnit* boundCompileUnit) :
            base(span_, u"@constructor"), classType(classType_)
        {
            SymbolsContext& context = boundCompileUnit->Context();
            SetGenerated();
            SetAccess(SymbolAccess.public_);
            SetParent(classType);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(classType->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(classType->AddConst(context)->AddLvalueReference(context));
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            Result<string> sourceFileIdResult = boundCompileUnit->SourceFile()->Id();
            if (sourceFileIdResult.Error())
            {
                SetErrorId(sourceFileIdResult.GetErrorId());
                return;
            }
            SetSourceFileId(sourceFileIdResult.Value());
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public inline ClassTypeSymbol* ClassType() const
        {
            return classType;
        }
        private ClassTypeSymbol* classType;
    }

    public class ClassCopyConstructorOperation : Operation
    {
        public ClassCopyConstructorOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@constructor", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            SymbolsContext& context = Context();
            TypeSymbol* baseType = type->RemovePointer(context)->PlainType(context);
            if (type->PointerCount() != 1 || !baseType->IsClassTypeSymbol()) return Result<bool>(false);
            ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type->BaseType());
            if (classType->IsStatic())
            {
                int errorId = MakeError("cannot copy an instance of a static class", node->GetFullSpan(), classType->FullSpan());
                return Result<bool>(ErrorId(errorId));
            }
            TypeSymbol* rightType = arguments[1]->Type()->PlainType(context);
            bool typesEqual = TypesEqual(rightType, classType);
            bool bindToRvalueRef = arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference);
            bool conversionFunctionExists = false;
            if (!typesEqual)
            {
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> conversionResult = GetConversion(rightType, classType, containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (!conversionResult.Error())
                {
                    FunctionSymbol* conversion = conversionResult.Value();
                    if (conversion != null && conversion->IsConversionFunctionSymbol())
                    {
                        conversionFunctionExists = true;
                        if (conversion->ReturnsClassInterfaceOrClassDelegateByValue())
                        {
                            bindToRvalueRef = true; // in this case class move constructor will match
                        }
                    }
                }
            }
            if (typesEqual ||
                GetCollectFlag(flags, CollectFlags.noRvalueRef) ||
                (!TypesEqual(arguments[1]->Type(), classType->AddRvalueReference(context)) && !bindToRvalueRef) && (typesEqual || conversionFunctionExists))
            {
                if (classType->CopyConstructor() != null)
                {
                    viableFunctions.Add(classType->CopyConstructor());
                    return Result<bool>(true);
                }
                if (classType->IsClassTemplateSpecializationSymbol())
                {
                    ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(classType);
                    Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                    if (result.Error()) return result;
                }
                FunctionSymbol* function = functionMap[classType];
                if (function == null)
                {
                    UniquePtr<ClassCopyConstructor> copyConstructor(new ClassCopyConstructor(node->GetSpan(), classType, GetBoundCompileUnit()));
                    if (copyConstructor->Error()) return Result<bool>(ErrorId(copyConstructor->GetErrorId()));
                    copyConstructor->SetSourceFile(GetBoundCompileUnit()->SourceFile());
                    if (GetCollectFlag(flags, CollectFlags.dontInstantiate))
                    {
                        function = copyConstructor.Get();
                        function->SetModule(GetModule());
                        functions.Add(UniquePtr<FunctionSymbol>(copyConstructor.Release()));
                    }
                    else
                    {
                        Result<bool> result = GenerateImplementation(copyConstructor.Get(), containerScope, currentFunction, node);
                        if (result.Error()) return result;
                        function = copyConstructor.Get();
                        function->SetModule(GetModule());
                        functionMap[classType] = function;
                        functions.Add(UniquePtr<FunctionSymbol>(copyConstructor.Release()));
                    }
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private Result<bool> GenerateImplementation(ClassCopyConstructor* copyConstructor, ContainerScope* containerScope, BoundFunction* currentFunction, Node* node)
        {
            ClassTypeSymbol* classType = copyConstructor->ClassType();
            SymbolsContext& context = Context();
            UniquePtr<BoundFunction> boundFunction(new BoundFunction(node->GetSpan(), copyConstructor, node->ModuleId(), node->FileIndex()));
            boundFunction->SetBody(UniquePtr<BoundCompoundStatement>(new BoundCompoundStatement(node->GetSpan())));
            boundFunction->SetNode(node);
            if (classType->StaticConstructor() != null)
            {
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(), UniquePtr<BoundExpression>(
                    new BoundFunctionCall(node->GetSpan(), classType->StaticConstructor())))));
                copyConstructor->SetCannotInline();
            }
            if (classType->BaseClass() != null)
            {
                List<FunctionScopeLookup> baseConstructorCallLookups;
                baseConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                baseConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_, classType->BaseClass()->GetContainerScope()));
                baseConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                List<UniquePtr<BoundExpression>> baseConstructorCallArguments;
                ParameterSymbol* thisParam = copyConstructor->Parameters()[0];
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> thisToBaseConversionResult = GetConversion(thisParam->Type(), classType->BaseClass()->AddPointer(context),
                    containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (thisToBaseConversionResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(thisToBaseConversionResult.GetErrorId());
                    int errorId = MakeError("Cannot create copy constructor for class '" + classTypeFullName +
                        "'. Reason: base class conversion not found:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                FunctionSymbol* thisToBaseConversion = thisToBaseConversionResult.Value();
                UniquePtr<BoundExpression> baseClassPointerConversion(new BoundConversion(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)), thisToBaseConversion));
                baseConstructorCallArguments.Add(Rvalue(baseClassPointerConversion));
                ParameterSymbol* thatParam = copyConstructor->Parameters()[1];
                Result<FunctionSymbol*> thatToBaseConversionResult = GetConversion(thatParam->Type(), classType->BaseClass()->AddConst(context)->AddLvalueReference(context),
                    containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (thatToBaseConversionResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(thatToBaseConversionResult.GetErrorId());
                    int errorId = MakeError("Cannot create copy constructor for class '" + classTypeFullName +
                        "'. Reason: base class conversion not found:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                FunctionSymbol* thatToBaseConversion = thatToBaseConversionResult.Value();
                UniquePtr<BoundExpression> thatArgumentConversion(new BoundConversion(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thatParam)), thatToBaseConversion));
                baseConstructorCallArguments.Add(Rvalue(thatArgumentConversion));
                Result<UniquePtr<BoundFunctionCall>> baseConstructorCallResult = ResolveOverload(u"@constructor", containerScope, baseConstructorCallLookups,
                    baseConstructorCallArguments, GetBoundCompileUnit(), boundFunction.Get(), node);
                if (baseConstructorCallResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(baseConstructorCallResult.GetErrorId());
                    int errorId = MakeError("Cannot create copy constructor for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(),
                    UniquePtr<BoundExpression>(baseConstructorCallResult.Value().Release()))));
                copyConstructor->SetCannotInline();
            }
            if (classType->IsPolymorphic())
            {
                ParameterSymbol* thisParam = copyConstructor->Parameters()[0];
                UniquePtr<BoundExpression> classPtr;
                Result<ClassTypeSymbol*> vmtPtrHolderClassResult = classType->VmtPtrHolderClass();
                if (vmtPtrHolderClassResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(vmtPtrHolderClassResult.GetErrorId());
                    int errorId = MakeError("Cannot create copy constructor for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                ClassTypeSymbol* vmtPtrHolderClass = vmtPtrHolderClassResult.Value();
                if (vmtPtrHolderClass == classType)
                {
                    classPtr.Reset(new BoundParameter(node->GetSpan(), thisParam));
                }
                else
                {
                    ArgumentMatch argumentMatch;
                    Result<FunctionSymbol*> thisToHolderConversionResult = GetConversion(thisParam->Type(), vmtPtrHolderClass->AddPointer(context),
                        containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                    if (thisToHolderConversionResult.Error())
                    {
                        Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                        if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                        string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                        string message = RtmGetErrorMessageWithoutStackTrace(thisToHolderConversionResult.GetErrorId());
                        int errorId = MakeError("Cannot create copy constructor for class '" + classTypeFullName +
                            "'. Reason:\n" + message, node->GetFullSpan(), classType->FullSpan());
                        return Result<bool>(ErrorId(errorId));
                    }
                    FunctionSymbol* thisToHolderConversion = thisToHolderConversionResult.Value();
                    classPtr.Reset(new BoundConversion(node->GetSpan(), UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)), thisToHolderConversion));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundSetVmtPtrStatement(node->GetSpan(), Rvalue(classPtr), classType)));
                copyConstructor->SetCannotInline();
            }
            int n = cast<int>(classType->MemberVariables().Count());
            if (n > maxGeneratedInlineFunctionMembers)
            {
                copyConstructor->SetCannotInline();
            }
            for (int i = 0; i < n; ++i)
            {
                MemberVariableSymbol* memberVariableSymbol = classType->MemberVariables()[i];
                List<FunctionScopeLookup> memberConstructorCallLookups;
                memberConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                Result<ContainerScope*> scopeResult = memberVariableSymbol->Type()->BaseType()->ClassInterfaceEnumDelegateOrNsScope();
                if (scopeResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(scopeResult.GetErrorId());
                    int errorId = MakeError("Cannot create copy constructor for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), memberVariableSymbol->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                if (memberVariableSymbol->Type()->IsClassTypeSymbol())
                {
                    ClassTypeSymbol* memberVarClassType = cast<ClassTypeSymbol*>(memberVariableSymbol->Type());
                    FunctionSymbol* copyCtor = memberVarClassType->CopyConstructor();
                    if (copyCtor != null)
                    {
                        if (copyCtor->IsSuppressed())
                        {
                            Result<string> memberVarClassTypeName = ToUtf8(memberVarClassType->FullName());
                            if (memberVarClassTypeName.Error()) return Result<bool>(ErrorId(memberVarClassTypeName.GetErrorId()));
                            int copyCtorErrorId = MakeError("copy constructor of member variable type '" + memberVarClassTypeName.Value() + "' is suppressed",
                                memberVariableSymbol->FullSpan(), copyCtor->FullSpan());
                            string message = RtmGetErrorMessageWithoutStackTrace(copyCtorErrorId);
                            Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                            if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                            string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                            int errorId = MakeError("Cannot create copy constructor for class '" + classTypeFullName +
                                "'. Reason:\n" + message, node->GetFullSpan(), memberVariableSymbol->FullSpan());
                            return Result<bool>(ErrorId(errorId));
                        }
                    }
                }
                ContainerScope* scope = scopeResult.Value();
                memberConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_, scope));
                memberConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                List<UniquePtr<BoundExpression>> memberConstructorCallArguments;
                UniquePtr<BoundMemberVariable> boundMemberVariable(new BoundMemberVariable(node->GetSpan(), memberVariableSymbol));
                ParameterSymbol* thisParam = copyConstructor->GetThisParam();
                #assert(thisParam != null);
                boundMemberVariable->SetClassPtr(UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)));
                TypeSymbol* type = boundMemberVariable->Type()->AddPointer(context);
                memberConstructorCallArguments.Add(UniquePtr<BoundExpression>(new BoundAddressOfExpression(node->GetSpan(),
                    UniquePtr<BoundExpression>(boundMemberVariable.Release()), type)));
                ParameterSymbol* thatParam = copyConstructor->Parameters()[1];
                UniquePtr<BoundMemberVariable> thatBoundMemberVariable(new BoundMemberVariable(node->GetSpan(), memberVariableSymbol));
                thatBoundMemberVariable->SetClassPtr(UniquePtr<BoundExpression>(new BoundReferenceToPointerExpression(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thatParam)), thatParam->Type()->BaseType()->AddPointer(context))));
                memberConstructorCallArguments.Add(UniquePtr<BoundExpression>(thatBoundMemberVariable.Release()));
                Result<UniquePtr<BoundFunctionCall>> memberConstructorCallResult = ResolveOverload(u"@constructor", containerScope,
                    memberConstructorCallLookups, memberConstructorCallArguments, GetBoundCompileUnit(), boundFunction.Get(), node);
                if (memberConstructorCallResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(memberConstructorCallResult.GetErrorId());
                    int errorId = MakeError("Cannot create copy constructor for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), memberVariableSymbol->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(),
                    UniquePtr<BoundExpression>(memberConstructorCallResult.Value().Release()))));
            }
            GetBoundCompileUnit()->AddBoundNode(UniquePtr<BoundNode>(boundFunction.Release()));
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class ClassMoveConstructor : ConstructorSymbol
    {
        public ClassMoveConstructor(const System.Lex.Span& span_, ClassTypeSymbol* classType_, BoundCompileUnit* boundCompileUnit) :
            base(span_, u"@constructor"), classType(classType_)
        {
            SymbolsContext& context = boundCompileUnit->Context();
            SetGenerated();
            SetAccess(SymbolAccess.public_);
            SetParent(classType);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(classType->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(classType->AddRvalueReference(context));
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            Result<string> sourceFileIdResult = boundCompileUnit->SourceFile()->Id();
            if (sourceFileIdResult.Error())
            {
                SetErrorId(sourceFileIdResult.GetErrorId());
                return;
            }
            SetSourceFileId(sourceFileIdResult.Value());
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public inline ClassTypeSymbol* ClassType() const
        {
            return classType;
        }
        private ClassTypeSymbol* classType;
    }

    public class ClassMoveConstructorOperation : Operation
    {
        public ClassMoveConstructorOperation(BoundCompileUnit* boundCompileUnit_) : base(u"@constructor", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            if (GetCollectFlag(flags, CollectFlags.noRvalueRef)) return Result<bool>(false);
            TypeSymbol* type = arguments[0]->Type();
            SymbolsContext& context = Context();
            TypeSymbol* baseType = type->RemovePointer(context)->PlainType(context);
            if (type->PointerCount() != 1 || !baseType->IsClassTypeSymbol()) return Result<bool>(false);
            ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type->BaseType());
            if (classType->IsStatic())
            {
                int errorId = MakeError("cannot move an instance of a static class", node->GetFullSpan(), classType->FullSpan());
                return Result<bool>(ErrorId(errorId));
            }
            TypeSymbol* rightType = arguments[1]->Type()->PlainType(context);
            bool bindToRvalueRef = arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference);
            bool typesEqual = TypesEqual(arguments[1]->Type(), classType->AddRvalueReference(context));
            if (!typesEqual)
            {
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> conversionResult = GetConversion(rightType, classType, containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (conversionResult.Error()) return Result<bool>(ErrorId(conversionResult.GetErrorId()));
                FunctionSymbol* conversion = conversionResult.Value();
                if (conversion != null && conversion->IsConversionFunctionSymbol())
                {
                    if (conversion->ReturnsClassInterfaceOrClassDelegateByValue())
                    {
                        bindToRvalueRef = true;
                    }
                }
                else if (!TypesEqual(rightType, classType))
                {
                    return Result<bool>(false); // reject conversion
                }
            }
            if (typesEqual || bindToRvalueRef)
            {
                if (classType->MoveConstructor() != null)
                {
                    viableFunctions.Add(classType->MoveConstructor());
                    return Result<bool>(true);
                }
                if (classType->IsClassTemplateSpecializationSymbol())
                {
                    ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(classType);
                    Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                    if (result.Error()) return result;
                }
                FunctionSymbol* function = functionMap[classType];
                if (function == null)
                {
                    UniquePtr<ClassMoveConstructor> moveConstructor(new ClassMoveConstructor(node->GetSpan(), classType, GetBoundCompileUnit()));
                    if (moveConstructor->Error()) return Result<bool>(ErrorId(moveConstructor->GetErrorId()));
                    moveConstructor->SetSourceFile(GetBoundCompileUnit()->SourceFile());
                    if (GetCollectFlag(flags, CollectFlags.dontInstantiate))
                    {
                        function = moveConstructor.Get();
                        function->SetModule(GetModule());
                        functions.Add(UniquePtr<FunctionSymbol>(moveConstructor.Release()));
                    }
                    else
                    {
                        Result<bool> result = GenerateImplementation(moveConstructor.Get(), containerScope, currentFunction, node);
                        if (result.Error()) return result;
                        function = moveConstructor.Get();
                        function->SetModule(GetModule());
                        functionMap[classType] = function;
                        functions.Add(UniquePtr<FunctionSymbol>(moveConstructor.Release()));
                    }
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private Result<bool> GenerateImplementation(ClassMoveConstructor* moveConstructor, ContainerScope* containerScope, BoundFunction* currentFunction, Node* node)
        {
            ClassTypeSymbol* classType = moveConstructor->ClassType();
            SymbolsContext& context = Context();
            UniquePtr<BoundFunction> boundFunction(new BoundFunction(node->GetSpan(), moveConstructor, node->ModuleId(), node->FileIndex()));
            boundFunction->SetNode(node);
            boundFunction->SetBody(UniquePtr<BoundCompoundStatement>(new BoundCompoundStatement(node->GetSpan())));
            if (classType->StaticConstructor() != null)
            {
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(), UniquePtr<BoundExpression>(
                    new BoundFunctionCall(node->GetSpan(), classType->StaticConstructor())))));
                moveConstructor->SetCannotInline();
            }
            if (classType->BaseClass() != null)
            {
                List<FunctionScopeLookup> baseConstructorCallLookups;
                baseConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                baseConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_, classType->BaseClass()->GetContainerScope()));
                baseConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                List<UniquePtr<BoundExpression>> baseConstructorCallArguments;
                ParameterSymbol* thisParam = moveConstructor->Parameters()[0];
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> thisToBaseConversionResult = GetConversion(thisParam->Type(), classType->BaseClass()->AddPointer(context),
                    containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (thisToBaseConversionResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(thisToBaseConversionResult.GetErrorId());
                    int errorId = MakeError("Cannot create move constructor for class '" + classTypeFullName +
                        "'. Reason: base class conversion not found:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                FunctionSymbol* thisToBaseConversion = thisToBaseConversionResult.Value();
                UniquePtr<BoundExpression> baseClassPointerConversion(new BoundConversion(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)), thisToBaseConversion));
                baseConstructorCallArguments.Add(Rvalue(baseClassPointerConversion));
                ParameterSymbol* thatParam = moveConstructor->Parameters()[1];
                Result<FunctionSymbol*> thatToBaseConversionResult = GetConversion(thatParam->Type(), classType->BaseClass()->AddRvalueReference(context),
                    containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (thatToBaseConversionResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(thatToBaseConversionResult.GetErrorId());
                    int errorId = MakeError("Cannot create move constructor for class '" + classTypeFullName +
                        "'. Reason: base class conversion not found:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                FunctionSymbol* thatToBaseConversion = thatToBaseConversionResult.Value();
                UniquePtr<BoundExpression> thatArgumentConversion(new BoundConversion(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thatParam)), thatToBaseConversion));
                baseConstructorCallArguments.Add(Rvalue(thatArgumentConversion));
                Result<UniquePtr<BoundFunctionCall>> baseConstructorCallResult = ResolveOverload(u"@constructor", containerScope, baseConstructorCallLookups,
                    baseConstructorCallArguments, GetBoundCompileUnit(), boundFunction.Get(), node);
                if (baseConstructorCallResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(baseConstructorCallResult.GetErrorId());
                    int errorId = MakeError("Cannot create move constructor for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(),
                    UniquePtr<BoundExpression>(baseConstructorCallResult.Value().Release()))));
                moveConstructor->SetCannotInline();
            }
            if (classType->IsPolymorphic())
            {
                ParameterSymbol* thisParam = moveConstructor->Parameters()[0];
                UniquePtr<BoundExpression> classPtr;
                Result<ClassTypeSymbol*> vmtPtrHolderClassResult = classType->VmtPtrHolderClass();
                if (vmtPtrHolderClassResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(vmtPtrHolderClassResult.GetErrorId());
                    int errorId = MakeError("Cannot create move constructor for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                ClassTypeSymbol* vmtPtrHolderClass = vmtPtrHolderClassResult.Value();
                if (vmtPtrHolderClass == classType)
                {
                    classPtr.Reset(new BoundParameter(node->GetSpan(), thisParam));
                }
                else
                {
                    ArgumentMatch argumentMatch;
                    Result<FunctionSymbol*> thisToHolderConversionResult = GetConversion(thisParam->Type(), vmtPtrHolderClass->AddPointer(context),
                        containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                    if (thisToHolderConversionResult.Error())
                    {
                        Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                        if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                        string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                        string message = RtmGetErrorMessageWithoutStackTrace(thisToHolderConversionResult.GetErrorId());
                        int errorId = MakeError("Cannot create move constructor for class '" + classTypeFullName +
                            "'. Reason:\n" + message, node->GetFullSpan(), classType->FullSpan());
                        return Result<bool>(ErrorId(errorId));
                    }
                    FunctionSymbol* thisToHolderConversion = thisToHolderConversionResult.Value();
                    classPtr.Reset(new BoundConversion(node->GetSpan(), UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)), thisToHolderConversion));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundSetVmtPtrStatement(node->GetSpan(), Rvalue(classPtr), classType)));
                moveConstructor->SetCannotInline();
            }
            int n = cast<int>(classType->MemberVariables().Count());
            if (n > maxGeneratedInlineFunctionMembers)
            {
                moveConstructor->SetCannotInline();
            }
            for (int i = 0; i < n; ++i)
            {
                MemberVariableSymbol* memberVariableSymbol = classType->MemberVariables()[i];
                List<FunctionScopeLookup> memberConstructorCallLookups;
                memberConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                Result<ContainerScope*> scopeResult = memberVariableSymbol->Type()->BaseType()->ClassInterfaceEnumDelegateOrNsScope();
                if (scopeResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(scopeResult.GetErrorId());
                    int errorId = MakeError("Cannot create move constructor for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), memberVariableSymbol->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                ContainerScope* scope = scopeResult.Value();
                memberConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_, scope));
                memberConstructorCallLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                List<UniquePtr<BoundExpression>> memberConstructorCallArguments;
                UniquePtr<BoundMemberVariable> boundMemberVariable(new BoundMemberVariable(node->GetSpan(), memberVariableSymbol));
                ParameterSymbol* thisParam = moveConstructor->GetThisParam();
                #assert(thisParam != null);
                boundMemberVariable->SetClassPtr(UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)));
                memberConstructorCallArguments.Add(UniquePtr<BoundExpression>(new BoundAddressOfExpression(node->GetSpan(),
                    UniquePtr<BoundExpression>(boundMemberVariable.Release()), boundMemberVariable->Type()->AddPointer(context))));
                ParameterSymbol* thatParam = moveConstructor->Parameters()[1];
                UniquePtr<BoundMemberVariable> thatBoundMemberVariable(new BoundMemberVariable(node->GetSpan(), memberVariableSymbol));
                thatBoundMemberVariable->SetClassPtr(UniquePtr<BoundExpression>(new BoundReferenceToPointerExpression(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thatParam)), thatParam->Type()->BaseType()->AddPointer(context))));
                memberConstructorCallArguments.Add(UniquePtr<BoundExpression>(thatBoundMemberVariable.Release()));
                Result<UniquePtr<BoundFunctionCall>> memberConstructorCallResult = ResolveOverload(u"@constructor", containerScope,
                    memberConstructorCallLookups, memberConstructorCallArguments, GetBoundCompileUnit(), boundFunction.Get(), node);
                if (memberConstructorCallResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(memberConstructorCallResult.GetErrorId());
                    int errorId = MakeError("Cannot create move constructor for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), memberVariableSymbol->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(),
                    UniquePtr<BoundExpression>(memberConstructorCallResult.Value().Release()))));
            }
            GetBoundCompileUnit()->AddBoundNode(UniquePtr<BoundNode>(boundFunction.Release()));
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class ClassCopyAssignment : MemberFunctionSymbol
    {
        public ClassCopyAssignment(const System.Lex.Span& span_, ClassTypeSymbol* classType_, TypeSymbol* voidType, BoundCompileUnit* boundCompileUnit) :
            base(span_, u"operator="), classType(classType_)
        {
            SymbolsContext& context = boundCompileUnit->Context();
            SetGroupName(u"operator=");
            SetGenerated();
            SetAccess(SymbolAccess.public_);
            SetParent(classType);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(classType->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(classType->AddConst(context)->AddLvalueReference(context));
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            Result<string> sourceFileIdResult = boundCompileUnit->SourceFile()->Id();
            if (sourceFileIdResult.Error())
            {
                SetErrorId(sourceFileIdResult.GetErrorId());
                return;
            }
            SetSourceFileId(sourceFileIdResult.Value());
            SetReturnType(voidType);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public inline ClassTypeSymbol* ClassType() const
        {
            return classType;
        }
        private ClassTypeSymbol* classType;
    }

    public class ClassCopyAssignmentOperation : Operation
    {
        public ClassCopyAssignmentOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator=", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            SymbolsContext& context = Context();
            TypeSymbol* baseType = type->RemovePointer(context)->PlainType(context);
            if (type->PointerCount() != 1 || !baseType->IsClassTypeSymbol()) return Result<bool>(false);
            ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type->BaseType());
            if (classType->IsStatic())
            {
                int errorId = MakeError("cannot assign an instance of a static class", node->GetFullSpan(), classType->FullSpan());
                return Result<bool>(ErrorId(errorId));
            }
            TypeSymbol* rightType = arguments[1]->Type()->PlainType(context);
            bool typesEqual = TypesEqual(rightType, classType);
            bool bindToRvalueRef = arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference);
            bool conversionFunctionExists = false;
            if (!typesEqual)
            {
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> conversionResult = GetConversion(rightType, classType, containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (!conversionResult.Error())
                {
                    FunctionSymbol* conversion = conversionResult.Value();
                    if (conversion != null && conversion->IsConversionFunctionSymbol())
                    {
                        conversionFunctionExists = true;
                        if (conversion->ReturnsClassInterfaceOrClassDelegateByValue())
                        {
                            bindToRvalueRef = true; // in this case class move constructor will match
                        }
                    }
                }
            }
            if (typesEqual ||
                GetCollectFlag(flags, CollectFlags.noRvalueRef) ||
                (!TypesEqual(arguments[1]->Type(), classType->AddRvalueReference(context)) && !bindToRvalueRef) && (typesEqual || conversionFunctionExists))
            {
                if (classType->CopyAssignment() != null)
                {
                    viableFunctions.Add(classType->CopyAssignment());
                    return Result<bool>(true);
                }
                if (classType->IsClassTemplateSpecializationSymbol())
                {
                    ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(classType);
                    Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                    if (result.Error()) return result;
                }
                FunctionSymbol* function = functionMap[classType];
                if (function == null)
                {
                    Result<TypeSymbol*> voidTypeResult = GetSymbolTable()->GetTypeByName(u"void");
                    if (voidTypeResult.Error()) return Result<bool>(ErrorId(voidTypeResult.GetErrorId()));
                    TypeSymbol* voidType = voidTypeResult.Value();
                    UniquePtr<ClassCopyAssignment> copyAssignment(new ClassCopyAssignment(node->GetSpan(), classType, voidType, GetBoundCompileUnit()));
                    if (copyAssignment->Error()) return Result<bool>(ErrorId(copyAssignment->GetErrorId()));
                    copyAssignment->SetSourceFile(GetBoundCompileUnit()->SourceFile());
                    if (GetCollectFlag(flags, CollectFlags.dontInstantiate))
                    {
                        function = copyAssignment.Get();
                        function->SetModule(GetModule());
                        functions.Add(UniquePtr<FunctionSymbol>(copyAssignment.Release()));
                    }
                    else
                    {
                        Result<bool> result = GenerateImplementation(copyAssignment.Get(), containerScope, currentFunction, node);
                        if (result.Error()) return result;
                        function = copyAssignment.Get();
                        function->SetModule(GetModule());
                        functionMap[classType] = function;
                        functions.Add(UniquePtr<FunctionSymbol>(copyAssignment.Release()));
                    }
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private Result<bool> GenerateImplementation(ClassCopyAssignment* copyAssignment, ContainerScope* containerScope, BoundFunction* currentFunction, Node* node)
        {
            ClassTypeSymbol* classType = copyAssignment->ClassType();
            SymbolsContext& context = Context();
            UniquePtr<BoundFunction> boundFunction(new BoundFunction(node->GetSpan(), copyAssignment, node->ModuleId(), node->FileIndex()));
            boundFunction->SetNode(node);
            boundFunction->SetBody(UniquePtr<BoundCompoundStatement>(new BoundCompoundStatement(node->GetSpan())));
            if (classType->BaseClass() != null)
            {
                List<FunctionScopeLookup> baseAssignmentCallLookups;
                baseAssignmentCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                baseAssignmentCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_, classType->BaseClass()->GetContainerScope()));
                baseAssignmentCallLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                List<UniquePtr<BoundExpression>> baseAssignmentCallArguments;
                ParameterSymbol* thisParam = copyAssignment->Parameters()[0];
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> thisToBaseConversionResult = GetConversion(thisParam->Type(), classType->BaseClass()->AddPointer(context),
                    containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (thisToBaseConversionResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(thisToBaseConversionResult.GetErrorId());
                    int errorId = MakeError("Cannot create copy assignment for class '" + classTypeFullName +
                        "'. Reason: base class conversion not found:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                FunctionSymbol* thisToBaseConversion = thisToBaseConversionResult.Value();
                UniquePtr<BoundExpression> baseClassPointerConversion(new BoundConversion(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)), thisToBaseConversion));
                baseAssignmentCallArguments.Add(Rvalue(baseClassPointerConversion));
                ParameterSymbol* thatParam = copyAssignment->Parameters()[1];
                Result<FunctionSymbol*> thatToBaseConversionResult = GetConversion(thatParam->Type(), classType->BaseClass()->AddConst(context)->AddLvalueReference(context),
                    containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (thatToBaseConversionResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(thatToBaseConversionResult.GetErrorId());
                    int errorId = MakeError("Cannot create copy assignment for class '" + classTypeFullName +
                        "'. Reason: base class conversion not found:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                FunctionSymbol* thatToBaseConversion = thatToBaseConversionResult.Value();
                UniquePtr<BoundExpression> thatArgumentConversion(new BoundConversion(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thatParam)), thatToBaseConversion));
                baseAssignmentCallArguments.Add(Rvalue(thatArgumentConversion));
                Result<UniquePtr<BoundFunctionCall>> baseAssignmentCallResult = ResolveOverload(u"operator=", containerScope, baseAssignmentCallLookups,
                    baseAssignmentCallArguments, GetBoundCompileUnit(), boundFunction.Get(), node);
                if (baseAssignmentCallResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(baseAssignmentCallResult.GetErrorId());
                    int errorId = MakeError("Cannot create copy assignment for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(),
                    UniquePtr<BoundExpression>(baseAssignmentCallResult.Value().Release()))));
                copyAssignment->SetCannotInline();
            }
            int n = cast<int>(classType->MemberVariables().Count());
            if (n > maxGeneratedInlineFunctionMembers)
            {
                copyAssignment->SetCannotInline();
            }
            for (int i = 0; i < n; ++i)
            {
                MemberVariableSymbol* memberVariableSymbol = classType->MemberVariables()[i];
                List<FunctionScopeLookup> memberAssignmentCallLookups;
                memberAssignmentCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                Result<ContainerScope*> scopeResult = memberVariableSymbol->Type()->BaseType()->ClassInterfaceEnumDelegateOrNsScope();
                if (scopeResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(scopeResult.GetErrorId());
                    int errorId = MakeError("Cannot create copy assignment for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), memberVariableSymbol->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                ContainerScope* scope = scopeResult.Value();
                memberAssignmentCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_, scope));
                memberAssignmentCallLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                List<UniquePtr<BoundExpression>> memberAssignmentCallArguments;
                UniquePtr<BoundMemberVariable> boundMemberVariable(new BoundMemberVariable(node->GetSpan(), memberVariableSymbol));
                ParameterSymbol* thisParam = copyAssignment->GetThisParam();
                #assert(thisParam != null);
                boundMemberVariable->SetClassPtr(UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)));
                TypeSymbol* type = boundMemberVariable->Type()->AddPointer(context);
                memberAssignmentCallArguments.Add(UniquePtr<BoundExpression>(new BoundAddressOfExpression(node->GetSpan(),
                    UniquePtr<BoundExpression>(boundMemberVariable.Release()), type)));
                ParameterSymbol* thatParam = copyAssignment->Parameters()[1];
                UniquePtr<BoundMemberVariable> thatBoundMemberVariable(new BoundMemberVariable(node->GetSpan(), memberVariableSymbol));
                thatBoundMemberVariable->SetClassPtr(UniquePtr<BoundExpression>(new BoundReferenceToPointerExpression(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thatParam)), thatParam->Type()->BaseType()->AddPointer(context))));
                memberAssignmentCallArguments.Add(UniquePtr<BoundExpression>(thatBoundMemberVariable.Release()));
                Result<UniquePtr<BoundFunctionCall>> memberAssignmentCallResult = ResolveOverload(u"operator=", containerScope,
                    memberAssignmentCallLookups, memberAssignmentCallArguments, GetBoundCompileUnit(), boundFunction.Get(), node);
                if (memberAssignmentCallResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(memberAssignmentCallResult.GetErrorId());
                    int errorId = MakeError("Cannot create copy asssignment for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), memberVariableSymbol->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(),
                    UniquePtr<BoundExpression>(memberAssignmentCallResult.Value().Release()))));
            }
            GetBoundCompileUnit()->AddBoundNode(UniquePtr<BoundNode>(boundFunction.Release()));
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class ClassMoveAssignment : MemberFunctionSymbol
    {
        public ClassMoveAssignment(const System.Lex.Span& span_, ClassTypeSymbol* classType_, TypeSymbol* voidType, BoundCompileUnit* boundCompileUnit) :
            base(span_, u"operator="), classType(classType_)
        {
            SymbolsContext& context = boundCompileUnit->Context();
            SetGroupName(u"operator=");
            SetGenerated();
            SetAccess(SymbolAccess.public_);
            SetParent(classType);
            ParameterSymbol* thisParam = new ParameterSymbol(span_, u"this");
            thisParam->SetType(classType->AddPointer(context));
            Result<bool> result = AddMember(thisParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            ParameterSymbol* thatParam = new ParameterSymbol(span_, u"that");
            thatParam->SetType(classType->AddRvalueReference(context));
            result = AddMember(thatParam, context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            Result<string> sourceFileIdResult = boundCompileUnit->SourceFile()->Id();
            if (sourceFileIdResult.Error())
            {
                SetErrorId(sourceFileIdResult.GetErrorId());
                return;
            }
            SetSourceFileId(sourceFileIdResult.Value());
            SetReturnType(voidType);
            result = ComputeName(context);
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
        }
        public inline ClassTypeSymbol* ClassType() const
        {
            return classType;
        }
        private ClassTypeSymbol* classType;
    }

    public class ClassMoveAssignmentOperation : Operation
    {
        public ClassMoveAssignmentOperation(BoundCompileUnit* boundCompileUnit_) : base(u"operator=", 2, boundCompileUnit_)
        {
        }
        [nodiscard]
        public override Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            TypeSymbol* type = arguments[0]->Type();
            SymbolsContext& context = Context();
            TypeSymbol* baseType = type->RemovePointer(context)->PlainType(context);
            if (type->PointerCount() != 1 || !baseType->IsClassTypeSymbol()) return Result<bool>(false);
            ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type->BaseType());
            if (classType->IsStatic())
            {
                int errorId = MakeError("cannot assign an instance of a static class", node->GetFullSpan(), classType->FullSpan());
                return Result<bool>(ErrorId(errorId));
            }
            TypeSymbol* rightType = arguments[1]->Type()->PlainType(context);
            bool typesEqual = TypesEqual(rightType, classType->AddRvalueReference(context));
            bool bindToRvalueRef = arguments[1]->GetFlag(BoundExpressionFlags.bindToRvalueReference);
            if (!typesEqual)
            {
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> conversionResult = GetConversion(rightType, classType, containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (!conversionResult.Error())
                {
                    FunctionSymbol* conversion = conversionResult.Value();
                    if (conversion != null && conversion->IsConversionFunctionSymbol())
                    {
                        if (conversion->ReturnsClassInterfaceOrClassDelegateByValue())
                        {
                            bindToRvalueRef = true;
                        }
                    }
                }
            }
            if (typesEqual || bindToRvalueRef)
            {
                if (classType->MoveAssignment() != null)
                {
                    viableFunctions.Add(classType->MoveAssignment());
                    return Result<bool>(true);
                }
                if (classType->IsClassTemplateSpecializationSymbol())
                {
                    ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(classType);
                    Result<bool> result = GetBoundCompileUnit()->FinalizeBinding(specialization);
                    if (result.Error()) return result;
                }
                FunctionSymbol* function = functionMap[classType];
                if (function == null)
                {
                    Result<TypeSymbol*> voidTypeResult = GetSymbolTable()->GetTypeByName(u"void");
                    if (voidTypeResult.Error()) return Result<bool>(ErrorId(voidTypeResult.GetErrorId()));
                    TypeSymbol* voidType = voidTypeResult.Value();
                    UniquePtr<ClassMoveAssignment> moveAssignment(new ClassMoveAssignment(node->GetSpan(), classType, voidType, GetBoundCompileUnit()));
                    if (moveAssignment->Error()) return Result<bool>(ErrorId(moveAssignment->GetErrorId()));
                    moveAssignment->SetSourceFile(GetBoundCompileUnit()->SourceFile());
                    if (GetCollectFlag(flags, CollectFlags.dontInstantiate))
                    {
                        function = moveAssignment.Get();
                        function->SetModule(GetModule());
                        functions.Add(UniquePtr<FunctionSymbol>(moveAssignment.Release()));
                    }
                    else
                    {
                        Result<bool> result = GenerateImplementation(moveAssignment.Get(), containerScope, currentFunction, node);
                        if (result.Error()) return result;
                        function = moveAssignment.Get();
                        function->SetModule(GetModule());
                        functionMap[classType] = function;
                        functions.Add(UniquePtr<FunctionSymbol>(moveAssignment.Release()));
                    }
                }
                viableFunctions.Add(function);
                return Result<bool>(true);
            }
            else
            {
                return Result<bool>(false);
            }
        }
        private Result<bool> GenerateImplementation(ClassMoveAssignment* moveAssignment, ContainerScope* containerScope, BoundFunction* currentFunction, Node* node)
        {
            ClassTypeSymbol* classType = moveAssignment->ClassType();
            SymbolsContext& context = Context();
            UniquePtr<BoundFunction> boundFunction(new BoundFunction(node->GetSpan(), moveAssignment, node->ModuleId(), node->FileIndex()));
            boundFunction->SetNode(node);
            boundFunction->SetBody(UniquePtr<BoundCompoundStatement>(new BoundCompoundStatement(node->GetSpan())));
            if (classType->BaseClass() != null)
            {
                List<FunctionScopeLookup> baseAssignmentCallLookups;
                baseAssignmentCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                baseAssignmentCallLookups.Add(FunctionScopeLookup(ScopeLookup.this_, classType->BaseClass()->GetContainerScope()));
                baseAssignmentCallLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                List<UniquePtr<BoundExpression>> baseAssignmentCallArguments;
                ParameterSymbol* thisParam = moveAssignment->Parameters()[0];
                ArgumentMatch argumentMatch;
                Result<FunctionSymbol*> thisToBaseConversionResult = GetConversion(thisParam->Type(), classType->BaseClass()->AddPointer(context),
                    containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (thisToBaseConversionResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(thisToBaseConversionResult.GetErrorId());
                    int errorId = MakeError("Cannot create move assignment for class '" + classTypeFullName +
                        "'. Reason: base class conversion not found:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                FunctionSymbol* thisToBaseConversion = thisToBaseConversionResult.Value();
                UniquePtr<BoundExpression> baseClassPointerConversion(new BoundConversion(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)), thisToBaseConversion));
                baseAssignmentCallArguments.Add(Rvalue(baseClassPointerConversion));
                ParameterSymbol* thatParam = moveAssignment->Parameters()[1];
                Result<FunctionSymbol*> thatToBaseConversionResult = GetConversion(thatParam->Type(), classType->BaseClass()->AddRvalueReference(context),
                    containerScope, GetBoundCompileUnit(), currentFunction, argumentMatch, node);
                if (thatToBaseConversionResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(thatToBaseConversionResult.GetErrorId());
                    int errorId = MakeError("Cannot create move assignment for class '" + classTypeFullName +
                        "'. Reason: base class conversion not found:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                FunctionSymbol* thatToBaseConversion = thatToBaseConversionResult.Value();
                UniquePtr<BoundExpression> thatArgumentConversion(new BoundConversion(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thatParam)), thatToBaseConversion));
                baseAssignmentCallArguments.Add(Rvalue(thatArgumentConversion));
                Result<UniquePtr<BoundFunctionCall>> baseAssignmentCallResult = ResolveOverload(u"operator=", containerScope, baseAssignmentCallLookups,
                    baseAssignmentCallArguments, GetBoundCompileUnit(), boundFunction.Get(), node);
                if (baseAssignmentCallResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(baseAssignmentCallResult.GetErrorId());
                    int errorId = MakeError("Cannot create move assignment for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), classType->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(),
                    UniquePtr<BoundExpression>(baseAssignmentCallResult.Value().Release()))));
                moveAssignment->SetCannotInline();
            }
            int n = cast<int>(classType->MemberVariables().Count());
            if (n > maxGeneratedInlineFunctionMembers)
            {
                moveAssignment->SetCannotInline();
            }
            for (int i = 0; i < n; ++i)
            {
                MemberVariableSymbol* memberVariableSymbol = classType->MemberVariables()[i];
                List<FunctionScopeLookup> swapLookups;
                swapLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                swapLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                List<UniquePtr<BoundExpression>> swapArguments;
                UniquePtr<BoundMemberVariable> boundMemberVariable(new BoundMemberVariable(node->GetSpan(), memberVariableSymbol));
                ParameterSymbol* thisParam = moveAssignment->GetThisParam();
                #assert(thisParam != null);
                boundMemberVariable->SetClassPtr(UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thisParam)));
                swapArguments.Add(UniquePtr<BoundExpression>(boundMemberVariable.Release()));
                ParameterSymbol* thatParam = moveAssignment->Parameters()[1];
                UniquePtr<BoundMemberVariable> thatBoundMemberVariable(new BoundMemberVariable(node->GetSpan(), memberVariableSymbol));
                thatBoundMemberVariable->SetClassPtr(UniquePtr<BoundExpression>(new BoundReferenceToPointerExpression(node->GetSpan(),
                    UniquePtr<BoundExpression>(new BoundParameter(node->GetSpan(), thatParam)), thatParam->Type()->BaseType()->AddPointer(context))));
                swapArguments.Add(UniquePtr<BoundExpression>(thatBoundMemberVariable.Release()));
                Result<UniquePtr<BoundFunctionCall>> swapCallResult = ResolveOverload(u"System.Swap", containerScope,
                    swapLookups, swapArguments, GetBoundCompileUnit(), boundFunction.Get(), node);
                if (swapCallResult.Error())
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error()) return Result<bool>(ErrorId(classTypeFullNameResult.GetErrorId()));
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    string message = RtmGetErrorMessageWithoutStackTrace(swapCallResult.GetErrorId());
                    int errorId = MakeError("Cannot create move asssignment for class '" + classTypeFullName +
                        "'. Reason:\n" + message, node->GetFullSpan(), memberVariableSymbol->FullSpan());
                    return Result<bool>(ErrorId(errorId));
                }
                boundFunction->Body()->AddStatement(UniquePtr<BoundStatement>(new BoundInitializationStatement(node->GetSpan(),
                    UniquePtr<BoundExpression>(swapCallResult.Value().Release()))));
            }
            GetBoundCompileUnit()->AddBoundNode(UniquePtr<BoundNode>(boundFunction.Release()));
            return Result<bool>(true);
        }
        private Map<TypeSymbol*, FunctionSymbol*> functionMap;
        private List<UniquePtr<FunctionSymbol>> functions;
    }

    public class ArityOperation
    {
        public ArityOperation() : operations()
        {
        }
        public void Add(Operation* operation)
        {
            operations.Add(operation);
        }
        [nodiscard]
        public Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            bool error = false;
            bool collected = false;
            string message;
            for (Operation* operation : operations)
            {
                Result<bool> result = operation->CollectViableFunctions(containerScope, arguments, currentFunction, node, flags, viableFunctions);
                if (result.Error())
                {
                    error = true;
                    if (!message.IsEmpty())
                    {
                        message.Append("\n");
                    }
                    message.Append(RtmGetErrorMessageWithoutStackTrace(result.GetErrorId()));
                }
                if (result.Value())
                {
                    collected = true;
                }
            }
            if (error && !collected)
            {
                int errorId = MakeError(message, node->GetFullSpan());
                return Result<bool>(ErrorId(errorId));
            }
            return Result<bool>(collected);
        }
        private List<Operation*> operations;
    }

    public class OperationGroup
    {
        public OperationGroup()
        {
        }
        public void Add(Operation* operation)
        {
            int arity = operation->Arity();
            while (arity >= arityOperations.Count())
            {
                arityOperations.Add(UniquePtr<ArityOperation>());
            }
            ArityOperation* arityOperation = arityOperations[arity].Get();
            if (arityOperation == null)
            {
                arityOperation = new ArityOperation();
                arityOperations[arity].Reset(arityOperation);
            }
            arityOperation->Add(operation);
        }
        [nodiscard]
        public Result<bool> CollectViableFunctions(ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments, BoundFunction* currentFunction,
            Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            int arity = cast<int>(arguments.Count());
            if (arity < arityOperations.Count())
            {
                ArityOperation* arityOperation = arityOperations[arity].Get();
                return arityOperation->CollectViableFunctions(containerScope, arguments, currentFunction, node, flags, viableFunctions);
            }
            return Result<bool>(false);
        }
        private List<UniquePtr<ArityOperation>> arityOperations;
    }

    public class OperationRepository
    {
        public OperationRepository(BoundCompileUnit* boundCompileUnit_) : boundCompileUnit(boundCompileUnit_)
        {
            Add(new PointerDefaultConstructorOperation(boundCompileUnit));
            Add(new PointerCopyConstructorOperation(boundCompileUnit));
            Add(new PointerMoveConstructorOperation(boundCompileUnit));
            Add(new PointerCopyAssignmentOperation(boundCompileUnit));
            Add(new PointerMoveAssignmentOperation(boundCompileUnit));
            Add(new PointerReturnOperation(boundCompileUnit));
            Add(new PointerPlusOffsetOperation(boundCompileUnit));
            Add(new OffsetPlusPointerOperation(boundCompileUnit));
            Add(new PointerMinusOffsetOperation(boundCompileUnit));
            Add(new PointerMinusPointerOperation(boundCompileUnit));
            Add(new PointerEqualOperation(boundCompileUnit));
            Add(new PointerLessOperation(boundCompileUnit));
            Add(new PointerArrowOperation(boundCompileUnit));
            Add(new LvalueReferenceCopyConstructorOperation(boundCompileUnit));
            Add(new LvalueReferenceCopyAssignmentOperation(boundCompileUnit));
            Add(new LvalueReferenceMoveAssignmentOperation(boundCompileUnit));
            Add(new LvalueReferenceReturnOperation(boundCompileUnit));
            Add(new RvalueReferenceCopyConstructorOperation(boundCompileUnit));
            Add(new RvalueReferenceCopyAssignmentOperation(boundCompileUnit));
            Add(new RvalueReferenceReturnOperation(boundCompileUnit));
            Add(new ArrayDefaultConstructorOperation(boundCompileUnit));
            Add(new ArrayCopyConstructorOperation(boundCompileUnit));
            Add(new ArrayMoveConstructorOperation(boundCompileUnit));
            Add(new ArrayCopyAssignmentOperation(boundCompileUnit));
            Add(new ArrayMoveAssignmentOperation(boundCompileUnit));
            Add(new ArrayElementAccessOperation(boundCompileUnit));
            Add(new ClassDefaultConstructorOperation(boundCompileUnit));
            classCopyConstructorOperation = new ClassCopyConstructorOperation(boundCompileUnit);
            Add(classCopyConstructorOperation);
            Add(new ClassMoveConstructorOperation(boundCompileUnit));
            Add(new ClassCopyAssignmentOperation(boundCompileUnit));
            Add(new ClassMoveAssignmentOperation(boundCompileUnit));
        }
        public void Add(Operation* operation)
        {
            OperationGroup* group = null;
            auto it = operationGroupMap.Find(operation->GroupName());
            if (it != operationGroupMap.End())
            {
                group = it->second;
            }
            else
            {
                group = new OperationGroup();
                operationGroupMap.Insert(MakePair(operation->GroupName(), group));
                operationGroups.Add(UniquePtr<OperationGroup>(group));
            }
            group->Add(operation);
            operations.Add(UniquePtr<Operation>(operation));
        }
        [nodiscard]
        public Result<bool> CollectViableFunctions(const ustring& groupName, ContainerScope* containerScope, const List<UniquePtr<BoundExpression>>& arguments,
            BoundFunction* currentFunction, Node* node, CollectFlags flags, ViableFunctionSet& viableFunctions)
        {
            auto it = operationGroupMap.Find(groupName);
            if (it != operationGroupMap.End())
            {
                OperationGroup* operationGroup = it->second;
                return operationGroup->CollectViableFunctions(containerScope, arguments, currentFunction, node, flags, viableFunctions);
            }
            return Result<bool>(false);
        }
        public Result<FunctionSymbol*> GetClassCopyConstructor(ClassTypeSymbol* cls, BoundFunction* currentFunction)
        {
            Node* node = currentFunction->GetNode();
            SymbolsContext& context = boundCompileUnit->Context();
            ViableFunctionSet viableFunctions;
            List<UniquePtr<BoundExpression>> arguments;
            UniquePtr<BoundExpression> clsTypeExpr(new BoundTypeExpression(node->GetSpan(), cls));
            Result<TypeSymbol*> clsPointerTypeResult = cls->AddPointer(context);
            if (clsPointerTypeResult.Error()) return Result<FunctionSymbol*>(ErrorId(clsPointerTypeResult.GetErrorId()));
            TypeSymbol* clsPointerType = clsPointerTypeResult.Value();
            arguments.Add(UniquePtr<BoundExpression>(new BoundAddressOfExpression(node->GetSpan(), Rvalue(clsTypeExpr), clsPointerType)));
            Result<TypeSymbol*> classLvalueRefTypeResult = cls->AddConst(context)->AddLvalueReference(context);
            if (classLvalueRefTypeResult.Error()) return Result<FunctionSymbol*>(ErrorId(classLvalueRefTypeResult.GetErrorId()));
            TypeSymbol* classLvalueRefType = classLvalueRefTypeResult.Value();
            arguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(node->GetSpan(), classLvalueRefType)));
            ContainerScope* containerScope = cls->GetContainerScope();
            Result<bool> result = classCopyConstructorOperation->CollectViableFunctions(containerScope, arguments, currentFunction, node, CollectFlags.none, viableFunctions);
            if (viableFunctions.Count() != 1)
            {
                Result<string> clsFullNameResult = ToUtf8(cls->FullName());
                if (clsFullNameResult.Error()) return Result<FunctionSymbol*>(ErrorId(clsFullNameResult.GetErrorId()));
                string clsFullName = Rvalue(clsFullNameResult.Value());
                string reasonMessage = RtmGetErrorMessageWithoutStackTrace(result.GetErrorId());
                int errorId = MakeError("could not generate copy constructor for class type '" + clsFullName + "': " + reasonMessage, currentFunction->FullSpan());
                return Result<FunctionSymbol*>(ErrorId(errorId));
            }
            FunctionSymbol* copyCtor = *(viableFunctions.Get().Begin());
            return Result<FunctionSymbol*>(copyCtor);
        }
        private BoundCompileUnit* boundCompileUnit;
        private Map<ustring, OperationGroup*> operationGroupMap;
        private List<UniquePtr<OperationGroup>> operationGroups;
        private List<UniquePtr<Operation>> operations;
        private ClassCopyConstructorOperation* classCopyConstructorOperation;
    }
}

