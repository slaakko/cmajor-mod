// =================================
// Copyright (c) 2024 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using symbols;
using cm.ast;

namespace binder
{
    public class ExpressionBinder : Visitor
    {
        public ExpressionBinder(BoundCompileUnit* boundCompileUnit_, BoundFunction* boundFunction_, ContainerScope* containerScope_, StatementBinder* statementBinder_,
            bool lvalue_) : boundCompileUnit(boundCompileUnit_), context(boundCompileUnit->Context()),
            symbolTable(boundCompileUnit->GetSymbolTable()), module(boundCompileUnit->GetModule()),
            boundFunction(boundFunction_), containerScope(containerScope_), statementBinder(statementBinder_), lvalue(lvalue_), inhibitCompile(false), errorId(0)
        {
        }
        public UniquePtr<BoundExpression> GetExpression()
        {
            return Rvalue(expression);
        }
        public override void Visit(BoolNode& boolNode)
        {
            Result<TypeSymbol*> boolTypeResult = symbolTable->GetTypeByName(u"bool");
            if (boolTypeResult.Error())
            {
                SetErrorId(boolTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* boolType = boolTypeResult.Value();
            expression.Reset(new BoundTypeExpression(boolNode.GetSpan(), boolType));
        }
        public override void Visit(SByteNode& sbyteNode)
        {
            Result<TypeSymbol*> sbyteTypeResult = symbolTable->GetTypeByName(u"sbyte");
            if (sbyteTypeResult.Error())
            {
                SetErrorId(sbyteTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* sbyteType = sbyteTypeResult.Value();
            expression.Reset(new BoundTypeExpression(sbyteNode.GetSpan(), sbyteType));
        }
        public override void Visit(ByteNode& byteNode)
        {
            Result<TypeSymbol*> byteTypeResult = symbolTable->GetTypeByName(u"byte");
            if (byteTypeResult.Error())
            {
                SetErrorId(byteTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* byteType = byteTypeResult.Value();
            expression.Reset(new BoundTypeExpression(byteNode.GetSpan(), byteType));
        }
        public override void Visit(ShortNode& shortNode)
        {
            Result<TypeSymbol*> shortTypeResult = symbolTable->GetTypeByName(u"short");
            if (shortTypeResult.Error())
            {
                SetErrorId(shortTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* shortType = shortTypeResult.Value();
            expression.Reset(new BoundTypeExpression(shortNode.GetSpan(), shortType));
        }
        public override void Visit(UShortNode& ushortNode)
        {
            Result<TypeSymbol*> ushortTypeResult = symbolTable->GetTypeByName(u"ushort");
            if (ushortTypeResult.Error())
            {
                SetErrorId(ushortTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* ushortType = ushortTypeResult.Value();
            expression.Reset(new BoundTypeExpression(ushortNode.GetSpan(), ushortType));
        }
        public override void Visit(IntNode& intNode)
        {
            Result<TypeSymbol*> intTypeResult = symbolTable->GetTypeByName(u"int");
            if (intTypeResult.Error())
            {
                SetErrorId(intTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* intType = intTypeResult.Value();
            expression.Reset(new BoundTypeExpression(intNode.GetSpan(), intType));
        }
        public override void Visit(UIntNode& uintNode)
        {
            Result<TypeSymbol*> uintTypeResult = symbolTable->GetTypeByName(u"uint");
            if (uintTypeResult.Error())
            {
                SetErrorId(uintTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* uintType = uintTypeResult.Value();
            expression.Reset(new BoundTypeExpression(uintNode.GetSpan(), uintType));
        }
        public override void Visit(LongNode& longNode)
        {
            Result<TypeSymbol*> longTypeResult = symbolTable->GetTypeByName(u"long");
            if (longTypeResult.Error())
            {
                SetErrorId(longTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* longType = longTypeResult.Value();
            expression.Reset(new BoundTypeExpression(longNode.GetSpan(), longType));
        }
        public override void Visit(ULongNode& ulongNode)
        {
            Result<TypeSymbol*> ulongTypeResult = symbolTable->GetTypeByName(u"ulong");
            if (ulongTypeResult.Error())
            {
                SetErrorId(ulongTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* ulongType = ulongTypeResult.Value();
            expression.Reset(new BoundTypeExpression(ulongNode.GetSpan(), ulongType));
        }
        public override void Visit(FloatNode& floatNode)
        {
            Result<TypeSymbol*> floatTypeResult = symbolTable->GetTypeByName(u"float");
            if (floatTypeResult.Error())
            {
                SetErrorId(floatTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* floatType = floatTypeResult.Value();
            expression.Reset(new BoundTypeExpression(floatNode.GetSpan(), floatType));
        }
        public override void Visit(DoubleNode& doubleNode)
        {
            Result<TypeSymbol*> doubleTypeResult = symbolTable->GetTypeByName(u"double");
            if (doubleTypeResult.Error())
            {
                SetErrorId(doubleTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* doubleType = doubleTypeResult.Value();
            expression.Reset(new BoundTypeExpression(doubleNode.GetSpan(), doubleType));
        }
        public override void Visit(CharNode& charNode)
        {
            Result<TypeSymbol*> charTypeResult = symbolTable->GetTypeByName(u"char");
            if (charTypeResult.Error())
            {
                SetErrorId(charTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* charType = charTypeResult.Value();
            expression.Reset(new BoundTypeExpression(charNode.GetSpan(), charType));
        }
        public override void Visit(WCharNode& wcharNode)
        {
            Result<TypeSymbol*> wcharTypeResult = symbolTable->GetTypeByName(u"wchar");
            if (wcharTypeResult.Error())
            {
                SetErrorId(wcharTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* wcharType = wcharTypeResult.Value();
            expression.Reset(new BoundTypeExpression(wcharNode.GetSpan(), wcharType));
        }
        public override void Visit(UCharNode& ucharNode)
        {
            Result<TypeSymbol*> ucharTypeResult = symbolTable->GetTypeByName(u"uchar");
            if (ucharTypeResult.Error())
            {
                SetErrorId(ucharTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* ucharType = ucharTypeResult.Value();
            expression.Reset(new BoundTypeExpression(ucharNode.GetSpan(), ucharType));
        }
        public override void Visit(VoidNode& voidNode)
        {
            Result<TypeSymbol*> voidTypeResult = symbolTable->GetTypeByName(u"void");
            if (voidTypeResult.Error())
            {
                SetErrorId(voidTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* voidType = voidTypeResult.Value();
            expression.Reset(new BoundTypeExpression(voidNode.GetSpan(), voidType));
        }
        public override void Visit(BooleanLiteralNode& booleanLiteralNode)
        {
            Result<TypeSymbol*> boolTypeResult = symbolTable->GetTypeByName(u"bool");
            if (boolTypeResult.Error())
            {
                SetErrorId(boolTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* boolType = boolTypeResult.Value();
            expression.Reset(new BoundLiteral(booleanLiteralNode.GetSpan(), UniquePtr<Value>(new BoolValue(booleanLiteralNode.GetSpan(), booleanLiteralNode.Value())),
                boolType));
        }
        public override void Visit(SByteLiteralNode& sbyteLiteralNode)
        {
            Result<TypeSymbol*> sbyteTypeResult = symbolTable->GetTypeByName(u"sbyte");
            if (sbyteTypeResult.Error())
            {
                SetErrorId(sbyteTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* sbyteType = sbyteTypeResult.Value();
            expression.Reset(new BoundLiteral(sbyteLiteralNode.GetSpan(), UniquePtr<Value>(new SByteValue(sbyteLiteralNode.GetSpan(), sbyteLiteralNode.Value())), sbyteType));
        }
        public override void Visit(ByteLiteralNode& byteLiteralNode)
        {
            Result<TypeSymbol*> byteTypeResult = symbolTable->GetTypeByName(u"byte");
            if (byteTypeResult.Error())
            {
                SetErrorId(byteTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* byteType = byteTypeResult.Value();
            expression.Reset(new BoundLiteral(byteLiteralNode.GetSpan(), UniquePtr<Value>(new ByteValue(byteLiteralNode.GetSpan(), byteLiteralNode.Value())), byteType));
        }
        public override void Visit(ShortLiteralNode& shortLiteralNode)
        {
            Result<TypeSymbol*> shortTypeResult = symbolTable->GetTypeByName(u"short");
            if (shortTypeResult.Error())
            {
                SetErrorId(shortTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* shortType = shortTypeResult.Value();
            expression.Reset(new BoundLiteral(shortLiteralNode.GetSpan(), UniquePtr<Value>(new ShortValue(shortLiteralNode.GetSpan(), shortLiteralNode.Value())), shortType));
        }
        public override void Visit(UShortLiteralNode& ushortLiteralNode)
        {
            Result<TypeSymbol*> ushortTypeResult = symbolTable->GetTypeByName(u"ushort");
            if (ushortTypeResult.Error())
            {
                SetErrorId(ushortTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* ushortType = ushortTypeResult.Value();
            expression.Reset(new BoundLiteral(ushortLiteralNode.GetSpan(), UniquePtr<Value>(new UShortValue(ushortLiteralNode.GetSpan(), ushortLiteralNode.Value())),
                ushortType));
        }
        public override void Visit(IntLiteralNode& intLiteralNode)
        {
            Result<TypeSymbol*> intTypeResult = symbolTable->GetTypeByName(u"int");
            if (intTypeResult.Error())
            {
                SetErrorId(intTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* intType = intTypeResult.Value();
            expression.Reset(new BoundLiteral(intLiteralNode.GetSpan(), UniquePtr<Value>(new IntValue(intLiteralNode.GetSpan(), intLiteralNode.Value())), intType));
        }
        public override void Visit(UIntLiteralNode& uintLiteralNode)
        {
            Result<TypeSymbol*> uintTypeResult = symbolTable->GetTypeByName(u"uint");
            if (uintTypeResult.Error())
            {
                SetErrorId(uintTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* uintType = uintTypeResult.Value();
            expression.Reset(new BoundLiteral(uintLiteralNode.GetSpan(), UniquePtr<Value>(new UIntValue(uintLiteralNode.GetSpan(), uintLiteralNode.Value())), uintType));
        }
        public override void Visit(LongLiteralNode& longLiteralNode)
        {
            Result<TypeSymbol*> longTypeResult = symbolTable->GetTypeByName(u"long");
            if (longTypeResult.Error())
            {
                SetErrorId(longTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* longType = longTypeResult.Value();
            expression.Reset(new BoundLiteral(longLiteralNode.GetSpan(), UniquePtr<Value>(new LongValue(longLiteralNode.GetSpan(), longLiteralNode.Value())), longType));
        }
        public override void Visit(ULongLiteralNode& ulongLiteralNode)
        {
            Result<TypeSymbol*> ulongTypeResult = symbolTable->GetTypeByName(u"ulong");
            if (ulongTypeResult.Error())
            {
                SetErrorId(ulongTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* ulongType = ulongTypeResult.Value();
            expression.Reset(new BoundLiteral(ulongLiteralNode.GetSpan(), UniquePtr<Value>(new ULongValue(ulongLiteralNode.GetSpan(), ulongLiteralNode.Value())), ulongType));
        }
        public override void Visit(FloatLiteralNode& floatLiteralNode)
        {
            Result<TypeSymbol*> floatTypeResult = symbolTable->GetTypeByName(u"float");
            if (floatTypeResult.Error())
            {
                SetErrorId(floatTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* floatType = floatTypeResult.Value();
            expression.Reset(new BoundLiteral(floatLiteralNode.GetSpan(), UniquePtr<Value>(new FloatValue(floatLiteralNode.GetSpan(), floatLiteralNode.Value())), floatType));
        }
        public override void Visit(DoubleLiteralNode& doubleLiteralNode)
        {
            Result<TypeSymbol*> doubleTypeResult = symbolTable->GetTypeByName(u"double");
            if (doubleTypeResult.Error())
            {
                SetErrorId(doubleTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* doubleType = doubleTypeResult.Value();
            expression.Reset(new BoundLiteral(doubleLiteralNode.GetSpan(), UniquePtr<Value>(new DoubleValue(doubleLiteralNode.GetSpan(), doubleLiteralNode.Value())),
                doubleType));
        }
        public override void Visit(CharLiteralNode& charLiteralNode)
        {
            Result<TypeSymbol*> charTypeResult = symbolTable->GetTypeByName(u"char");
            if (charTypeResult.Error())
            {
                SetErrorId(charTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* charType = charTypeResult.Value();
            expression.Reset(new BoundLiteral(charLiteralNode.GetSpan(), UniquePtr<Value>(new CharValue(charLiteralNode.GetSpan(), charLiteralNode.Value())), charType));
        }
        public override void Visit(WCharLiteralNode& wcharLiteralNode)
        {
            Result<TypeSymbol*> wcharTypeResult = symbolTable->GetTypeByName(u"wchar");
            if (wcharTypeResult.Error())
            {
                SetErrorId(wcharTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* wcharType = wcharTypeResult.Value();
            expression.Reset(new BoundLiteral(wcharLiteralNode.GetSpan(), UniquePtr<Value>(new WCharValue(wcharLiteralNode.GetSpan(), wcharLiteralNode.Value())), wcharType));
        }
        public override void Visit(UCharLiteralNode& ucharLiteralNode)
        {
            Result<TypeSymbol*> ucharTypeResult = symbolTable->GetTypeByName(u"uchar");
            if (ucharTypeResult.Error())
            {
                SetErrorId(ucharTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* ucharType = ucharTypeResult.Value();
            expression.Reset(new BoundLiteral(ucharLiteralNode.GetSpan(), UniquePtr<Value>(new UCharValue(ucharLiteralNode.GetSpan(), ucharLiteralNode.Value())), ucharType));
        }
        public override void Visit(StringLiteralNode& stringLiteralNode)
        {
            Result<TypeSymbol*> charTypeResult = symbolTable->GetTypeByName(u"char");
            if (charTypeResult.Error())
            {
                SetErrorId(charTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* charType = charTypeResult.Value();
            Result<TypeSymbol*> constCharTypeResult = charType->AddConst(context);
            if (constCharTypeResult.Error())
            {
                SetErrorId(constCharTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* constCharType = constCharTypeResult.Value();
            Result<TypeSymbol*> constCharPtrTypeResult = constCharType->AddPointer(context);
            if (constCharPtrTypeResult.Error())
            {
                SetErrorId(constCharPtrTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* constCharPtrType = constCharPtrTypeResult.Value();
            expression.Reset(new BoundLiteral(stringLiteralNode.GetSpan(), UniquePtr<Value>(new StringValue(stringLiteralNode.GetSpan(),
                boundCompileUnit->Install(stringLiteralNode.Value()), stringLiteralNode.Value())), constCharPtrType));
        }
        public override void Visit(WStringLiteralNode& wstringLiteralNode)
        {
            Result<TypeSymbol*> wcharTypeResult = symbolTable->GetTypeByName(u"wchar");
            if (wcharTypeResult.Error())
            {
                SetErrorId(wcharTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* wcharType = wcharTypeResult.Value();
            Result<TypeSymbol*> constWCharTypeResult = wcharType->AddConst(context);
            if (constWCharTypeResult.Error())
            {
                SetErrorId(constWCharTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* constWCharType = constWCharTypeResult.Value();
            Result<TypeSymbol*> constWCharPtrTypeResult = constWCharType->AddPointer(context);
            if (constWCharPtrTypeResult.Error())
            {
                SetErrorId(constWCharPtrTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* constWCharPtrType = constWCharPtrTypeResult.Value();
            expression.Reset(new BoundLiteral(wstringLiteralNode.GetSpan(), UniquePtr<Value>(new WStringValue(wstringLiteralNode.GetSpan(),
                boundCompileUnit->Install(wstringLiteralNode.Value()), wstringLiteralNode.Value())), constWCharPtrType));
        }
        public override void Visit(UStringLiteralNode& ustringLiteralNode)
        {
            Result<TypeSymbol*> ucharTypeResult = symbolTable->GetTypeByName(u"uchar");
            if (ucharTypeResult.Error())
            {
                SetErrorId(ucharTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* ucharType = ucharTypeResult.Value();
            Result<TypeSymbol*> constUCharTypeResult = ucharType->AddConst(context);
            if (constUCharTypeResult.Error())
            {
                SetErrorId(constUCharTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* constUCharType = constUCharTypeResult.Value();
            Result<TypeSymbol*> constUCharPtrTypeResult = constUCharType->AddPointer(context);
            if (constUCharPtrTypeResult.Error())
            {
                SetErrorId(constUCharPtrTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* constUCharPtrType = constUCharPtrTypeResult.Value();
            expression.Reset(new BoundLiteral(ustringLiteralNode.GetSpan(), UniquePtr<Value>(new UStringValue(ustringLiteralNode.GetSpan(),
                boundCompileUnit->Install(ustringLiteralNode.Value()), ustringLiteralNode.Value())), constUCharPtrType));
        }
        public override void Visit(NullLiteralNode& nullLiteralNode)
        {
            Result<TypeSymbol*> nullPtrTypeResult = symbolTable->GetTypeByName(u"@nullptr_type");
            if (nullPtrTypeResult.Error())
            {
                SetErrorId(nullPtrTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* nullPtrType = nullPtrTypeResult.Value();
            expression.Reset(new BoundLiteral(nullLiteralNode.GetSpan(), UniquePtr<Value>(new NullValue(nullLiteralNode.GetSpan())), nullPtrType));
        }
        public override void Visit(IdentifierNode& identifierNode)
        {
            Result<Symbol*> symbolResult = containerScope->Lookup(identifierNode.Str(), ScopeLookup.this_and_base_and_parent, context);
            if (symbolResult.Error())
            {
                SetErrorId(symbolResult.GetErrorId());
                return;
            }
            Symbol* symbol = symbolResult.Value();
            if (symbol == null)
            {
                int n = cast<int>(boundCompileUnit->FileScopes().Count());
                for (int i = 0; i < n; ++i)
                {
                    FileScope* fileScope = boundCompileUnit->FileScopes()[i].Get();
                    symbolResult = fileScope->Lookup(identifierNode.Str(), context);
                    if (symbolResult.Error())
                    {
                        SetErrorId(symbolResult.GetErrorId());
                        return;
                    }
                    symbol = symbolResult.Value();
                    if (symbol != null) break;
                }
            }
            if (symbol != null)
            {
                BindSymbol(symbol, &identifierNode);
            }
            else
            {
                Result<string> symbolNameResult = ToUtf8(identifierNode.Str());
                if (symbolNameResult.Error())
                {
                    SetErrorId(symbolNameResult.GetErrorId());
                    return;
                }
                string symbolName = Rvalue(symbolNameResult.Value());
                int errorId = MakeError("symbol '" + symbolName + "' not found", identifierNode.GetFullSpan());
                SetErrorId(errorId);
                return;
            }
        }
        public override void Visit(TemplateIdNode& templateIdNode)
        {
            int arity = cast<int>(templateIdNode.TemplateArguments().Count());
            templateIdNode.Primary()->Accept(*this);
            if (Error()) return;
            if (expression->IsBoundTypeExpression())
            {
                TypeSymbol* typeSymbol = expression->Type();
                if (typeSymbol->IsClassGroupSymbol())
                {
                    ClassGroupSymbol* classGroup = cast<ClassGroupSymbol*>(typeSymbol);
                    typeSymbol = classGroup->GetClass(arity);
                    if (typeSymbol == null)
                    {
                        Result<string> classGroupFullNameResult = ToUtf8(classGroup->FullName());
                        if (classGroupFullNameResult.Error())
                        {
                            SetErrorId(classGroupFullNameResult.GetErrorId());
                            return;
                        }
                        string classGroupFullName = Rvalue(classGroupFullNameResult.Value());
                        int errorId = MakeError("class group '" + classGroupFullName + "' does not have a class template with arity " + ToString(arity),
                            templateIdNode.GetFullSpan());
                        SetErrorId(errorId);
                        return;
                    }
                }
                expression.Reset(new BoundTypeExpression(typeSymbol->Span(), typeSymbol));
            }
            List<TypeSymbol*> templateArgumentTypes;
            int n = arity;
            for (int i = 0; i < n; ++i)
            {
                Node* templateArgumentNode = templateIdNode.TemplateArguments()[i];
                Result<TypeSymbol*> typeResult = ResolveType(templateArgumentNode, boundCompileUnit, containerScope);
                if (typeResult.Error())
                {
                    SetErrorId(typeResult.GetErrorId());
                    return;
                }
                TypeSymbol* type = typeResult.Value();
                templateArgumentTypes.Add(type);
            }
            if (expression->IsBoundFunctionGroupExpression())
            {
                BoundFunctionGroupExpression* bfge = cast<BoundFunctionGroupExpression*>(expression.Get());
                bfge->SetTemplateArgumentTypes(Rvalue(templateArgumentTypes));
            }
            else if (expression->IsBoundMemberExpression())
            {
                BoundMemberExpression* bme = cast<BoundMemberExpression*>(expression.Get());
                if (bme->Member()->IsBoundFunctionGroupExpression())
                {
                    BoundFunctionGroupExpression* bfge = cast<BoundFunctionGroupExpression*>(bme->Member());
                    bfge->SetTemplateArgumentTypes(Rvalue(templateArgumentTypes));
                }
                else if (bme->Member()->IsBoundTypeExpression())
                {
                    TypeSymbol* typeSymbol = bme->Member()->Type();
                    if (typeSymbol->IsClassTypeSymbol())
                    {
                        ClassTypeSymbol* classTypeSymbol = cast<ClassTypeSymbol*>(typeSymbol);
                        if (classTypeSymbol->IsClassTemplate())
                        {
                            int m = cast<int>(classTypeSymbol->TemplateParameters().Count());
                            if (n < m)
                            {
                                Result<bool> result = boundCompileUnit->GetClassTemplateRepository()->ResolveDefaultTemplateArguments(templateArgumentTypes, classTypeSymbol,
                                    containerScope, &templateIdNode);
                                if (result.Error())
                                {
                                    SetErrorId(result.GetErrorId());
                                    return;
                                }
                            }
                            ClassTemplateSpecializationSymbol* classTemplateSpecialization = symbolTable->MakeClassTemplateSpecialization(classTypeSymbol, templateArgumentTypes);
                            if (!classTemplateSpecialization->IsBound())
                            {
                                Result<bool> result = boundCompileUnit->GetClassTemplateRepository()->BindClassTemplateSpecialization(
                                    classTemplateSpecialization, containerScope, &templateIdNode);
                                if (result.Error())
                                {
                                    SetErrorId(result.GetErrorId());
                                    return;
                                }
                            }
                            expression.Reset(new BoundTypeExpression(templateIdNode.GetSpan(), classTemplateSpecialization));
                        }
                    }
                }
                else
                {
                    int errorId = MakeError("function group or class group expected", templateIdNode.GetFullSpan());
                    SetErrorId(errorId);
                    return;
                }
            }
            else if (expression->IsBoundTypeExpression())
            {
                TypeSymbol* typeSymbol = expression->Type();
                if (typeSymbol->IsClassTypeSymbol())
                {
                    ClassTypeSymbol* classTypeSymbol = cast<ClassTypeSymbol*>(typeSymbol);
                    if (classTypeSymbol->IsClassTemplate())
                    {
                        int m = cast<int>(classTypeSymbol->TemplateParameters().Count());
                        if (n < m)
                        {
                            Result<bool> result = boundCompileUnit->GetClassTemplateRepository()->ResolveDefaultTemplateArguments(templateArgumentTypes, classTypeSymbol,
                                containerScope, &templateIdNode);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                        }
                        ClassTemplateSpecializationSymbol* classTemplateSpecialization = symbolTable->MakeClassTemplateSpecialization(classTypeSymbol, templateArgumentTypes);
                        if (!classTemplateSpecialization->IsBound())
                        {
                            Result<bool> result = boundCompileUnit->GetClassTemplateRepository()->BindClassTemplateSpecialization(
                                classTemplateSpecialization, containerScope, &templateIdNode);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                        }
                        expression.Reset(new BoundTypeExpression(templateIdNode.GetSpan(), classTemplateSpecialization));
                    }
                }
            }
            else
            {
                int errorId = MakeError("function group or class group expected", templateIdNode.GetFullSpan());
                SetErrorId(errorId);
                return;
            }
        }
        public override void Visit(ParameterNode& parameterNode)
        {
            if (parameterNode.Id() == null)
            {
                int errorId = MakeError("parameter not named", parameterNode.GetFullSpan());
                SetErrorId(errorId);
                return;
            }
            Result<Symbol*> symbolResult = containerScope->Lookup(parameterNode.Id()->Str(), ScopeLookup.this_and_base_and_parent, context);
            if (symbolResult.Error())
            {
                SetErrorId(symbolResult.GetErrorId());
                return;
            }
            Symbol* symbol = symbolResult.Value();
            if (symbol == null)
            {
                for (const UniquePtr<FileScope>& fileScope : boundCompileUnit->FileScopes())
                {
                    symbolResult = fileScope->Lookup(parameterNode.Id()->Str(), context);
                    if (symbolResult.Error())
                    {
                        SetErrorId(symbolResult.GetErrorId());
                        return;
                    }
                    symbol = symbolResult.Value();
                    if (symbol != null) break;
                }
            }
            if (symbol != null)
            {
                if (symbol->IsParameterSymbol())
                {
                    ParameterSymbol* parameterSymbol = cast<ParameterSymbol*>(symbol);
                    expression.Reset(new BoundParameter(parameterNode.GetSpan(), parameterSymbol));
                }
                else
                {
                    Result<string> symbolNameResult = ToUtf8(parameterNode.Id()->Str());
                    if (symbolNameResult.Error())
                    {
                        SetErrorId(symbolNameResult.GetErrorId());
                        return;
                    }
                    string symbolName = Rvalue(symbolNameResult.Value());
                    int errorId = MakeError("symbol '" + symbolName + "' does not denote a parameter", parameterNode.GetFullSpan());
                    SetErrorId(errorId);
                    return;
                }
            }
            else
            {
                Result<string> symbolNameResult = ToUtf8(parameterNode.Id()->Str());
                if (symbolNameResult.Error())
                {
                    SetErrorId(symbolNameResult.GetErrorId());
                    return;
                }
                string symbolName = Rvalue(symbolNameResult.Value());
                int errorId = MakeError("parameter symbol '" + symbolName + "' not found", parameterNode.GetFullSpan());
                SetErrorId(errorId);
                return;
            }
        }
        public override void Visit(DotNode& dotNode)
        {
            Result<UniquePtr<BoundExpression>> subjectResult = BindExpression(dotNode.Subject(), boundCompileUnit, boundFunction, containerScope, statementBinder,
                false, true, true);
            if (subjectResult.Error())
            {
                SetErrorId(subjectResult.GetErrorId());
                return;
            }
            expression = Rvalue(subjectResult.Value());
            if (expression->IsBoundTypeExpression())
            {
                TypeSymbol* typeSymbol = expression->Type();
                if (typeSymbol->IsClassGroupSymbol())
                {
                    ClassGroupSymbol* classGroupSymbol = cast<ClassGroupSymbol*>(typeSymbol);
                    typeSymbol = classGroupSymbol->GetClass(0);
                    if (typeSymbol == null)
                    {
                        Result<string> classGroupFullNameResult = ToUtf8(classGroupSymbol->FullName());
                        if (classGroupFullNameResult.Error())
                        {
                            SetErrorId(classGroupFullNameResult.GetErrorId());
                            return;
                        }
                        string classGroupFullName = Rvalue(classGroupFullNameResult.Value());
                        int errorId = MakeError("nontemplate class not found from class group '" + classGroupFullName + "'", dotNode.GetFullSpan(), classGroupSymbol->FullSpan());
                        SetErrorId(errorId);
                        return;
                    }
                    else
                    {
                        expression.Reset(new BoundTypeExpression(dotNode.GetSpan(), typeSymbol));
                    }
                }
            }
            if (expression->IsBoundNamespaceExpression())
            {
                BoundNamespaceExpression* bns = cast<BoundNamespaceExpression*>(expression.Get());
                ContainerScope* nsScope = bns->Ns()->GetContainerScope();
                Result<Symbol*> symbolResult = nsScope->Lookup(dotNode.MemberId()->Str(), ScopeLookup.this_, context);
                if (symbolResult.Error())
                {
                    SetErrorId(symbolResult.GetErrorId());
                    return;
                }
                Symbol* symbol = symbolResult.Value();
                if (symbol != null)
                {
                    BindSymbol(symbol, dotNode.MemberId());
                    if (Error()) return;
                    if (expression->IsBoundFunctionGroupExpression())
                    {
                        BoundFunctionGroupExpression* bfe = cast<BoundFunctionGroupExpression*>(expression.Get());
                        bfe->SetScopeQualified();
                        bfe->SetQualifiedScope(nsScope);
                    }
                }
                else
                {
                    Result<string> symbolNameResult = ToUtf8(dotNode.MemberId()->Str());
                    if (symbolNameResult.Error())
                    {
                        SetErrorId(symbolNameResult.GetErrorId());
                        return;
                    }
                    string symbolName = Rvalue(symbolNameResult.Value());
                    Result<string> namespaceFullNameResult = ToUtf8(bns->Ns()->FullName());
                    if (namespaceFullNameResult.Error())
                    {
                        SetErrorId(namespaceFullNameResult.GetErrorId());
                        return;
                    }
                    string namespaceFullName = Rvalue(namespaceFullNameResult.Value());
                    int errorId = MakeError("symbol '" + symbolName + "' not found from namespace '" + namespaceFullName + "'", dotNode.MemberId()->GetFullSpan());
                    SetErrorId(errorId);
                    return;
                }
            }
            else
            {
                Result<TypeSymbol*> plainTypeResult = expression->Type()->PlainType(context);
                if (plainTypeResult.Error())
                {
                    SetErrorId(plainTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* type = plainTypeResult.Value();
                if (type->IsClassDelegateTypeSymbol())
                {
                    ClassDelegateTypeSymbol* classDelegateType = cast<ClassDelegateTypeSymbol*>(type);
                    type = classDelegateType->ObjectDelegatePairType();
                }
                if (type->IsClassTypeSymbol())
                {
                    ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type);
                    ContainerScope* scope = classType->GetContainerScope();
                    Result<Symbol*> symbolResult = scope->Lookup(dotNode.MemberId()->Str(), ScopeLookup.this_and_base, context);
                    if (symbolResult.Error())
                    {
                        SetErrorId(symbolResult.GetErrorId());
                        return;
                    }
                    Symbol* symbol = symbolResult.Value();
                    if (symbol != null)
                    {
                        UniquePtr<BoundExpression> classPtr;
                        BoundExpression* plainClassPtr = expression.Get();
                        if (expression->Type()->IsClassTypeSymbol())
                        {
                            Result<TypeSymbol*> ptrTypeResult = expression->Type()->AddPointer(context);
                            if (ptrTypeResult.Error())
                            {
                                SetErrorId(ptrTypeResult.GetErrorId());
                                return;
                            }
                            TypeSymbol* type = ptrTypeResult.Value();
                            classPtr.Reset(new BoundAddressOfExpression(dotNode.MemberId()->GetSpan(), UniquePtr<BoundExpression>(expression.Release()), type));
                        }
                        else if (expression->Type()->IsReferenceType())
                        {
                            Result<TypeSymbol*> nonRefTypeResult = expression->Type()->RemoveReference(context);
                            if (nonRefTypeResult.Error())
                            {
                                SetErrorId(nonRefTypeResult.GetErrorId());
                                return;
                            }
                            TypeSymbol* nonRefType = nonRefTypeResult.Value();
                            Result<TypeSymbol*> ptrTypeResult = nonRefType->AddPointer(context);
                            if (ptrTypeResult.Error())
                            {
                                SetErrorId(ptrTypeResult.GetErrorId());
                                return;
                            }
                            TypeSymbol* type = ptrTypeResult.Value();
                            classPtr.Reset(new BoundReferenceToPointerExpression(dotNode.MemberId()->GetSpan(), UniquePtr<BoundExpression>(expression.Release()), type));
                        }
                        else
                        {
                            classPtr.Reset(expression.Release());
                        }
                        BindSymbol(symbol, dotNode.MemberId());
                        if (Error()) return;
                        if (expression->IsBoundFunctionGroupExpression())
                        {
                            BoundFunctionGroupExpression* bfg = cast<BoundFunctionGroupExpression*>(expression.Get());
                            if (!classPtr->GetFlag(BoundExpressionFlags.argIsExplicitThisOrBasePtr))
                            {
                                Symbol* parent = symbol->Parent();
                                #assert(parent->IsClassTypeSymbol());
                                ClassTypeSymbol* owner = cast<ClassTypeSymbol*>(parent);
                                if (classType->HasBaseClass(owner))
                                {
                                    if (classPtr->Type()->IsConstType())
                                    {
                                        ArgumentMatch argumentMatch;
                                        Result<TypeSymbol*> constTypeResult = classType->AddConst(context);
                                        if (constTypeResult.Error())
                                        {
                                            SetErrorId(constTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* constType = constTypeResult.Value();
                                        Result<TypeSymbol*> ptrTypeResult = constType->AddPointer(context);
                                        if (ptrTypeResult.Error())
                                        {
                                            SetErrorId(ptrTypeResult.GetErrorId());
                                            return;
                                        }
                                        Result<TypeSymbol*> ownerConstTypeResult = owner->AddConst(context);
                                        if (ownerConstTypeResult.Error())
                                        {
                                            SetErrorId(ownerConstTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ownerConstType = ownerConstTypeResult.Value();
                                        Result<TypeSymbol*> ownerPtrTypeResult = ownerConstType->AddPointer(context);
                                        if (ownerPtrTypeResult.Error())
                                        {
                                            SetErrorId(ownerPtrTypeResult.GetErrorId());
                                            return;
                                        }
                                        Result<FunctionSymbol*> conversionResult = GetConversion(
                                            ptrTypeResult.Value(), ownerPtrTypeResult.Value(),
                                            containerScope, boundCompileUnit, boundFunction, argumentMatch, &dotNode);
                                        if (conversionResult.Error())
                                        {
                                            SetErrorId(conversionResult.GetErrorId());
                                            return;
                                        }
                                        FunctionSymbol* conversionFn = conversionResult.Value();
                                        classPtr.Reset(new BoundConversion(dotNode.GetSpan(), UniquePtr<BoundExpression>(classPtr.Release()), conversionFn));
                                    }
                                    else
                                    {
                                        ArgumentMatch argumentMatch;
                                        Result<TypeSymbol*> classPtrTypeResult = classType->AddPointer(context);
                                        if (classPtrTypeResult.Error())
                                        {
                                            SetErrorId(classPtrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* classPtrType = classPtrTypeResult.Value();
                                        Result<TypeSymbol*> ownerPtrTypeResult = owner->AddPointer(context);
                                        if (ownerPtrTypeResult.Error())
                                        {
                                            SetErrorId(ownerPtrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ownerPtrType = ownerPtrTypeResult.Value();
                                        Result<FunctionSymbol*> conversionResult = GetConversion(classPtrType, ownerPtrType,
                                            containerScope, boundCompileUnit, boundFunction, argumentMatch, &dotNode);
                                        if (conversionResult.Error())
                                        {
                                            SetErrorId(conversionResult.GetErrorId());
                                            return;
                                        }
                                        FunctionSymbol* conversionFn = conversionResult.Value();
                                        classPtr.Reset(new BoundConversion(dotNode.GetSpan(), UniquePtr<BoundExpression>(classPtr.Release()), conversionFn));
                                    }
                                }
                            }
                            if (plainClassPtr->IsBoundTypeExpression())
                            {
                                BoundTypeExpression* bte = cast<BoundTypeExpression*>(plainClassPtr);
                                bfg->SetScopeQualified();
                                bfg->SetQualifiedScope(bte->Type()->GetContainerScope());
                            }
                            MemberExpressionTypeSymbol* memberExpressionTypeSymbol = new MemberExpressionTypeSymbol(dotNode.GetSpan(), expression->Type()->Name());
                            BoundMemberExpression* bme = new BoundMemberExpression(dotNode.GetSpan(), UniquePtr<BoundExpression>(classPtr.Release()), Rvalue(expression),
                                memberExpressionTypeSymbol);
                            memberExpressionTypeSymbol->SetBoundMemberExpression(bme);
                            expression.Reset(bme);
                        }
                        else if (expression->IsBoundMemberVariable())
                        {
                            BoundMemberVariable* bmv = cast<BoundMemberVariable*>(expression.Get());
                            if (!bmv->GetMemberVariableSymbol()->IsStatic())
                            {
                                Symbol* parent = symbol->Parent();
                                #assert(parent->IsClassTypeSymbol());
                                ClassTypeSymbol* owner = cast<ClassTypeSymbol*>(parent);
                                if (classType->HasBaseClass(owner))
                                {
                                    if (classPtr->Type()->IsConstType())
                                    {
                                        ArgumentMatch argumentMatch;
                                        Result<TypeSymbol*> constTypeResult = classType->AddConst(context);
                                        if (constTypeResult.Error())
                                        {
                                            SetErrorId(constTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* constType = constTypeResult.Value();
                                        Result<TypeSymbol*> ptrTypeResult = constType->AddPointer(context);
                                        if (ptrTypeResult.Error())
                                        {
                                            SetErrorId(ptrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ptrType = ptrTypeResult.Value();
                                        Result<TypeSymbol*> ownerConstTypeResult = owner->AddConst(context);
                                        if (ownerConstTypeResult.Error())
                                        {
                                            SetErrorId(ownerConstTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ownerConstType = ownerConstTypeResult.Value();
                                        Result<TypeSymbol*> ownerPtrTypeResult = ownerConstType->AddPointer(context);
                                        if (ownerPtrTypeResult.Error())
                                        {
                                            SetErrorId(ownerPtrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ownerPtrType = ownerPtrTypeResult.Value();
                                        Result<FunctionSymbol*> conversionResult = GetConversion(
                                            ptrType, ownerPtrType,
                                            containerScope, boundCompileUnit, boundFunction, argumentMatch, &dotNode);
                                        if (conversionResult.Error())
                                        {
                                            SetErrorId(conversionResult.GetErrorId());
                                            return;
                                        }
                                        FunctionSymbol* conversionFn = conversionResult.Value();
                                        classPtr.Reset(new BoundConversion(dotNode.GetSpan(), UniquePtr<BoundExpression>(classPtr.Release()), conversionFn));
                                    }
                                    else
                                    {
                                        ArgumentMatch argumentMatch;
                                        Result<TypeSymbol*> classPtrTypeResult = classType->AddPointer(context);
                                        if (classPtrTypeResult.Error())
                                        {
                                            SetErrorId(classPtrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* classPtrType = classPtrTypeResult.Value();
                                        Result<TypeSymbol*> ownerPtrTypeResult = owner->AddPointer(context);
                                        if (ownerPtrTypeResult.Error())
                                        {
                                            SetErrorId(ownerPtrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ownerPtrType = ownerPtrTypeResult.Value();
                                        Result<FunctionSymbol*> conversionResult = GetConversion(classPtrType, ownerPtrType,
                                            containerScope, boundCompileUnit, boundFunction, argumentMatch, &dotNode);
                                        FunctionSymbol* conversionFn = conversionResult.Value();
                                        classPtr.Reset(new BoundConversion(dotNode.GetSpan(), UniquePtr<BoundExpression>(classPtr.Release()), conversionFn));
                                    }
                                }
                                bmv->SetClassPtr(UniquePtr<BoundExpression>(classPtr.Release()));
                            }
                        }
                        else if (!expression->IsBoundTypeExpression() && !expression->IsBoundConstant())
                        {
                            Result<string> symbolNameResult = ToUtf8(dotNode.MemberId()->Str());
                            if (symbolNameResult.Error())
                            {
                                SetErrorId(symbolNameResult.GetErrorId());
                                return;
                            }
                            string symbolName = Rvalue(symbolNameResult.Value());
                            int errorId = MakeError("symbol '" + symbolName + "' does not denote a function group, member variable or type", dotNode.MemberId()->GetFullSpan());
                            SetErrorId(errorId);
                            return;
                        }
                    }
                    else
                    {
                        Result<string> symbolNameResult = ToUtf8(dotNode.MemberId()->Str());
                        if (symbolNameResult.Error())
                        {
                            SetErrorId(symbolNameResult.GetErrorId());
                            return;
                        }
                        string symbolName = Rvalue(symbolNameResult.Value());
                        Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                        if (classTypeFullNameResult.Error())
                        {
                            SetErrorId(classTypeFullNameResult.GetErrorId());
                            return;
                        }
                        string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                        int errorId = MakeError("symbol '" + symbolName + "' not found from class '" + classTypeFullName + "'", dotNode.MemberId()->GetFullSpan());
                        SetErrorId(errorId);
                        return;
                    }
                }
                else if (type->IsInterfaceTypeSymbol())
                {
                    // todo
                }
                else if (type->IsEnumTypeSymbol())
                {
                    EnumTypeSymbol* enumType = cast<EnumTypeSymbol*>(type);
                    ContainerScope* scope = enumType->GetContainerScope();
                    Result<Symbol*> symbolResult = scope->Lookup(dotNode.MemberId()->Str(), context);
                    if (symbolResult.Error())
                    {
                        SetErrorId(symbolResult.GetErrorId());
                        return;
                    }
                    Symbol* symbol = symbolResult.Value();
                    if (symbol != null)
                    {
                        BindSymbol(symbol, dotNode.MemberId());
                        if (Error()) return;
                    }
                    else
                    {
                        Result<string> symbolNameResult = ToUtf8(dotNode.MemberId()->Str());
                        if (symbolNameResult.Error())
                        {
                            SetErrorId(symbolNameResult.GetErrorId());
                            return;
                        }
                        string symbolName = Rvalue(symbolNameResult.Value());
                        Result<string> enumTypeFullNameResult = ToUtf8(enumType->FullName());
                        if (enumTypeFullNameResult.Error())
                        {
                            SetErrorId(enumTypeFullNameResult.GetErrorId());
                            return;
                        }
                        string enumTypeFullName = Rvalue(enumTypeFullNameResult.Value());
                        int errorId = MakeError("symbol '" + symbolName + "' not found from enumerated type '" + enumTypeFullName + "'", dotNode.MemberId()->GetFullSpan());
                        SetErrorId(errorId);
                        return;
                    }
                }
                else if (type->IsArrayTypeSymbol())
                {
                    ArrayTypeSymbol* arrayType = cast<ArrayTypeSymbol*>(type);
                    ContainerScope* scope = arrayType->GetContainerScope();
                    Result<Symbol*> symbolResult = scope->Lookup(dotNode.MemberId()->Str(), context);
                    if (symbolResult.Error())
                    {
                        SetErrorId(symbolResult.GetErrorId());
                        return;
                    }
                    Symbol* symbol = symbolResult.Value();
                    if (symbol != null)
                    {
                        UniquePtr<BoundExpression> receiverPtr = Rvalue(expression);
                        BindSymbol(symbol, dotNode.MemberId());
                        if (Error()) return;
                        if (expression->IsBoundFunctionGroupExpression())
                        {
                            BoundFunctionGroupExpression* bfe = cast<BoundFunctionGroupExpression*>(expression.Get());
                            bfe->SetScopeQualified();
                            bfe->SetQualifiedScope(scope);
                            bfe->SetClassPtr(Rvalue(receiverPtr));
                        }
                    }
                    else
                    {
                        Result<string> symbolNameResult = ToUtf8(dotNode.MemberId()->Str());
                        if (symbolNameResult.Error())
                        {
                            SetErrorId(symbolNameResult.GetErrorId());
                            return;
                        }
                        string symbolName = Rvalue(symbolNameResult.Value());
                        Result<string> arrayTypeFullNameResult = ToUtf8(arrayType->FullName());
                        if (arrayTypeFullNameResult.Error())
                        {
                            SetErrorId(arrayTypeFullNameResult.GetErrorId());
                            return;
                        }
                        string arrayTypeFullName = Rvalue(arrayTypeFullNameResult.Value());
                        int errorId = MakeError("symbol '" + symbolName + "' not found from array type '" + arrayTypeFullName + "'", dotNode.MemberId()->GetFullSpan());
                        SetErrorId(errorId);
                        return;
                    }
                }
                else if (type->IsCharacterPointerType() && expression->IsBoundLiteral())
                {
                    // todo
                }
                else
                {
                    int errorId = MakeError("expression does not denote a namespace, class type, interface type, array type or an enumerated type type object",
                        dotNode.GetFullSpan());
                    SetErrorId(errorId);
                    return;
                }
            }
        }
        public override void Visit(ArrowNode& arrowNode)
        {
            arrowNode.Subject()->Accept(*this);
            if (Error()) return;
            bool argIsExplicitThisOrBasePtr = expression->GetFlag(BoundExpressionFlags.argIsExplicitThisOrBasePtr);
            Result<TypeSymbol*> plainTypeResult = expression->Type()->PlainType(context);
            if (plainTypeResult.Error())
            {
                SetErrorId(plainTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* plainType = plainTypeResult.Value();
            if (expression->Type()->IsReferenceType() && plainType->IsClassTypeSymbol())
            {
                Result<TypeSymbol*> nonRefTypeResult = expression->Type()->RemoveReference(context);
                if (nonRefTypeResult.Error())
                {
                    SetErrorId(nonRefTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* nonRefType = nonRefTypeResult.Value();
                Result<TypeSymbol*> ptrTypeResult = nonRefType->AddPointer(context);
                if (ptrTypeResult.Error())
                {
                    SetErrorId(ptrTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* ptrType = ptrTypeResult.Value();
                TypeSymbol* type = ptrType;
                expression.Reset(new BoundReferenceToPointerExpression(arrowNode.GetSpan(), Rvalue(expression), type));
            }
            else if (expression->Type()->IsReferenceType())
            {
                Result<TypeSymbol*> nonRefTypeResult = expression->Type()->RemoveReference(context);
                if (nonRefTypeResult.Error())
                {
                    SetErrorId(nonRefTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* nonRefType = nonRefTypeResult.Value();
                Result<TypeSymbol*> ptrTypeResult = nonRefType->AddPointer(context);
                if (ptrTypeResult.Error())
                {
                    SetErrorId(ptrTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* ptrType = ptrTypeResult.Value();
                TypeSymbol* type = ptrType;
                Result<TypeSymbol*> ptrPtrTypeResult = type->AddPointer(context);
                if (ptrPtrTypeResult.Error())
                {
                    SetErrorId(ptrPtrTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* ptrPtrType = ptrPtrTypeResult.Value();
                expression.Reset(new BoundAddressOfExpression(arrowNode.GetSpan(), UniquePtr<BoundExpression>(new BoundDereferenceExpression(arrowNode.GetSpan(),
                    Rvalue(expression), type)), ptrPtrType));
            }
            else
            {
                Result<TypeSymbol*> ptrTypeResult = expression->Type()->AddPointer(context);
                if (ptrTypeResult.Error())
                {
                    SetErrorId(ptrTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* ptrType = ptrTypeResult.Value();
                TypeSymbol* type = ptrType;
                expression.Reset(new BoundAddressOfExpression(arrowNode.GetSpan(), Rvalue(expression), type));
            }
            BindUnaryOp(expression.Release(), &arrowNode, u"operator->");
            if (Error()) return;
            if (argIsExplicitThisOrBasePtr)
            {
                expression->SetFlag(BoundExpressionFlags.argIsExplicitThisOrBasePtr);
            }
            BindArrow(&arrowNode, arrowNode.MemberId());
            if (Error()) return;
            if (argIsExplicitThisOrBasePtr)
            {
                expression->SetFlag(BoundExpressionFlags.argIsExplicitThisOrBasePtr);
            }
        }
        public override void Visit(DisjunctionNode& disjunctionNode)
        {
            Result<UniquePtr<BoundExpression>> leftResult = BindExpression(disjunctionNode.Left(), boundCompileUnit, boundFunction, containerScope, statementBinder);
            if (leftResult.Error())
            {
                SetErrorId(leftResult.GetErrorId());
                return;
            }
            Result<UniquePtr<BoundExpression>> rightResult = BindExpression(disjunctionNode.Right(), boundCompileUnit, boundFunction, containerScope, statementBinder);
            if (rightResult.Error())
            {
                SetErrorId(leftResult.GetErrorId());
                return;
            }
            Result<TypeSymbol*> boolResult = symbolTable->GetTypeByName(u"bool");
            if (boolResult.Error())
            {
                SetErrorId(boolResult.GetErrorId());
                return;
            }
            TypeSymbol* boolType = boolResult.Value();
            Result<LocalVariableSymbol*> temporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(disjunctionNode.GetSpan(), boolType, context);
            if (temporaryResult.Error())
            {
                SetErrorId(temporaryResult.GetErrorId());
                return;
            }
            LocalVariableSymbol* temporary = temporaryResult.Value();
            BoundDisjunction* boundDisjunction = new BoundDisjunction(disjunctionNode.GetSpan(), Rvalue(leftResult.Value()), Rvalue(rightResult.Value()),
                UniquePtr<BoundLocalVariable>(new BoundLocalVariable(disjunctionNode.GetSpan(), temporary)), boolType);
            expression.Reset(boundDisjunction);
        }
        public override void Visit(ConjunctionNode& conjunctionNode)
        {
            Result<UniquePtr<BoundExpression>> leftResult = BindExpression(conjunctionNode.Left(), boundCompileUnit, boundFunction, containerScope, statementBinder);
            if (leftResult.Error())
            {
                SetErrorId(leftResult.GetErrorId());
                return;
            }
            Result<UniquePtr<BoundExpression>> rightResult = BindExpression(conjunctionNode.Right(), boundCompileUnit, boundFunction, containerScope, statementBinder);
            if (rightResult.Error())
            {
                SetErrorId(leftResult.GetErrorId());
                return;
            }
            Result<TypeSymbol*> boolResult = symbolTable->GetTypeByName(u"bool");
            if (boolResult.Error())
            {
                SetErrorId(boolResult.GetErrorId());
                return;
            }
            TypeSymbol* boolType = boolResult.Value();
            Result<LocalVariableSymbol*> temporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(conjunctionNode.GetSpan(), boolType, context);
            if (temporaryResult.Error())
            {
                SetErrorId(temporaryResult.GetErrorId());
                return;
            }
            LocalVariableSymbol* temporary = temporaryResult.Value();
            BoundConjunction* boundConjunction = new BoundConjunction(conjunctionNode.GetSpan(), Rvalue(leftResult.Value()), Rvalue(rightResult.Value()),
                UniquePtr<BoundLocalVariable>(new BoundLocalVariable(conjunctionNode.GetSpan(), temporary)), boolType);
            expression.Reset(boundConjunction);
        }
        public override void Visit(BitOrNode& bitOrNode)
        {
            BindBinaryOp(&bitOrNode, u"operator|");
        }
        public override void Visit(BitXorNode& bitXorNode)
        {
            BindBinaryOp(&bitXorNode, u"operator^");
        }
        public override void Visit(BitAndNode& bitAndNode)
        {
            BindBinaryOp(&bitAndNode, u"operator&");
        }
        public override void Visit(EqualNode& equalNode)
        {
            BindBinaryOp(&equalNode, u"operator==");
        }
        public override void Visit(NotEqualNode& notEqualNode)
        {
            BindBinaryOp(&notEqualNode, u"operator==");
            if (Error()) return;
            BindUnaryOp(expression.Release(), &notEqualNode, u"operator!");
        }
        public override void Visit(LessNode& lessNode)
        {
            BindBinaryOp(&lessNode, u"operator<");
        }
        public override void Visit(GreaterNode& greaterNode)
        {
            greaterNode.Left()->Accept(*this);
            if (Error()) return;
            BoundExpression* left = expression.Release();
            greaterNode.Right()->Accept(*this);
            if (Error()) return;
            BoundExpression* right = expression.Release();
            BindBinaryOp(right, left, &greaterNode, u"operator<");
        }
        public override void Visit(LessOrEqualNode& lessOrEqualNode)
        {
            lessOrEqualNode.Left()->Accept(*this);
            if (Error()) return;
            BoundExpression* left = expression.Release();
            lessOrEqualNode.Right()->Accept(*this);
            if (Error()) return;
            BoundExpression* right = expression.Release();
            BindBinaryOp(right, left, &lessOrEqualNode, u"operator<");
            if (Error()) return;
            BindUnaryOp(expression.Release(), &lessOrEqualNode, u"operator!");
        }
        public override void Visit(GreaterOrEqualNode& greaterOrEqualNode)
        {
            BindBinaryOp(&greaterOrEqualNode, u"operator<");
            if (Error()) return;
            BindUnaryOp(expression.Release(), &greaterOrEqualNode, u"operator!");
        }
        public override void Visit(ShiftLeftNode& shiftLeftNode)
        {
            BindBinaryOp(&shiftLeftNode, u"operator<<");
        }
        public override void Visit(ShiftRightNode& shiftRightNode)
        {
            BindBinaryOp(&shiftRightNode, u"operator>>");
        }
        public override void Visit(AddNode& addNode)
        {
            BindBinaryOp(&addNode, u"operator+");
        }
        public override void Visit(SubNode& subNode)
        {
            BindBinaryOp(&subNode, u"operator-");
        }
        public override void Visit(MulNode& mulNode)
        {
            BindBinaryOp(&mulNode, u"operator*");
        }
        public override void Visit(DivNode& divNode)
        {
            BindBinaryOp(&divNode, u"operator/");
        }
        public override void Visit(RemNode& remNode)
        {
            BindBinaryOp(&remNode, u"operator%");
        }
        public override void Visit(NotNode& notNode)
        {
            BindUnaryOp(&notNode, u"operator!");
        }
        public override void Visit(UnaryPlusNode& unaryPlusNode)
        {
            BindUnaryOp(&unaryPlusNode, u"operator+");
        }
        public override void Visit(UnaryMinusNode& unaryMinusNode)
        {
            BindUnaryOp(&unaryMinusNode, u"operator-");
        }
        public override void Visit(PrefixIncrementNode& prefixIncrementNode)
        {
            prefixIncrementNode.Subject()->Accept(*this);
            if (Error()) return;
            Result<TypeSymbol*> plainTypeResult = expression->Type()->PlainType(context);
            if (plainTypeResult.Error())
            {
                SetErrorId(plainTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* plainType = plainTypeResult.Value();
            if (plainType->IsClassTypeSymbol())
            {
                BindUnaryOp(&prefixIncrementNode, u"operator++");
            }
            else
            {
                if (!inhibitCompile)
                {
                    if (expression->Type()->IsUnsignedType())
                    {
                        CloneContext cloneContext;
                        AssignmentStatementNode assignmentStatement(prefixIncrementNode.GetSpan(), prefixIncrementNode.FileIndex(),
                            prefixIncrementNode.Subject()->Clone(cloneContext),
                            new AddNode(prefixIncrementNode.GetSpan(), prefixIncrementNode.FileIndex(), prefixIncrementNode.Subject()->Clone(cloneContext),
                                new ByteLiteralNode(prefixIncrementNode.GetSpan(), prefixIncrementNode.FileIndex(), 1u)));
                        Result<bool> result = statementBinder->CompileStatement(&assignmentStatement, false);
                        if (result.Error())
                        {
                            SetErrorId(result.GetErrorId());
                            return;
                        }
                    }
                    else
                    {
                        CloneContext cloneContext;
                        AssignmentStatementNode assignmentStatement(prefixIncrementNode.GetSpan(), prefixIncrementNode.FileIndex(),
                            prefixIncrementNode.Subject()->Clone(cloneContext),
                            new AddNode(prefixIncrementNode.GetSpan(), prefixIncrementNode.FileIndex(), prefixIncrementNode.Subject()->Clone(cloneContext),
                                new SByteLiteralNode(prefixIncrementNode.GetSpan(), prefixIncrementNode.FileIndex(), 1)));
                        Result<bool> result = statementBinder->CompileStatement(&assignmentStatement, false);
                        if (result.Error())
                        {
                            SetErrorId(result.GetErrorId());
                            return;
                        }
                    }
                }
                bool prevInhibitCompile = inhibitCompile;
                inhibitCompile = true;
                prefixIncrementNode.Subject()->Accept(*this);
                if (Error()) return;
                inhibitCompile = prevInhibitCompile;
            }
        }
        public override void Visit(PrefixDecrementNode& prefixDecrementNode)
        {
            prefixDecrementNode.Subject()->Accept(*this);
            if (Error()) return;
            Result<TypeSymbol*> plainTypeResult = expression->Type()->PlainType(context);
            if (plainTypeResult.Error())
            {
                SetErrorId(plainTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* plainType = plainTypeResult.Value();
            if (plainType->IsClassTypeSymbol())
            {
                BindUnaryOp(&prefixDecrementNode, u"operator--");
            }
            else
            {
                if (!inhibitCompile)
                {
                    if (expression->Type()->IsUnsignedType())
                    {
                        CloneContext cloneContext;
                        AssignmentStatementNode assignmentStatement(prefixDecrementNode.GetSpan(), prefixDecrementNode.FileIndex(),
                            prefixDecrementNode.Subject()->Clone(cloneContext),
                            new SubNode(prefixDecrementNode.GetSpan(), prefixDecrementNode.FileIndex(), prefixDecrementNode.Subject()->Clone(cloneContext),
                                new ByteLiteralNode(prefixDecrementNode.GetSpan(), prefixDecrementNode.FileIndex(), 1u)));
                        Result<bool> result = statementBinder->CompileStatement(&assignmentStatement, false);
                        if (result.Error())
                        {
                            SetErrorId(result.GetErrorId());
                            return;
                        }
                    }
                    else
                    {
                        CloneContext cloneContext;
                        AssignmentStatementNode assignmentStatement(prefixDecrementNode.GetSpan(), prefixDecrementNode.FileIndex(),
                            prefixDecrementNode.Subject()->Clone(cloneContext),
                            new SubNode(prefixDecrementNode.GetSpan(), prefixDecrementNode.FileIndex(), prefixDecrementNode.Subject()->Clone(cloneContext),
                                new SByteLiteralNode(prefixDecrementNode.GetSpan(), prefixDecrementNode.FileIndex(), 1)));
                        Result<bool> result = statementBinder->CompileStatement(&assignmentStatement, false);
                        if (result.Error())
                        {
                            SetErrorId(result.GetErrorId());
                            return;
                        }
                    }
                }
                bool prevInhibitCompile = inhibitCompile;
                inhibitCompile = true;
                prefixDecrementNode.Subject()->Accept(*this);
                if (Error()) return;
                inhibitCompile = prevInhibitCompile;
            }
        }
        public override void Visit(PostfixIncrementNode& postfixIncrementNode)
        {
            bool prevInhibitCompile = inhibitCompile;
            inhibitCompile = true;
            postfixIncrementNode.Subject()->Accept(*this);
            if (Error()) return;
            inhibitCompile = prevInhibitCompile;
            if (!inhibitCompile)
            {
                Result<TypeSymbol*> plainTypeResult = expression->Type()->PlainType(context);
                if (plainTypeResult.Error())
                {
                    SetErrorId(plainTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* plainType = plainTypeResult.Value();
                if (plainType->IsClassTypeSymbol())
                {
                    CloneContext cloneContext;
                    ExpressionStatementNode prefixIncrementExpression(postfixIncrementNode.GetSpan(), postfixIncrementNode.FileIndex(),
                        new PrefixIncrementNode(postfixIncrementNode.GetSpan(), postfixIncrementNode.FileIndex(), postfixIncrementNode.Subject()->Clone(cloneContext)));
                    Result<bool> result = statementBinder->CompileStatement(&prefixIncrementExpression, true);
                    if (result.Error())
                    {
                        SetErrorId(result.GetErrorId());
                        return;
                    }
                }
                else
                {
                    if (expression->Type()->IsUnsignedType())
                    {
                        CloneContext cloneContext;
                        AssignmentStatementNode assignmentStatement(postfixIncrementNode.GetSpan(), postfixIncrementNode.FileIndex(),
                            postfixIncrementNode.Subject()->Clone(cloneContext),
                            new AddNode(postfixIncrementNode.GetSpan(), postfixIncrementNode.FileIndex(), postfixIncrementNode.Subject()->Clone(cloneContext),
                                new ByteLiteralNode(postfixIncrementNode.GetSpan(), postfixIncrementNode.FileIndex(), 1u)));
                        Result<bool> result = statementBinder->CompileStatement(&assignmentStatement, true);
                        if (result.Error())
                        {
                            SetErrorId(result.GetErrorId());
                            return;
                        }
                    }
                    else
                    {
                        CloneContext cloneContext;
                        AssignmentStatementNode assignmentStatement(postfixIncrementNode.GetSpan(), postfixIncrementNode.FileIndex(),
                            postfixIncrementNode.Subject()->Clone(cloneContext),
                            new AddNode(postfixIncrementNode.GetSpan(), postfixIncrementNode.FileIndex(), postfixIncrementNode.Subject()->Clone(cloneContext),
                                new SByteLiteralNode(postfixIncrementNode.GetSpan(), postfixIncrementNode.FileIndex(), 1)));
                        Result<bool> result = statementBinder->CompileStatement(&assignmentStatement, true);
                        if (result.Error())
                        {
                            SetErrorId(result.GetErrorId());
                            return;
                        }
                    }
                }
            }
            postfixIncrementNode.Subject()->Accept(*this);
        }
        public override void Visit(PostfixDecrementNode& postfixDecrementNode)
        {
            bool prevInhibitCompile = inhibitCompile;
            inhibitCompile = true;
            postfixDecrementNode.Subject()->Accept(*this);
            if (Error()) return;
            inhibitCompile = prevInhibitCompile;
            if (!inhibitCompile)
            {
                Result<TypeSymbol*> plainTypeResult = expression->Type()->PlainType(context);
                if (plainTypeResult.Error())
                {
                    SetErrorId(plainTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* plainType = plainTypeResult.Value();
                if (plainType->IsClassTypeSymbol())
                {
                    CloneContext cloneContext;
                    ExpressionStatementNode prefixDecrementExpression(postfixDecrementNode.GetSpan(), postfixDecrementNode.FileIndex(),
                        new PrefixDecrementNode(postfixDecrementNode.GetSpan(), postfixDecrementNode.FileIndex(), postfixDecrementNode.Subject()->Clone(cloneContext)));
                    Result<bool> result = statementBinder->CompileStatement(&prefixDecrementExpression, true);
                    if (result.Error())
                    {
                        SetErrorId(result.GetErrorId());
                        return;
                    }
                }
                else
                {
                    if (expression->Type()->IsUnsignedType())
                    {
                        CloneContext cloneContext;
                        AssignmentStatementNode assignmentStatement(postfixDecrementNode.GetSpan(), postfixDecrementNode.FileIndex(),
                            postfixDecrementNode.Subject()->Clone(cloneContext),
                            new SubNode(postfixDecrementNode.GetSpan(), postfixDecrementNode.FileIndex(), postfixDecrementNode.Subject()->Clone(cloneContext),
                                new ByteLiteralNode(postfixDecrementNode.GetSpan(), postfixDecrementNode.FileIndex(), 1u)));
                        Result<bool> result = statementBinder->CompileStatement(&assignmentStatement, true);
                        if (result.Error())
                        {
                            SetErrorId(result.GetErrorId());
                            return;
                        }
                    }
                    else
                    {
                        CloneContext cloneContext;
                        AssignmentStatementNode assignmentStatement(postfixDecrementNode.GetSpan(), postfixDecrementNode.FileIndex(),
                            postfixDecrementNode.Subject()->Clone(cloneContext),
                            new SubNode(postfixDecrementNode.GetSpan(), postfixDecrementNode.FileIndex(), postfixDecrementNode.Subject()->Clone(cloneContext),
                                new SByteLiteralNode(postfixDecrementNode.GetSpan(), postfixDecrementNode.FileIndex(), 1)));
                        Result<bool> result = statementBinder->CompileStatement(&assignmentStatement, true);
                        if (result.Error())
                        {
                            SetErrorId(result.GetErrorId());
                            return;
                        }
                    }
                }
            }
            postfixDecrementNode.Subject()->Accept(*this);
        }
        public override void Visit(DerefNode& derefNode)
        {
            derefNode.Subject()->Accept(*this);
            if (Error()) return;
            BindDerefExpr(&derefNode);
        }
        public override void Visit(AddrOfNode& addrOfNode)
        {
            addrOfNode.Subject()->Accept(*this);
            if (expression->IsLvalueExpression())
            {
                if (expression->Type()->IsReferenceType())
                {
                    Result<TypeSymbol*> nonRefTypeResult = expression->Type()->RemoveReference(context);
                    if (nonRefTypeResult.Error())
                    {
                        SetErrorId(nonRefTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* nonRefType = nonRefTypeResult.Value();
                    Result<TypeSymbol*> pointerTypeResult = nonRefType->AddPointer(context);
                    if (pointerTypeResult.Error())
                    {
                        SetErrorId(pointerTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* pointerType = pointerTypeResult.Value();
                    TypeSymbol* type = pointerType;
                    expression.Reset(new BoundReferenceToPointerExpression(addrOfNode.GetSpan(), UniquePtr<BoundExpression>(expression.Release()), type));
                }
                else
                {
                    Result<TypeSymbol*> pointerTypeResult = expression->Type()->AddPointer(context);
                    if (pointerTypeResult.Error())
                    {
                        SetErrorId(pointerTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* pointerType = pointerTypeResult.Value();
                    TypeSymbol* type = pointerType;
                    expression.Reset(new BoundAddressOfExpression(addrOfNode.GetSpan(), UniquePtr<BoundExpression>(expression.Release()), type));
                }
            }
            else
            {
                int errorId = MakeError("cannot take address of " + expression->TypeString(), addrOfNode.GetFullSpan());
                SetErrorId(errorId);
                return;
            }
        }
        public override void Visit(ComplementNode& complementNode)
        {
            BindUnaryOp(&complementNode, u"operator~");
        }
        public override void Visit(IsNode& isNode)
        {
            Result<TypeSymbol*> rightTypeResult = ResolveType(isNode.TargetTypeExpr(), boundCompileUnit, containerScope);
            if (rightTypeResult.Error())
            {
                SetErrorId(rightTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* rightType = rightTypeResult.Value();
            if (rightType->IsPointerType())
            {
                Result<TypeSymbol*> rightBaseTypeResult = rightType->RemovePointer(context);
                if (rightBaseTypeResult.Error())
                {
                    SetErrorId(rightBaseTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* rightBaseType = rightBaseTypeResult.Value();
                if (rightBaseType->IsClassTypeSymbol())
                {
                    ClassTypeSymbol* rightClassType = cast<ClassTypeSymbol*>(rightBaseType);
                    if (rightClassType->IsPolymorphic())
                    {
                        Result<UniquePtr<BoundExpression>> exprResult = BindExpression(isNode.Expr(), boundCompileUnit, boundFunction, containerScope, statementBinder,
                            false, false, false);
                        if (exprResult.Error())
                        {
                            SetErrorId(exprResult.GetErrorId());
                            return;
                        }
                        UniquePtr<BoundExpression>& expr = exprResult.Value();
                        TypeSymbol* leftType = expr->Type();
                        if (leftType->IsPointerType())
                        {
                            Result<TypeSymbol*> leftTypeResult = leftType->RemovePointer(context);
                            if (leftTypeResult.Error())
                            {
                                SetErrorId(leftTypeResult.GetErrorId());
                                return;
                            }
                            TypeSymbol* leftBaseType = leftTypeResult.Value();
                            if (leftBaseType->IsClassTypeSymbol())
                            {
                                ClassTypeSymbol* leftClassType = cast<ClassTypeSymbol*>(leftBaseType);
                                if (leftClassType->IsPolymorphic())
                                {
                                    Result<TypeSymbol*> ulongTypeResult = symbolTable->GetTypeByName(u"ulong");
                                    if (ulongTypeResult.Error())
                                    {
                                        SetErrorId(ulongTypeResult.GetErrorId());
                                        return;
                                    }
                                    TypeSymbol* ulongType = ulongTypeResult.Value();
                                    Result<LocalVariableSymbol*> leftTemporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(isNode.GetSpan(), ulongType, context);
                                    if (leftTemporaryResult.Error())
                                    {
                                        SetErrorId(leftTemporaryResult.GetErrorId());
                                        return;
                                    }
                                    LocalVariableSymbol* leftTemporary = leftTemporaryResult.Value();
                                    UniquePtr<BoundLocalVariable> leftClassIdVar(new BoundLocalVariable(isNode.GetSpan(), leftTemporary));
                                    Result<LocalVariableSymbol*> rightTemporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(isNode.GetSpan(), ulongType, context);
                                    if (rightTemporaryResult.Error())
                                    {
                                        SetErrorId(rightTemporaryResult.GetErrorId());
                                        return;
                                    }
                                    LocalVariableSymbol* rightTemporary = rightTemporaryResult.Value();
                                    List<FunctionScopeLookup> functionScopeLookups;
                                    functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                                    List<UniquePtr<BoundExpression>> arguments;
                                    Result<TypeSymbol*> voidTypeResult = symbolTable->GetTypeByName(u"void");
                                    if (voidTypeResult.Error())
                                    {
                                        SetErrorId(voidTypeResult.GetErrorId());
                                        return;
                                    }
                                    TypeSymbol* voidType = voidTypeResult.Value();
                                    Result<TypeSymbol*> voidPtrTypeResult = voidType->AddPointer(context);
                                    if (voidPtrTypeResult.Error())
                                    {
                                        SetErrorId(voidPtrTypeResult.GetErrorId());
                                        return;
                                    }
                                    TypeSymbol* voidPtrType = voidPtrTypeResult.Value();
                                    arguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(isNode.GetSpan(), voidPtrType)));
                                    arguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(isNode.GetSpan(), voidPtrType)));
                                    Result<UniquePtr<BoundFunctionCall>> rtmIsFunctionCallResult = ResolveOverload(u"RtmIs", containerScope, functionScopeLookups, arguments,
                                        boundCompileUnit, boundFunction, &isNode);
                                    if (rtmIsFunctionCallResult.Error())
                                    {
                                        SetErrorId(rtmIsFunctionCallResult.GetErrorId());
                                        return;
                                    }
                                    FunctionSymbol* rtmIsFunctionSymbol = rtmIsFunctionCallResult.Value()->GetFunctionSymbol();
                                    UniquePtr<BoundLocalVariable> rightClassIdVar(new BoundLocalVariable(isNode.GetSpan(), rightTemporary));
                                    expression.Reset(new BoundIsExpression(isNode.GetSpan(), Rvalue(expr), rightClassType, Rvalue(leftClassIdVar), Rvalue(rightClassIdVar),
                                        rtmIsFunctionSymbol));
                                }
                                else
                                {
                                    int errorId = MakeError("left type in 'is' expression must be pointer to polymorphic class type", isNode.Expr()->GetFullSpan());
                                    SetErrorId(errorId);
                                    return;
                                }
                            }
                            else
                            {
                                int errorId = MakeError("left type in 'is' expression must be pointer to polymorphic class type", isNode.Expr()->GetFullSpan());
                                SetErrorId(errorId);
                                return;
                            }
                        }
                        else
                        {
                            int errorId = MakeError("left type in 'is' expression must be pointer to polymorphic class type", isNode.Expr()->GetFullSpan());
                            SetErrorId(errorId);
                            return;
                        }
                    }
                    else
                    {
                        int errorId = MakeError("right type in 'is' expression must be pointer to polymorphic class type", isNode.TargetTypeExpr()->GetFullSpan());
                        SetErrorId(errorId);
                        return;
                    }
                }
                else
                {
                    int errorId = MakeError("right type in 'is' expression must be pointer to polymorphic class type", isNode.TargetTypeExpr()->GetFullSpan());
                    SetErrorId(errorId);
                    return;
                }
            }
            else
            {
                int errorId = MakeError("right type in 'is' expression must be pointer to polymorphic class type", isNode.TargetTypeExpr()->GetFullSpan());
                SetErrorId(errorId);
                return;
            }
        }
        public override void Visit(AsNode& asNode)
        {
            Result<TypeSymbol*> rightTypeResult = ResolveType(asNode.TargetTypeExpr(), boundCompileUnit, containerScope);
            if (rightTypeResult.Error())
            {
                SetErrorId(rightTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* rightType = rightTypeResult.Value();
            if (rightType->IsPointerType())
            {
                Result<TypeSymbol*> rightBaseTypeResult = rightType->RemovePointer(context);
                if (rightBaseTypeResult.Error())
                {
                    SetErrorId(rightBaseTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* rightBaseType = rightBaseTypeResult.Value();
                if (rightBaseType->IsClassTypeSymbol())
                {
                    ClassTypeSymbol* rightClassType = cast<ClassTypeSymbol*>(rightBaseType);
                    if (rightClassType->IsPolymorphic())
                    {
                        Result<UniquePtr<BoundExpression>> exprResult = BindExpression(asNode.Expr(), boundCompileUnit, boundFunction, containerScope, statementBinder,
                            false, false, false);
                        if (exprResult.Error())
                        {
                            SetErrorId(exprResult.GetErrorId());
                            return;
                        }
                        UniquePtr<BoundExpression>& expr = exprResult.Value();
                        TypeSymbol* leftType = expr->Type();
                        if (leftType->IsPointerType())
                        {
                            Result<TypeSymbol*> leftBaseTypeResult = leftType->RemovePointer(context);
                            if (leftBaseTypeResult.Error())
                            {
                                SetErrorId(leftBaseTypeResult.GetErrorId());
                                return;
                            }
                            TypeSymbol* leftBaseType = leftBaseTypeResult.Value();
                            if (leftBaseType->IsClassTypeSymbol())
                            {
                                ClassTypeSymbol* leftClassType = cast<ClassTypeSymbol*>(leftBaseType);
                                if (leftClassType->IsPolymorphic())
                                {
                                    Result<TypeSymbol*> ulongTypeResult = symbolTable->GetTypeByName(u"ulong");
                                    if (ulongTypeResult.Error())
                                    {
                                        SetErrorId(ulongTypeResult.GetErrorId());
                                        return;
                                    }
                                    TypeSymbol* ulongType = ulongTypeResult.Value();
                                    Result<LocalVariableSymbol*> leftTemporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(asNode.GetSpan(), ulongType, context);
                                    if (leftTemporaryResult.Error())
                                    {
                                        SetErrorId(leftTemporaryResult.GetErrorId());
                                        return;
                                    }
                                    LocalVariableSymbol* leftTemporary = leftTemporaryResult.Value();
                                    UniquePtr<BoundLocalVariable> leftClassIdVar(new BoundLocalVariable(asNode.GetSpan(), leftTemporary));
                                    Result<LocalVariableSymbol*> rightTemporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(asNode.GetSpan(), ulongType, context);
                                    if (rightTemporaryResult.Error())
                                    {
                                        SetErrorId(rightTemporaryResult.GetErrorId());
                                        return;
                                    }
                                    LocalVariableSymbol* rightTemporary = rightTemporaryResult.Value();
                                    List<FunctionScopeLookup> functionScopeLookups;
                                    functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                                    List<UniquePtr<BoundExpression>> arguments;
                                    Result<TypeSymbol*> voidTypeResult = symbolTable->GetTypeByName(u"void");
                                    if (voidTypeResult.Error())
                                    {
                                        SetErrorId(voidTypeResult.GetErrorId());
                                        return;
                                    }
                                    TypeSymbol* voidType = voidTypeResult.Value();
                                    Result<TypeSymbol*> voidPtrTypeResult = voidType->AddPointer(context);
                                    if (voidPtrTypeResult.Error())
                                    {
                                        SetErrorId(voidPtrTypeResult.GetErrorId());
                                        return;
                                    }
                                    TypeSymbol* voidPtrType = voidPtrTypeResult.Value();
                                    arguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(asNode.GetSpan(), voidPtrType)));
                                    arguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(asNode.GetSpan(), voidPtrType)));
                                    Result<UniquePtr<BoundFunctionCall>> rtmIsFunctionCallResult = ResolveOverload(u"RtmIs", containerScope, functionScopeLookups, arguments,
                                        boundCompileUnit, boundFunction, &asNode);
                                    if (rtmIsFunctionCallResult.Error())
                                    {
                                        SetErrorId(rtmIsFunctionCallResult.GetErrorId());
                                        return;
                                    }
                                    FunctionSymbol* rtmIsFunctionSymbol = rtmIsFunctionCallResult.Value()->GetFunctionSymbol();
                                    UniquePtr<BoundLocalVariable> rightClassIdVar(new BoundLocalVariable(asNode.GetSpan(), rightTemporary));
                                    Result<TypeSymbol*> pointerTypeResult = rightClassType->AddPointer(context);
                                    if (pointerTypeResult.Error())
                                    {
                                        SetErrorId(pointerTypeResult.GetErrorId());
                                        return;
                                    }
                                    TypeSymbol* pointerType = pointerTypeResult.Value();
                                    Result<LocalVariableSymbol*> temporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(asNode.GetSpan(), pointerType, context);
                                    if (temporaryResult.Error())
                                    {
                                        SetErrorId(temporaryResult.GetErrorId());
                                        return;
                                    }
                                    LocalVariableSymbol* temporary = temporaryResult.Value();
                                    UniquePtr<BoundLocalVariable> variable(new BoundLocalVariable(asNode.GetSpan(), temporary));
                                    expression.Reset(new BoundAsExpression(asNode.GetSpan(), Rvalue(expr), rightClassType, Rvalue(variable),
                                        Rvalue(leftClassIdVar), Rvalue(rightClassIdVar), rtmIsFunctionSymbol, pointerType));
                                }
                                else
                                {
                                    int errorId = MakeError("left type in 'as' expression must be pointer to polymorphic class type", asNode.Expr()->GetFullSpan());
                                    SetErrorId(errorId);
                                    return;
                                }
                            }
                            else
                            {
                                int errorId = MakeError("left type in 'as' expression must be pointer to polymorphic class type", asNode.Expr()->GetFullSpan());
                                SetErrorId(errorId);
                                return;
                            }
                        }
                        else
                        {
                            int errorId = MakeError("left type in 'as' expression must be pointer to polymorphic class type", asNode.Expr()->GetFullSpan());
                            SetErrorId(errorId);
                            return;
                        }
                    }
                    else
                    {
                        int errorId = MakeError("right type in 'as' expression must be pointer to polymorphic class type", asNode.TargetTypeExpr()->GetFullSpan());
                        SetErrorId(errorId);
                        return;
                    }
                }
                else
                {
                    int errorId = MakeError("right type in 'as' expression must be pointer to polymorphic class type", asNode.TargetTypeExpr()->GetFullSpan());
                    SetErrorId(errorId);
                    return;
                }
            }
            else
            {
                int errorId = MakeError("right type in 'as' expression must be pointer to polymorphic class type", asNode.TargetTypeExpr()->GetFullSpan());
                SetErrorId(errorId);
                return;
            }
        }
        public override void Visit(IndexingNode& indexingNode)
        {
            indexingNode.Subject()->Accept(*this);
            if (Error()) return;
            UniquePtr<BoundExpression> subject = Rvalue(expression);
            indexingNode.Index()->Accept(*this);
            if (Error()) return;
            UniquePtr<BoundExpression> index = Rvalue(expression);
            Result<TypeSymbol*> plainSubjectTypeResult = subject->Type()->PlainType(context);
            if (plainSubjectTypeResult.Error())
            {
                SetErrorId(plainSubjectTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* plainSubjectType = plainSubjectTypeResult.Value();
            if (plainSubjectType->IsClassTypeSymbol())
            {
                BindBinaryOp(subject.Release(), index.Release(), &indexingNode, u"operator[]");
                if (Error()) return;
            }
            else if (plainSubjectType->IsPointerType())
            {
                BindBinaryOp(subject.Release(), index.Release(), &indexingNode, u"operator+");
                if (Error()) return;
                BindDerefExpr(&indexingNode);
                if (Error()) return;
            }
            else if (plainSubjectType->IsArrayTypeSymbol())
            {
                ArrayTypeSymbol* arraryType = cast<ArrayTypeSymbol*>(plainSubjectType);
                TypeSymbol* elementType = arraryType->ElementType();
                Result<UniquePtr<Value>> valueResult = Evaluate(&indexingNode, elementType, containerScope, boundCompileUnit, boundFunction);
                if (!valueResult.Error())
                {
                    UniquePtr<Value> value = Rvalue(valueResult.Value());
                    if (!value.IsNull())
                    {
                        Result<TypeSymbol*> typeResult = value->Type(symbolTable, context);
                        if (typeResult.Error())
                        {
                            SetErrorId(typeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* type = typeResult.Value();
                        expression.Reset(new BoundLiteral(indexingNode.GetSpan(), Rvalue(value), type));
                    }
                    else
                    {
                        BindBinaryOp(subject.Release(), index.Release(), &indexingNode, u"operator[]");
                        if (Error()) return;
                    }
                }
                else
                {
                    BindBinaryOp(subject.Release(), index.Release(), &indexingNode, u"operator[]");
                    if (Error()) return;
                }
            }
            else
            {
                int errorId = MakeError("subscript operator can be applied only to pointer, array or class type subject", indexingNode.GetFullSpan());
                SetErrorId(errorId);
                return;
            }
        }
        public override void Visit(InvokeNode& invokeNode)
        {
            invokeNode.Subject()->Accept(*this);
            if (Error()) return;
            bool argIsExplicitThisOrBasePtr = expression->GetFlag(BoundExpressionFlags.argIsExplicitThisOrBasePtr);
            List<UniquePtr<BoundExpression>> arguments;
            List<FunctionScopeLookup> functionScopeLookups;
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
            FunctionGroupSymbol* functionGroupSymbol = null;
            List<TypeSymbol*> templateArgumentTypes;
            ustring groupName;
            bool scopeQualified = false;
            LocalVariableSymbol* temporary = null;
            Result<TypeSymbol*> plainExpressionTypeResult = expression->Type()->PlainType(context);
            if (plainExpressionTypeResult.Error())
            {
                SetErrorId(plainExpressionTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* plainExpressionType = plainExpressionTypeResult.Value();
            if (expression->IsBoundFunctionGroupExpression())
            {
                BoundFunctionGroupExpression* bfge = cast<BoundFunctionGroupExpression*>(expression.Get());
                functionGroupSymbol = bfge->FunctionGroup();
                templateArgumentTypes = bfge->TemplateArgumentTypes();
                groupName = functionGroupSymbol->Name();
                if (bfge->IsScopeQualified())
                {
                    functionScopeLookups.Clear();
                    functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_, bfge->QualifiedScope()));
                    scopeQualified = true;
                }
                if (bfge->ClassPtr() != null)
                {
                    arguments.Add(UniquePtr<BoundExpression>(bfge->ReleaseClassPtr()));
                }
            }
            else if (expression->IsBoundMemberExpression())
            {
                BoundMemberExpression* bme = cast<BoundMemberExpression*>(expression.Get());
                if (bme->Member()->IsBoundFunctionGroupExpression())
                {
                    BoundFunctionGroupExpression* bfge = cast<BoundFunctionGroupExpression*>(bme->Member());
                    functionGroupSymbol = bfge->FunctionGroup();
                    templateArgumentTypes = bfge->TemplateArgumentTypes();
                    groupName = functionGroupSymbol->Name();
                    if (bfge->IsScopeQualified())
                    {
                        functionScopeLookups.Clear();
                        functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_, bfge->QualifiedScope()));
                        scopeQualified = true;
                    }
                    if (!scopeQualified)
                    {
                        Result<ContainerScope*> scopeResult = bme->ClassPtr()->Type()->BaseType()->ClassInterfaceOrNsScope(context);
                        if (scopeResult.Error())
                        {
                            SetErrorId(scopeResult.GetErrorId());
                            return;
                        }
                        ContainerScope* scope = scopeResult.Value();
                        functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base, scope));
                    }
                    arguments.Add(UniquePtr<BoundExpression>(bme->ReleaseClassPtr()));
                    Result<TypeSymbol*> plainTypeResult = arguments.Front()->Type()->PlainType(context);
                    if (plainTypeResult.Error())
                    {
                        SetErrorId(plainTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* plainType = plainTypeResult.Value();
                    if (plainType->IsInterfaceTypeSymbol())
                    {
                        if (arguments.Front()->Type()->IsReferenceType())
                        {
                            Result<TypeSymbol*> nonRefTypeResult = arguments.Front()->Type()->RemoveReference(context);
                            if (nonRefTypeResult.Error())
                            {
                                SetErrorId(nonRefTypeResult.GetErrorId());
                                return;
                            }
                            TypeSymbol* nonRefType = nonRefTypeResult.Value();
                            Result<TypeSymbol*> ptrTypeResult = nonRefType->AddPointer(context);
                            if (ptrTypeResult.Error())
                            {
                                SetErrorId(ptrTypeResult.GetErrorId());
                                return;
                            }
                            TypeSymbol* type = ptrTypeResult.Value();
                            arguments[0].Reset(new BoundReferenceToPointerExpression(invokeNode.GetSpan(), Rvalue(arguments[0]), type));
                        }
                        else
                        {
                            Result<TypeSymbol*> ptrTypeResult = arguments.Front()->Type()->AddPointer(context);
                            if (ptrTypeResult.Error())
                            {
                                SetErrorId(ptrTypeResult.GetErrorId());
                                return;
                            }
                            TypeSymbol* type = ptrTypeResult.Value();
                            arguments[0].Reset(new BoundAddressOfExpression(invokeNode.GetSpan(), Rvalue(arguments[0]), type));
                        }
                    }
                }
                else
                {
                    int errorId = MakeError("invoke cannot be applied to this type of expression", invokeNode.GetFullSpan());
                    SetErrorId(errorId);
                    return;
                }
            }
            else if (expression->IsBoundTypeExpression())
            {
                TypeSymbol* type = expression->Type();
                if (type->IsClassGroupSymbol())
                {
                    ClassGroupSymbol* classGroup = cast<ClassGroupSymbol*>(type);
                    ClassTypeSymbol* classTypeSymbol = classGroup->GetClass(0);
                    if (classTypeSymbol == null)
                    {
                        Result<string> classGroupFullNameResult = ToUtf8(classGroup->FullName());
                        string classGroupFullName = Rvalue(classGroupFullNameResult.Value());
                        int errorId = MakeError("nontemplate class not found from class group '" + classGroupFullName + "'", invokeNode.GetFullSpan(), classGroup->FullSpan());
                        SetErrorId(errorId);
                        return;
                    }
                    expression.Reset(new BoundTypeExpression(invokeNode.GetSpan(), classTypeSymbol));
                    type = classTypeSymbol;
                }
                if (!scopeQualified)
                {
                    Result<ContainerScope*> scopeResult = type->BaseType()->ClassInterfaceEnumDelegateOrNsScope(context);
                    if (scopeResult.Error())
                    {
                        SetErrorId(scopeResult.GetErrorId());
                        return;
                    }
                    ContainerScope* scope = scopeResult.Value();
                    functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base, scope));
                }
                if (type->IsClassTemplateSpecializationSymbol())
                {
                    ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type);
                    if (!specialization->IsBound())
                    {
                        Result<bool> result = boundCompileUnit->GetClassTemplateRepository()->BindClassTemplateSpecialization(specialization, containerScope, &invokeNode);
                        if (result.Error())
                        {
                            SetErrorId(result.GetErrorId());
                            return;
                        }
                    }
                }
                Result<LocalVariableSymbol*> temporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(invokeNode.GetSpan(), type, context);
                if (temporaryResult.Error())
                {
                    SetErrorId(temporaryResult.GetErrorId());
                    return;
                }
                temporary = temporaryResult.Value();
                Result<TypeSymbol*> ptrTypeResult = type->AddPointer(context);
                if (ptrTypeResult.Error())
                {
                    SetErrorId(ptrTypeResult.GetErrorId());
                    return;
                }
                UniquePtr<BoundExpression> addrOfTemporary(new BoundAddressOfExpression(invokeNode.GetSpan(),
                    UniquePtr<BoundExpression>(new BoundLocalVariable(invokeNode.GetSpan(), temporary)), ptrTypeResult.Value()));
                arguments.Add(Rvalue(addrOfTemporary));
                groupName = u"@constructor";
                if (type->IsClassTypeSymbol())
                {
                    ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type);
                    if (classType->Destructor() != null)
                    {
                        UniquePtr<BoundFunctionCall> destructorCall(new BoundFunctionCall(invokeNode.GetSpan(), classType->Destructor()));
                        destructorCall->AddArgument(UniquePtr<BoundExpression>(arguments.Back()->Clone()));
                        Result<bool> result = boundFunction->AddTemporaryDestructorCall(Rvalue(destructorCall), boundFunction, containerScope, &invokeNode);
                        if (result.Error())
                        {
                            SetErrorId(result.GetErrorId());
                            return;
                        }
                    }
                }
            }
            else if (plainExpressionType->IsClassTypeSymbol())
            {
                TypeSymbol* type = expression->Type();
                ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(plainExpressionType);
                groupName = u"operator()";
                functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_, classType->GetContainerScope()));
                if (type->IsReferenceType())
                {
                    Result<TypeSymbol*> nonRefTypeResult = type->RemoveReference(context);
                    if (nonRefTypeResult.Error())
                    {
                        SetErrorId(nonRefTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* nonRefType = nonRefTypeResult.Value();
                    Result<TypeSymbol*> ptrTypeResult = nonRefType->AddPointer(context);
                    if (ptrTypeResult.Error())
                    {
                        SetErrorId(ptrTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* ptrType = ptrTypeResult.Value();
                    expression.Reset(new BoundReferenceToPointerExpression(invokeNode.GetSpan(), Rvalue(expression), ptrType));
                }
                else
                {
                    Result<TypeSymbol*> ptrTypeResult = type->AddPointer(context);
                    if (ptrTypeResult.Error())
                    {
                        SetErrorId(ptrTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* ptrType = ptrTypeResult.Value();
                    expression.Reset(new BoundAddressOfExpression(invokeNode.GetSpan(), Rvalue(expression), ptrType));
                }
                arguments.Add(UniquePtr<BoundExpression>(expression.Release()));
            }
            else if (plainExpressionType->IsDelegateTypeSymbol())
            {
                TypeSymbol* type = expression->Type();
                if (type->IsReferenceType())
                {
                    Result<TypeSymbol*> nonRefTypeResult = type->RemoveReference(context);
                    if (nonRefTypeResult.Error())
                    {
                        SetErrorId(nonRefTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* nonRefType = nonRefTypeResult.Value();
                    arguments.Add(UniquePtr<BoundExpression>(new BoundDereferenceExpression(invokeNode.GetSpan(), Rvalue(expression), nonRefType)));
                }
                else
                {
                    arguments.Add(Rvalue(expression));
                }
                DelegateTypeSymbol* delegateTypeSymbol = cast<DelegateTypeSymbol*>(type->BaseType());
                int n = cast<int>(invokeNode.Arguments().Count());
                if (n != delegateTypeSymbol->Arity())
                {
                    Result<string> delegateTypeFullNameResult = ToUtf8(delegateTypeSymbol->FullName());
                    if (delegateTypeFullNameResult.Error())
                    {
                        SetErrorId(delegateTypeFullNameResult.GetErrorId());
                        return;
                    }
                    string delegateTypeFullName = Rvalue(delegateTypeFullNameResult.Value());
                    int errorId = MakeError("wrong number of arguments for calling delegate type '" + delegateTypeFullName + "'", invokeNode.GetFullSpan());
                    SetErrorId(errorId);
                    return;
                }
                for (int i = 0; i < n; ++i)
                {
                    TypeSymbol* delegateParameterType = delegateTypeSymbol->Parameters()[i]->Type();
                    Node* argument = invokeNode.Arguments()[i];
                    argument->Accept(*this);
                    if (Error()) return;
                    TypeSymbol* argumentType = expression->Type();
                    if (!TypesEqual(argumentType, delegateParameterType))
                    {
                        Result<TypeSymbol*> argumentPlainTypeResult = argumentType->PlainType(context);
                        if (argumentPlainTypeResult.Error())
                        {
                            SetErrorId(argumentPlainTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* argumentPlainType = argumentPlainTypeResult.Value();
                        Result<TypeSymbol*> delegatePlainTypeResult = delegateParameterType->PlainType(context);
                        if (delegatePlainTypeResult.Error())
                        {
                            SetErrorId(delegatePlainTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* delegatePlainType = delegatePlainTypeResult.Value();
                        if (TypesEqual(argumentPlainType, delegatePlainType))
                        {
                            if (argumentType->IsReferenceType() && !delegateParameterType->IsReferenceType())
                            {
                                Result<TypeSymbol*> nonRefTypeResult = argumentType->RemoveReference(context);
                                if (nonRefTypeResult.Error())
                                {
                                    SetErrorId(nonRefTypeResult.GetErrorId());
                                    return;
                                }
                                TypeSymbol* type = nonRefTypeResult.Value();
                                BoundDereferenceExpression* dereferenceExpression = new BoundDereferenceExpression(invokeNode.GetSpan(), Rvalue(expression), type);
                                expression.Reset(dereferenceExpression);
                            }
                            else if (!argumentType->IsReferenceType() &&
                                (delegateParameterType->IsReferenceType() || delegateParameterType->IsClassTypeSymbol()))
                            {
                                Result<TypeSymbol*> lvalueRefTypeResult = argumentType->AddLvalueReference(context);
                                if (lvalueRefTypeResult.Error())
                                {
                                    SetErrorId(lvalueRefTypeResult.GetErrorId());
                                    return;
                                }
                                TypeSymbol* type = lvalueRefTypeResult.Value();
                                BoundAddressOfExpression* addressOfExpression = new BoundAddressOfExpression(invokeNode.GetSpan(), Rvalue(expression), type);
                                expression.Reset(addressOfExpression);
                            }
                        }
                        else
                        {
                            ArgumentMatch argumentMatch;
                            Result<FunctionSymbol*> conversionResult = GetConversion(
                                argumentType, delegateParameterType, containerScope, boundCompileUnit, boundFunction, argumentMatch, &invokeNode);
                            if (conversionResult.Error())
                            {
                                string reasonMessage = RtmGetErrorMessageWithoutStackTrace(conversionResult.GetErrorId());
                                Result<string> argumentTypeFullNameResult = ToUtf8(argumentType->FullName());
                                if (argumentTypeFullNameResult.Error())
                                {
                                    SetErrorId(argumentTypeFullNameResult.GetErrorId());
                                    return;
                                }
                                string argumentTypeFullName = Rvalue(argumentTypeFullNameResult.Value());
                                Result<string> delegateParameterTypeFullNameResult = ToUtf8(delegateParameterType->FullName());
                                if (delegateParameterTypeFullNameResult.Error())
                                {
                                    SetErrorId(delegateParameterTypeFullNameResult.GetErrorId());
                                    return;
                                }
                                string delegateParameterTypeFullName = Rvalue(delegateParameterTypeFullNameResult.Value());
                                int errorId = MakeError("cannot convert '" + argumentTypeFullName + "' type argument to '" + delegateParameterTypeFullName + "' type parameter: " +
                                    reasonMessage, argument->GetFullSpan(), invokeNode.GetFullSpan());
                                SetErrorId(errorId);
                                return;
                            }
                            FunctionSymbol* conversionFn = conversionResult.Value();
                            BoundConversion* conversion = new BoundConversion(invokeNode.GetSpan(), Rvalue(expression), conversionFn);
                            expression.Reset(conversion);
                        }
                    }
                    arguments.Add(UniquePtr<BoundExpression>(expression.Release()));
                }
                BoundDelegateCall* delegateCall = new BoundDelegateCall(invokeNode.GetSpan(), delegateTypeSymbol);
                for (UniquePtr<BoundExpression>& argument : arguments)
                {
                    delegateCall->AddArgument(Rvalue(argument));
                }
                LocalVariableSymbol* temporary = null;
                if (delegateTypeSymbol->ReturnsClassInterfaceOrClassDelegateByValue())
                {
                    TypeSymbol* type = delegateTypeSymbol->ReturnType();
                    if (type->IsClassTemplateSpecializationSymbol())
                    {
                        ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type);
                        if (!specialization->IsBound())
                        {
                            Result<bool> result = boundCompileUnit->GetClassTemplateRepository()->BindClassTemplateSpecialization(specialization, containerScope, &invokeNode);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                        }
                    }
                    Result<LocalVariableSymbol*> temporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(invokeNode.GetSpan(), type, context);
                    if (temporaryResult.Error())
                    {
                        SetErrorId(temporaryResult.GetErrorId());
                        return;
                    }
                    temporary = temporaryResult.Value();
                    Result<TypeSymbol*> ptrTypeResult = type->AddPointer(context);
                    if (ptrTypeResult.Error())
                    {
                        SetErrorId(ptrTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* ptrType = ptrTypeResult.Value();
                    delegateCall->AddArgument(UniquePtr<BoundExpression>(new BoundAddressOfExpression(invokeNode.GetSpan(),
                        UniquePtr<BoundExpression>(new BoundLocalVariable(invokeNode.GetSpan(), temporary)), ptrType)));
                    if (type->IsClassTypeSymbol())
                    {
                        ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type);
                        if (classType->Destructor() != null)
                        {
                            UniquePtr<BoundFunctionCall> destructorCall(new BoundFunctionCall(invokeNode.GetSpan(), classType->Destructor()));
                            destructorCall->AddArgument(UniquePtr<BoundExpression>(delegateCall->Arguments().Back()->Clone()));
                            Result<bool> result = boundFunction->AddTemporaryDestructorCall(Rvalue(destructorCall), boundFunction, containerScope, &invokeNode);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                        }
                    }
                }
                expression.Reset(delegateCall);
                if (temporary != null)
                {
                    expression.Reset(new BoundConstructAndReturnTemporaryExpression(invokeNode.GetSpan(), Rvalue(expression),
                        UniquePtr<BoundExpression>(new BoundLocalVariable(invokeNode.GetSpan(), temporary))));
                    expression->SetFlag(BoundExpressionFlags.bindToRvalueReference);
                }
                return;
            }
            else if (plainExpressionType->IsClassDelegateTypeSymbol())
            {
                TypeSymbol* type = expression->Type();
                if (type->IsReferenceType())
                {
                    Result<TypeSymbol*> nonRefTypeResult = type->RemoveReference(context);
                    if (nonRefTypeResult.Error())
                    {
                        SetErrorId(nonRefTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* nonRefType = nonRefTypeResult.Value();
                    Result<TypeSymbol*> ptrTypeResult = nonRefType->AddPointer(context);
                    if (ptrTypeResult.Error())
                    {
                        SetErrorId(ptrTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* ptrType = ptrTypeResult.Value();
                    arguments.Add(UniquePtr<BoundExpression>(new BoundReferenceToPointerExpression(invokeNode.GetSpan(), Rvalue(expression), ptrType)));
                }
                else
                {
                    Result<TypeSymbol*> ptrTypeResult = type->AddPointer(context);
                    if (ptrTypeResult.Error())
                    {
                        SetErrorId(ptrTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* ptrType = ptrTypeResult.Value();
                    arguments.Add(UniquePtr<BoundExpression>(new BoundAddressOfExpression(invokeNode.GetSpan(), Rvalue(expression), ptrType)));
                }
                ClassDelegateTypeSymbol* classDelegateTypeSymbol = cast<ClassDelegateTypeSymbol*>(type->BaseType());
                int n = invokeNode.Arguments().Count();
                if (n != classDelegateTypeSymbol->Arity())
                {
                    Result<string> classDelegateTypeSymbolFullNameResult = ToUtf8(classDelegateTypeSymbol->FullName());
                    if (classDelegateTypeSymbolFullNameResult.Error())
                    {
                        SetErrorId(classDelegateTypeSymbolFullNameResult.GetErrorId());
                        return;
                    }
                    string classDelegateTypeSymbolFullName = Rvalue(classDelegateTypeSymbolFullNameResult.Value());
                    int errorId = MakeError("wrong number of arguments for calling delegate type'" + classDelegateTypeSymbolFullName + "'", invokeNode.GetFullSpan());
                    SetErrorId(errorId);
                    return;
                }
                for (int i = 0; i < n; ++i)
                {
                    TypeSymbol* classDelegateParameterType = classDelegateTypeSymbol->Parameters()[i]->Type();
                    Node* argument = invokeNode.Arguments()[i];
                    argument->Accept(*this);
                    if (Error()) return;
                    TypeSymbol* argumentType = expression->Type();
                    if (!TypesEqual(argumentType, classDelegateParameterType))
                    {
                        Result<TypeSymbol*> argumentPlainTypeResult = argumentType->PlainType(context);
                        if (argumentPlainTypeResult.Error())
                        {
                            SetErrorId(argumentPlainTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* argumentPlainType = argumentPlainTypeResult.Value();
                        Result<TypeSymbol*> classDelegatePlainTypeResult = classDelegateParameterType->PlainType(context);
                        if (classDelegatePlainTypeResult.Error())
                        {
                            SetErrorId(classDelegatePlainTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* classDelegatePlainType = classDelegatePlainTypeResult.Value();
                        if (TypesEqual(argumentPlainType, classDelegatePlainType))
                        {
                            if (argumentType->IsReferenceType() && !classDelegateParameterType->IsReferenceType())
                            {
                                Result<TypeSymbol*> nonRefTypeResult = argumentType->RemoveReference(context);
                                if (nonRefTypeResult.Error())
                                {
                                    SetErrorId(nonRefTypeResult.GetErrorId());
                                    return;
                                }
                                TypeSymbol* type = nonRefTypeResult.Value();
                                BoundDereferenceExpression* dereferenceExpression = new BoundDereferenceExpression(invokeNode.GetSpan(), Rvalue(expression), type);
                                expression.Reset(dereferenceExpression);
                            }
                            else if (!argumentType->IsReferenceType() && classDelegateParameterType->IsReferenceType())
                            {
                                Result<TypeSymbol*> lvalueRefTypeResult = argumentType->AddLvalueReference(context);
                                if (lvalueRefTypeResult.Error())
                                {
                                    SetErrorId(lvalueRefTypeResult.GetErrorId());
                                    return;
                                }
                                TypeSymbol* type = lvalueRefTypeResult.Value();
                                BoundAddressOfExpression* addressOfExpression = new BoundAddressOfExpression(invokeNode.GetSpan(), Rvalue(expression), type);
                                expression.Reset(addressOfExpression);
                            }
                        }
                        else
                        {
                            ArgumentMatch argumentMatch;
                            Result<FunctionSymbol*> conversionResult = GetConversion(argumentType, classDelegateParameterType, containerScope, boundCompileUnit, boundFunction,
                                argumentMatch, &invokeNode);
                            if (conversionResult.Error())
                            {
                                string reasonMessage = RtmGetErrorMessageWithoutStackTrace(conversionResult.GetErrorId());
                                Result<string> argumentTypeFullNameResult = ToUtf8(argumentType->FullName());
                                if (argumentTypeFullNameResult.Error())
                                {
                                    SetErrorId(argumentTypeFullNameResult.GetErrorId());
                                    return;
                                }
                                string argumentTypeFullName = Rvalue(argumentTypeFullNameResult.Value());
                                Result<string> classDelegateParameterTypeFullNameResult = ToUtf8(classDelegateParameterType->FullName());
                                if (classDelegateParameterTypeFullNameResult.Error())
                                {
                                    SetErrorId(classDelegateParameterTypeFullNameResult.GetErrorId());
                                    return;
                                }
                                string classDelegateParameterTypeFullName = Rvalue(classDelegateParameterTypeFullNameResult.Value());
                                int errorId = MakeError("cannot convert '" + argumentTypeFullName + "' type argument to '" + classDelegateParameterTypeFullName +
                                    "' type parameter: " + reasonMessage, argument->GetFullSpan(), invokeNode.GetFullSpan());
                                SetErrorId(errorId);
                                return;
                            }
                            FunctionSymbol* conversionFn = conversionResult.Value();
                            BoundConversion* conversion = new BoundConversion(invokeNode.GetSpan(), Rvalue(expression), conversionFn);
                            expression.Reset(conversion);
                        }
                    }
                    arguments.Add(UniquePtr<BoundExpression>(expression.Release()));
                }
                BoundClassDelegateCall* classDelegateCall = new BoundClassDelegateCall(invokeNode.GetSpan(), classDelegateTypeSymbol);
                for (UniquePtr<BoundExpression>& argument : arguments)
                {
                    classDelegateCall->AddArgument(Rvalue(argument));
                }
                LocalVariableSymbol* temporary = null;
                if (classDelegateTypeSymbol->ReturnsClassInterfaceOrClassDelegateByValue())
                {
                    TypeSymbol* type = classDelegateTypeSymbol->ReturnType();
                    if (type->IsClassTemplateSpecializationSymbol())
                    {
                        ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type);
                        if (!specialization->IsBound())
                        {
                            Result<bool> result = boundCompileUnit->GetClassTemplateRepository()->BindClassTemplateSpecialization(
                                specialization, containerScope, &invokeNode);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                        }
                    }
                    Result<LocalVariableSymbol*> temporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(invokeNode.GetSpan(), type, context);
                    if (temporaryResult.Error())
                    {
                        SetErrorId(temporaryResult.GetErrorId());
                        return;
                    }
                    temporary = temporaryResult.Value();
                    Result<TypeSymbol*> ptrTypeResult = type->AddPointer(context);
                    if (ptrTypeResult.Error())
                    {
                        SetErrorId(ptrTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* ptrType = ptrTypeResult.Value();
                    classDelegateCall->AddArgument(UniquePtr<BoundExpression>(new BoundAddressOfExpression(invokeNode.GetSpan(),
                        UniquePtr<BoundExpression>(new BoundLocalVariable(invokeNode.GetSpan(), temporary)), ptrType)));
                    if (type->IsClassTypeSymbol())
                    {
                        ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type);
                        if (classType->Destructor() != null)
                        {
                            UniquePtr<BoundFunctionCall> destructorCall(new BoundFunctionCall(invokeNode.GetSpan(), classType->Destructor()));
                            destructorCall->AddArgument(UniquePtr<BoundExpression>(classDelegateCall->Arguments().Back()->Clone()));
                            Result<bool> result = boundFunction->AddTemporaryDestructorCall(Rvalue(destructorCall), boundFunction, containerScope, &invokeNode);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                        }
                    }
                }
                expression.Reset(classDelegateCall);
                if (temporary != null)
                {
                    expression.Reset(new BoundConstructAndReturnTemporaryExpression(invokeNode.GetSpan(), Rvalue(expression),
                        UniquePtr<BoundExpression>(new BoundLocalVariable(invokeNode.GetSpan(), temporary))));
                    expression->SetFlag(BoundExpressionFlags.bindToRvalueReference);
                }
                return;
            }
            else
            {
                int errorId = MakeError("invoke cannot be applied to this type of expression", invokeNode.Subject()->GetFullSpan());
                SetErrorId(errorId);
                return;
            }
            int n = cast<int>(invokeNode.Arguments().Count());
            for (int i = 0; i < n; ++i)
            {
                Node* argument = invokeNode.Arguments()[i];
                argument->Accept(*this);
                if (Error()) return;
                if (!expression->Type()->IsFunctionGroupTypeSymbol() && !scopeQualified)
                {
                    Result<ContainerScope*> scopeResult = expression->Type()->BaseType()->ClassInterfaceEnumDelegateOrNsScope(context);
                    if (scopeResult.Error())
                    {
                        SetErrorId(scopeResult.GetErrorId());
                        return;
                    }
                    ContainerScope* scope = scopeResult.Value();
                    functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, scope));
                }
                arguments.Add(Rvalue(expression));
            }
            if (!scopeQualified)
            {
                functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
            }
            if (!arguments.IsEmpty() && arguments[0]->GetFlag(BoundExpressionFlags.argIsExplicitThisOrBasePtr))
            {
                argIsExplicitThisOrBasePtr = true;
            }
            Result<UniquePtr<BoundFunctionCall>> firstFunctionCallResult = ResolveOverload(groupName, containerScope, functionScopeLookups, arguments, boundCompileUnit,
                boundFunction, &invokeNode, OverloadResolutionFlags.none, templateArgumentTypes);
            Result<UniquePtr<BoundFunctionCall>> secondFunctionCallResult(UniquePtr<BoundFunctionCall>());
            Result<UniquePtr<BoundFunctionCall>> thirdFunctionCallResult(UniquePtr<BoundFunctionCall>());
            if (firstFunctionCallResult.Error())
            {
                ParameterSymbol* thisParam = boundFunction->GetFunctionSymbol()->GetThisParam();
                bool thisParamInserted = false;
                if (thisParam != null)
                {
                    BoundParameter* boundThisParam = new BoundParameter(invokeNode.GetSpan(), thisParam);
                    arguments.Insert(arguments.Begin(), UniquePtr<BoundExpression>(boundThisParam));
                    thisParamInserted = true;
                    Result<ContainerScope*> scopeResult = thisParam->Type()->BaseType()->ClassInterfaceEnumDelegateOrNsScope(context);
                    if (scopeResult.Error())
                    {
                        SetErrorId(scopeResult.GetErrorId());
                        return;
                    }
                    ContainerScope* scope = scopeResult.Value();
                    functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base, scope));
                    secondFunctionCallResult = ResolveOverload(groupName, containerScope, functionScopeLookups, arguments, boundCompileUnit,
                        boundFunction, &invokeNode, OverloadResolutionFlags.none, templateArgumentTypes);
                }
                if (secondFunctionCallResult.Error() || !thisParamInserted)
                {
                    if (thisParamInserted)
                    {
                        arguments.Remove(arguments.Begin());
                    }
                    if (!arguments.IsEmpty())
                    {
                        arguments.Remove(arguments.Begin());
                    }
                    thirdFunctionCallResult = ResolveOverload(groupName, containerScope, functionScopeLookups, arguments, boundCompileUnit,
                        boundFunction, &invokeNode, OverloadResolutionFlags.none, templateArgumentTypes);
                }
            }
            UniquePtr<BoundFunctionCall> functionCall;
            if (!thirdFunctionCallResult.Value().IsNull())
            {
                functionCall = Rvalue(thirdFunctionCallResult.Value());
            }
            else if (!secondFunctionCallResult.Value().IsNull())
            {
                functionCall = Rvalue(secondFunctionCallResult.Value());
            }
            else if (!firstFunctionCallResult.Value().IsNull())
            {
                functionCall = Rvalue(firstFunctionCallResult.Value());
            }
            if (!functionCall.IsNull())
            {
                Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), functionCall->GetFunctionSymbol());
                if (result.Error())
                {
                    SetErrorId(result.GetErrorId());
                    return;
                }
                FunctionSymbol* functionSymbol = functionCall->GetFunctionSymbol();
                if (functionSymbol->IsMemberFunctionSymbol() && !functionSymbol->IsStatic() && functionSymbol->IsVirtualAbstractOrOverride())
                {
                    if (argIsExplicitThisOrBasePtr)
                    {
                        if (functionSymbol->IsAbstract())
                        {
                            int errorId = MakeError("cannot call abstract member function", invokeNode.GetFullSpan(), functionSymbol->FullSpan());
                            SetErrorId(errorId);
                            return;
                        }
                    }
                    else
                    {
                        functionCall->SetFlag(BoundExpressionFlags.virtualCall);
                    }
                }
                if (functionSymbol->ReturnsClassInterfaceOrClassDelegateByValue())
                {
                    TypeSymbol* type = functionSymbol->ReturnType();
                    if (type->IsClassTemplateSpecializationSymbol())
                    {
                        ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type);
                        if (!specialization->IsBound())
                        {
                            Result<bool> result = boundCompileUnit->GetClassTemplateRepository()->BindClassTemplateSpecialization(specialization, containerScope, &invokeNode);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                        }
                    }
                    Result<LocalVariableSymbol*> temporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(invokeNode.GetSpan(), type, context);
                    if (temporaryResult.Error())
                    {
                        SetErrorId(temporaryResult.GetErrorId());
                        return;
                    }
                    temporary = temporaryResult.Value();
                    Result<TypeSymbol*> ptrTypeResult = type->AddPointer(context);
                    if (ptrTypeResult.Error())
                    {
                        SetErrorId(ptrTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* ptrType = ptrTypeResult.Value();
                    functionCall->AddArgument(UniquePtr<BoundExpression>(new BoundAddressOfExpression(invokeNode.GetSpan(), UniquePtr<BoundExpression>(
                        new BoundLocalVariable(invokeNode.GetSpan(), temporary)), ptrType)));
                    if (type->IsClassTypeSymbol())
                    {
                        ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type);
                        if (classType->Destructor() != null)
                        {
                            UniquePtr<BoundFunctionCall> destructorCall(new BoundFunctionCall(invokeNode.GetSpan(), classType->Destructor()));
                            destructorCall->AddArgument(UniquePtr<BoundExpression>(functionCall->Arguments().Back()->Clone()));
                            Result<bool> result = boundFunction->AddTemporaryDestructorCall(Rvalue(destructorCall), boundFunction, containerScope, &invokeNode);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                        }
                    }
                }
                expression.Reset(functionCall.Release());
                if (temporary != null)
                {
                    expression.Reset(new BoundConstructAndReturnTemporaryExpression(invokeNode.GetSpan(), Rvalue(expression), UniquePtr<BoundExpression>(
                        new BoundLocalVariable(invokeNode.GetSpan(), temporary))));
                    expression->SetFlag(BoundExpressionFlags.bindToRvalueReference);
                }
                if (functionSymbol->IsConstExpr())
                {
                    TypeSymbol* returnType = functionSymbol->ReturnType();
                    if (returnType != null && !returnType->IsVoidTypeSymbol())
                    {
                        Result<UniquePtr<Value>> valueResult = Evaluate(&invokeNode, returnType, containerScope, boundCompileUnit, boundFunction);
                        if (!valueResult.Error())
                        {
                            Value* value = valueResult.Value().Get();
                            if (value != null)
                            {
                                Result<TypeSymbol*> typeResult = value->Type(symbolTable, context);
                                if (!typeResult.Error())
                                {
                                    TypeSymbol* type = typeResult.Value();
                                    BoundLiteral* literal = new BoundLiteral(invokeNode.GetSpan(), Rvalue(valueResult.Value()), type);
                                    expression.Reset(literal);
                                }
                            }
                        }
                    }
                }
                else if (functionSymbol->IsCompileTimePrimitiveFunction())
                {
                    TypeSymbol* returnType = functionSymbol->ReturnType();
                    if (returnType != null && !returnType->IsVoidTypeSymbol())
                    {
                        Result<UniquePtr<Value>> valueResult = Evaluate(&invokeNode, returnType, containerScope, boundCompileUnit, boundFunction);
                        if (!valueResult.Error())
                        {
                            Value* value = valueResult.Value().Get();
                            if (value != null)
                            {
                                Result<TypeSymbol*> typeResult = value->Type(symbolTable, context);
                                if (!typeResult.Error())
                                {
                                    TypeSymbol* type = typeResult.Value();
                                    BoundLiteral* literal = new BoundLiteral(invokeNode.GetSpan(), Rvalue(valueResult.Value()), type);
                                    expression.Reset(literal);
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                string errorMessage;
                if (firstFunctionCallResult.Error())
                {
                    errorMessage = RtmGetErrorMessageWithoutStackTrace(firstFunctionCallResult.GetErrorId());
                }
                if (secondFunctionCallResult.Error())
                {
                    if (!errorMessage.IsEmpty())
                    {
                        errorMessage.Append("\n");
                    }
                    errorMessage.Append(RtmGetErrorMessageWithoutStackTrace(secondFunctionCallResult.GetErrorId()));
                }
                if (thirdFunctionCallResult.Error())
                {
                    if (!errorMessage.IsEmpty())
                    {
                        errorMessage.Append("\n");
                    }
                    errorMessage.Append(RtmGetErrorMessageWithoutStackTrace(thirdFunctionCallResult.GetErrorId()));
                }
                int errorId = AllocateError(errorMessage);
                SetErrorId(errorId);
            }
        }
        public override void Visit(SizeOfNode& sizeOfNode)
        {
            sizeOfNode.Expression()->Accept(*this);
            if (Error()) return;
            if (expression->IsBoundTypeExpression() && expression->Type()->IsClassGroupSymbol())
            {
                ClassGroupSymbol* classGroup = cast<ClassGroupSymbol*>(expression->Type());
                ClassTypeSymbol* classTypeSymbol = classGroup->GetClass(0);
                if (classTypeSymbol != null)
                {
                    expression.Reset(new BoundTypeExpression(sizeOfNode.GetSpan(), classTypeSymbol));
                }
                else
                {
                    Result<string> classGroupFullNameResult = ToUtf8(classGroup->FullName());
                    if (classGroupFullNameResult.Error())
                    {
                        SetErrorId(classGroupFullNameResult.GetErrorId());
                        return;
                    }
                    string classGroupFullName = Rvalue(classGroupFullNameResult.Value());
                    int errorId = MakeError("nontemplate class not found from class group '" + classGroupFullName + "'", sizeOfNode.GetFullSpan(), classGroup->FullSpan());
                    SetErrorId(errorId);
                    return;
                }
            }
            Result<TypeSymbol*> longTypeResult = symbolTable->GetTypeByName(u"long");
            if (longTypeResult.Error())
            {
                SetErrorId(longTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* longType = longTypeResult.Value();
            Result<TypeSymbol*> ptrTypeResult = expression->Type()->AddPointer(context);
            if (ptrTypeResult.Error())
            {
                SetErrorId(ptrTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* ptrType = ptrTypeResult.Value();
            expression.Reset(new BoundSizeOfExpression(sizeOfNode.GetSpan(), longType, ptrType));
        }
        public override void Visit(TypeNameNode& typeNameNode)
        {
            bool staticTypeName = typeNameNode.Static();
            Result<UniquePtr<BoundExpression>> exprResult = BindExpression(typeNameNode.Expression(), boundCompileUnit, boundFunction, containerScope, statementBinder,
                false, false, true);
            if (exprResult.Error())
            {
                SetErrorId(exprResult.GetErrorId());
                return;
            }
            UniquePtr<BoundExpression> expr = Rvalue(exprResult.Value());
            TypeSymbol* type = expr->Type();
            if (type->IsClassGroupSymbol())
            {
                ClassGroupSymbol* classGroup = cast<ClassGroupSymbol*>(type);
                ClassTypeSymbol* classTypeSymbol = classGroup->GetClass(0);
                if (classTypeSymbol == null)
                {
                    Result<string> classGroupFullNameResult = ToUtf8(classGroup->FullName());
                    if (classGroupFullNameResult.Error())
                    {
                        SetErrorId(classGroupFullNameResult.GetErrorId());
                        return;
                    }
                    string classGroupFullName = Rvalue(classGroupFullNameResult.Value());
                    int errorId = MakeError("nontemplate class not found from class group '" + classGroupFullName + "'", typeNameNode.GetFullSpan(), classGroup->FullSpan());
                    SetErrorId(errorId);
                    return;
                }
                expr.Reset(new BoundTypeExpression(typeNameNode.GetSpan(), classTypeSymbol));
                type = classTypeSymbol;
                staticTypeName = true;
            }
            Result<TypeSymbol*> charTypeResult = symbolTable->GetTypeByName(u"char");
            if (charTypeResult.Error())
            {
                SetErrorId(charTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* charType = charTypeResult.Value();
            Result<TypeSymbol*> constTypeResult = charType->AddConst(context);
            if (constTypeResult.Error())
            {
                SetErrorId(constTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* constType = constTypeResult.Value();
            Result<TypeSymbol*> ptrTypeResult = constType->AddPointer(context);
            if (ptrTypeResult.Error())
            {
                SetErrorId(ptrTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* constCharPtrType = ptrTypeResult.Value();
            Result<TypeSymbol*> plainExpressionTypeResult = expr->Type()->PlainType(context);
            if (plainExpressionTypeResult.Error())
            {
                SetErrorId(plainExpressionTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* plainExpressionType = plainExpressionTypeResult.Value();
            if (plainExpressionType->IsClassTypeSymbol())
            {
                ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(expr->Type()->BaseType());
                if (!staticTypeName && classType->IsPolymorphic())
                {
                    if (expr->IsDerefenceExpression())
                    {
                        BoundDereferenceExpression* derefExpr = cast<BoundDereferenceExpression*>(expr.Get());
                        expr.Reset(derefExpr->ReleaseSubject());
                    }
                    else
                    {
                        Result<TypeSymbol*> ptrTypeResult = expr->Type()->AddPointer(context);
                        if (ptrTypeResult.Error())
                        {
                            SetErrorId(ptrTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* ptrType = ptrTypeResult.Value();
                        expr.Reset(new BoundAddressOfExpression(typeNameNode.GetSpan(), Rvalue(expr), ptrType));
                    }
                    List<FunctionScopeLookup> functionScopeLookups;
                    functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
                    functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
                    List<UniquePtr<BoundExpression>> arguments;
                    Result<TypeSymbol*> voidTypeResult = symbolTable->GetTypeByName(u"void");
                    if (voidTypeResult.Error())
                    {
                        SetErrorId(voidTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* voidType = voidTypeResult.Value();
                    Result<TypeSymbol*> voidPtrTypeResult = voidType->AddPointer(context);
                    if (voidPtrTypeResult.Error())
                    {
                        SetErrorId(voidPtrTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* voidPtrType = voidPtrTypeResult.Value();
                    arguments.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(typeNameNode.GetSpan(), voidPtrType)));
                    Result<UniquePtr<BoundFunctionCall>> rtmClassNameFunctionCall = ResolveOverload(u"RtmClassName", containerScope, functionScopeLookups, arguments,
                        boundCompileUnit, boundFunction, &typeNameNode);
                    if (rtmClassNameFunctionCall.Error())
                    {
                        SetErrorId(rtmClassNameFunctionCall.GetErrorId());
                        return;
                    }
                    FunctionSymbol* rtmClassNameFunction = rtmClassNameFunctionCall.Value()->GetFunctionSymbol();
                    expression.Reset(new BoundTypeNameExpression(typeNameNode.GetSpan(), Rvalue(expr), rtmClassNameFunction));
                }
                else
                {
                    Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                    if (classTypeFullNameResult.Error())
                    {
                        SetErrorId(classTypeFullNameResult.GetErrorId());
                        return;
                    }
                    string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                    expression.Reset(new BoundLiteral(typeNameNode.GetSpan(),
                        UniquePtr<Value>(new StringValue(typeNameNode.GetSpan(), boundCompileUnit->Install(classTypeFullName),
                        classTypeFullName)), constCharPtrType));
                }
            }
            else
            {
                Result<string> exprTypeFullNameResult = ToUtf8(expr->Type()->FullName());
                if (exprTypeFullNameResult.Error())
                {
                    SetErrorId(exprTypeFullNameResult.GetErrorId());
                    return;
                }
                string exprTypeFullName = Rvalue(exprTypeFullNameResult.Value());
                expression.Reset(new BoundLiteral(typeNameNode.GetSpan(),
                    UniquePtr<Value>(new StringValue(typeNameNode.GetSpan(), boundCompileUnit->Install(exprTypeFullName),
                    exprTypeFullName)), constCharPtrType));
            }
        }
        public override void Visit(CastNode& castNode)
        {
            Result<TypeSymbol*> targetTypeResult = ResolveType(castNode.TargetTypeExpr(), boundCompileUnit, containerScope);
            if (targetTypeResult.Error())
            {
                SetErrorId(targetTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* targetType = targetTypeResult.Value();
            castNode.SourceExpr()->Accept(*this);
            if (Error()) return;
            TypeSymbol* sourceType = expression->Type();
            switch (targetType->GetValueKind())
            {
                case ValueKind.floatValue:
                {
                    switch (sourceType->GetValueKind())
                    {
                        case ValueKind.boolValue:
                        {
                            CloneContext cloneContext;
                            UniquePtr<Node> expr(new NotEqualNode(castNode.GetSpan(), castNode.FileIndex(), castNode.SourceExpr()->Clone(cloneContext),
                                new FloatLiteralNode(castNode.GetSpan(), castNode.FileIndex(), 0)));
                            Result<UniquePtr<BoundExpression>> result = BindExpression(expr.Get(), boundCompileUnit, boundFunction, containerScope, statementBinder);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                            expression = Rvalue(result.Value());
                            return;
                        }
                        case ValueKind.sbyteValue:
                        case ValueKind.byteValue:
                        case ValueKind.shortValue:
                        case ValueKind.ushortValue:
                        case ValueKind.charValue:
                        case ValueKind.wcharValue:
                        case ValueKind.ucharValue:
                        {
                            CloneContext cloneContext;
                            UniquePtr<Node> expr(new CastNode(castNode.GetSpan(), castNode.FileIndex(), castNode.TargetTypeExpr()->Clone(cloneContext),
                                new CastNode(castNode.GetSpan(), castNode.FileIndex(),
                                    new IntNode(castNode.GetSpan(), castNode.FileIndex()),
                                    castNode.SourceExpr()->Clone(cloneContext))));
                            Result<UniquePtr<BoundExpression>> result = BindExpression(expr.Get(), boundCompileUnit, boundFunction, containerScope, statementBinder);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                            expression = Rvalue(result.Value());
                            return;
                        }
                    }
                    break;
                }
                case ValueKind.doubleValue:
                {
                    switch (sourceType->GetValueKind())
                    {
                        case ValueKind.boolValue:
                        {
                            CloneContext cloneContext;
                            UniquePtr<Node> expr(new NotEqualNode(castNode.GetSpan(), castNode.FileIndex(), castNode.SourceExpr()->Clone(cloneContext),
                                new DoubleLiteralNode(castNode.GetSpan(), castNode.FileIndex(), 0)));
                            Result<UniquePtr<BoundExpression>> result = BindExpression(expr.Get(), boundCompileUnit, boundFunction, containerScope, statementBinder);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                            expression = Rvalue(result.Value());
                            return;
                        }
                        case ValueKind.sbyteValue:
                        case ValueKind.byteValue:
                        case ValueKind.shortValue:
                        case ValueKind.ushortValue:
                        case ValueKind.intValue:
                        case ValueKind.uintValue:
                        case ValueKind.charValue:
                        case ValueKind.wcharValue:
                        case ValueKind.ucharValue:
                        {
                            CloneContext cloneContext;
                            UniquePtr<Node> expr(new CastNode(castNode.GetSpan(), castNode.FileIndex(), castNode.TargetTypeExpr()->Clone(cloneContext),
                                new CastNode(castNode.GetSpan(), castNode.FileIndex(),
                                    new LongNode(castNode.GetSpan(), castNode.FileIndex()),
                                    castNode.SourceExpr()->Clone(cloneContext))));
                            Result<UniquePtr<BoundExpression>> result = BindExpression(expr.Get(), boundCompileUnit, boundFunction, containerScope, statementBinder);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                            expression = Rvalue(result.Value());
                            return;
                        }
                    }
                    break;
                }
            }
            List<UniquePtr<BoundExpression>> targetExprArgs;
            targetExprArgs.Add(UniquePtr<BoundExpression>(new BoundTypeExpression(castNode.GetSpan(), targetType)));
            List<FunctionScopeLookup> functionScopeLookups;
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
            Result<ContainerScope*> scopeResult = targetType->BaseType()->ClassInterfaceEnumDelegateOrNsScope(context);
            if (scopeResult.Error())
            {
                SetErrorId(scopeResult.GetErrorId());
                return;
            }
            ContainerScope* scope = scopeResult.Value();
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, scope));
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
            Result<UniquePtr<BoundFunctionCall>> castFunctionCallResult = ResolveOverload(u"@return", containerScope, functionScopeLookups,
                targetExprArgs, boundCompileUnit, boundFunction, &castNode);
            if (castFunctionCallResult.Error())
            {
                SetErrorId(castFunctionCallResult.GetErrorId());
                return;
            }
            UniquePtr<BoundFunctionCall> castFunctionCall = Rvalue(castFunctionCallResult.Value());
            List<UniquePtr<BoundExpression>> castArguments;
            castArguments.Add(Rvalue(expression));
            FunctionMatch functionMatch(castFunctionCall->GetFunctionSymbol());
            Result<bool> conversionFoundResult = FindConversions(boundCompileUnit, castFunctionCall->GetFunctionSymbol(), castArguments, functionMatch,
                ConversionType.explicit_, containerScope, boundFunction, &castNode);
            if (conversionFoundResult.Error())
            {
                SetErrorId(conversionFoundResult.GetErrorId());
                return;
            }
            bool conversionFound = conversionFoundResult.Value();
            if (conversionFound)
            {
                #assert(!functionMatch.ArgumentMatches().IsEmpty());
                const ArgumentMatch& argumentMatch = functionMatch.ArgumentMatches()[0];
                if (argumentMatch.PreReferenceFlags() != OperationFlags.none)
                {
                    if (argumentMatch.PreReferenceFlags() == OperationFlags.addr)
                    {
                        Result<TypeSymbol*> refTypeResult = castArguments[0]->Type()->AddLvalueReference(context);
                        if (refTypeResult.Error())
                        {
                            SetErrorId(refTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* type = refTypeResult.Value();
                        BoundAddressOfExpression* addressOfExpression = new BoundAddressOfExpression(castNode.GetSpan(), Rvalue(castArguments[0]), type);
                        castArguments[0].Reset(addressOfExpression);
                    }
                    else if (argumentMatch.PreReferenceFlags() == OperationFlags.deref)
                    {
                        Result<TypeSymbol*> nonRefTypeResult = castArguments[0]->Type()->RemoveReference(context);
                        if (nonRefTypeResult.Error())
                        {
                            SetErrorId(nonRefTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* type = nonRefTypeResult.Value();
                        BoundDereferenceExpression* dereferenceExpression = new BoundDereferenceExpression(castNode.GetSpan(), Rvalue(castArguments[0]), type);
                        castArguments[0].Reset(dereferenceExpression);
                    }
                }
                FunctionSymbol* conversionFn = argumentMatch.ConversionFn();
                if (conversionFn != null)
                {
                    if (conversionFn->IsConstructorSymbol())
                    {
                        BoundFunctionCall* constructorCall = new BoundFunctionCall(castNode.GetSpan(), conversionFn);
                        if (conversionFn->ConversionTargetType()->IsClassTemplateSpecializationSymbol())
                        {
                            ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(conversionFn->ConversionTargetType());
                            if (!specialization->IsBound())
                            {
                                Result<bool> result = boundCompileUnit->GetClassTemplateRepository()->BindClassTemplateSpecialization(specialization, containerScope, &castNode);
                                if (result.Error())
                                {
                                    SetErrorId(result.GetErrorId());
                                    return;
                                }
                            }
                        }
                        Result<LocalVariableSymbol*> temporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(
                            conversionFn->Span(), conversionFn->ConversionTargetType(), context);
                        if (temporaryResult.Error())
                        {
                            SetErrorId(temporaryResult.GetErrorId());
                            return;
                        }
                        LocalVariableSymbol* temporary = temporaryResult.Value();
                        Result<TypeSymbol*> ptrTypeResult = conversionFn->ConversionTargetType()->AddPointer(context);
                        if (ptrTypeResult.Error())
                        {
                            SetErrorId(ptrTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* ptrType = ptrTypeResult.Value();
                        constructorCall->AddArgument(UniquePtr<BoundExpression>(new BoundAddressOfExpression(castNode.GetSpan(), UniquePtr<BoundExpression>(
                            new BoundLocalVariable(castNode.GetSpan(), temporary)), ptrType)));
                        TypeSymbol* conversionTargetType = conversionFn->ConversionTargetType();
                        if (conversionTargetType->IsClassTypeSymbol())
                        {
                            ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(conversionTargetType);
                            if (classType->Destructor() != null)
                            {
                                UniquePtr<BoundFunctionCall> destructorCall(new BoundFunctionCall(castNode.GetSpan(), classType->Destructor()));
                                destructorCall->AddArgument(UniquePtr<BoundExpression>(constructorCall->Arguments()[0]->Clone()));
                                Result<bool> result = boundFunction->AddTemporaryDestructorCall(Rvalue(destructorCall), boundFunction, containerScope, &castNode);
                                if (result.Error())
                                {
                                    SetErrorId(result.GetErrorId());
                                    return;
                                }
                            }
                        }
                        constructorCall->AddArgument(Rvalue(castArguments[0]));
                        BoundConstructAndReturnTemporaryExpression* conversion = new BoundConstructAndReturnTemporaryExpression(castNode.GetSpan(),
                            UniquePtr<BoundExpression>(constructorCall),
                            UniquePtr<BoundExpression>(new BoundLocalVariable(castNode.GetSpan(), temporary)));
                        castArguments[0].Reset(conversion);
                    }
                    else
                    {
                        castArguments[0].Reset(new BoundConversion(castNode.GetSpan(), UniquePtr<BoundExpression>(castArguments[0].Release()), conversionFn));
                    }
                }
                if (argumentMatch.PostReferenceFlags() != OperationFlags.none)
                {
                    if (argumentMatch.PostReferenceFlags() == OperationFlags.addr)
                    {
                        Result<TypeSymbol*> refTypeResult = castArguments[0]->Type()->AddLvalueReference(context);
                        if (refTypeResult.Error())
                        {
                            SetErrorId(refTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* type = refTypeResult.Value();
                        BoundAddressOfExpression* addressOfExpression = new BoundAddressOfExpression(castNode.GetSpan(), Rvalue(castArguments[0]), type);
                        castArguments[0].Reset(addressOfExpression);
                    }
                    else if (argumentMatch.PostReferenceFlags() == OperationFlags.deref)
                    {
                        Result<TypeSymbol*> nonRefTypeResult = castArguments[0]->Type()->RemoveReference(context);
                        if (nonRefTypeResult.Error())
                        {
                            SetErrorId(nonRefTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* type = nonRefTypeResult.Value();
                        BoundDereferenceExpression* dereferenceExpression = new BoundDereferenceExpression(castNode.GetSpan(), Rvalue(castArguments[0]), type);
                        castArguments[0].Reset(dereferenceExpression);
                    }
                }
                castFunctionCall->SetArguments(Rvalue(castArguments));
            }
            else
            {
                Result<string> castArgFullNameResult = ToUtf8(castArguments[0]->Type()->FullName());
                if (castArgFullNameResult.Error())
                {
                    SetErrorId(castArgFullNameResult.GetErrorId());
                    return;
                }
                string castArgFullName = Rvalue(castArgFullNameResult.Value());
                Result<string> targetTypeFullNameResult = ToUtf8(targetType->FullName());
                if (targetTypeFullNameResult.Error())
                {
                    SetErrorId(targetTypeFullNameResult.GetErrorId());
                    return;
                }
                string targetTypeFullName = Rvalue(targetTypeFullNameResult.Value());
                int errorId = MakeError("no explicit conversion from '" + castArgFullName + "' to '" + targetTypeFullName + "' exists",
                    castNode.GetFullSpan(), boundFunction->GetFunctionSymbol()->FullSpan());
                SetErrorId(errorId);
                return;
            }
            Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), castFunctionCall->GetFunctionSymbol());
            if (result.Error())
            {
                SetErrorId(result.GetErrorId());
                return;
            }
            expression.Reset(castFunctionCall.Release());
        }
        public override void Visit(ConstructNode& constructNode)
        {
            int n = cast<int>(constructNode.Arguments().Count());
            if (n == 0)
            {
                int errorId = MakeError("must supply at least one argument to construct expression", constructNode.GetFullSpan());
                SetErrorId(errorId);
                return;
            }
            TypeSymbol* resultType = null;
            List<UniquePtr<BoundExpression>> arguments;
            for (int i = 0; i < n; ++i)
            {
                Node* argumentNode = constructNode.Arguments()[i];
                if (i == 0)
                {
                    CloneContext cloneContext;
                    CastNode castNode(constructNode.GetSpan(), constructNode.FileIndex(), new PointerNode(constructNode.GetSpan(), constructNode.FileIndex(),
                        constructNode.TypeExpr()->Clone(cloneContext)), argumentNode->Clone(cloneContext));
                    castNode.Accept(*this);
                    if (Error()) return;
                    resultType = expression->Type();
                    if (!resultType->IsPointerType())
                    {
                        int errorId = MakeError("first argument of a construct expression must be of a pointer type", argumentNode->GetFullSpan());
                        SetErrorId(errorId);
                        return;
                    }
                    Result<TypeSymbol*> nonPtrTypeResult = resultType->RemovePointer(context);
                    if (nonPtrTypeResult.Error())
                    {
                        SetErrorId(nonPtrTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* nonPtrType = nonPtrTypeResult.Value();
                    if (!nonPtrType->IsClassTypeSymbol())
                    {
                        expression->SetFlag(BoundExpressionFlags.deref);
                    }
                }
                else
                {
                    argumentNode->Accept(*this);
                    if (Error()) return;
                }
                arguments.Add(Rvalue(expression));
            }
            List<FunctionScopeLookup> functionScopeLookups;
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
            Result<ContainerScope*> scopeResult = resultType->BaseType()->ClassInterfaceEnumDelegateOrNsScope(context);
            if (scopeResult.Error())
            {
                SetErrorId(scopeResult.GetErrorId());
                return;
            }
            ContainerScope* scope = scopeResult.Value();
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, scope));
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
            Result<UniquePtr<BoundFunctionCall>> constructorCallResult = ResolveOverload(u"@constructor", containerScope, functionScopeLookups, arguments,
                boundCompileUnit, boundFunction, &constructNode);
            if (constructorCallResult.Error())
            {
                SetErrorId(constructorCallResult.GetErrorId());
                return;
            }
            UniquePtr<BoundFunctionCall> constructorCall = Rvalue(constructorCallResult.Value());
            expression.Reset(new BoundConstructExpression(constructNode.GetSpan(), UniquePtr<BoundExpression>(constructorCall.Release()), resultType));
        }
        public override void Visit(NewNode& newNode)
        {
            InvokeNode* invokeMemAlloc = new InvokeNode(newNode.GetSpan(), newNode.FileIndex(), new IdentifierNode(newNode.GetSpan(), newNode.FileIndex(), u"RtmMemAlloc"));
            CloneContext cloneContext;
            invokeMemAlloc->AddArgument(new SizeOfNode(newNode.GetSpan(), newNode.FileIndex(), newNode.TypeExpr()->Clone(cloneContext)));
            CastNode castNode(newNode.GetSpan(), newNode.FileIndex(), new PointerNode(newNode.GetSpan(), newNode.FileIndex(),
                newNode.TypeExpr()->Clone(cloneContext)), invokeMemAlloc);
            castNode.Accept(*this);
            if (Error()) return;
            List<UniquePtr<BoundExpression>> arguments;
            TypeSymbol* resultType = expression->Type();
            Result<TypeSymbol*> nonPtrTypeResult = resultType->RemovePointer(context);
            if (nonPtrTypeResult.Error())
            {
                SetErrorId(nonPtrTypeResult.GetErrorId());
                return;
            }
            TypeSymbol* nonPtrType = nonPtrTypeResult.Value();
            if (!nonPtrType->IsClassTypeSymbol())
            {
                expression->SetFlag(BoundExpressionFlags.deref);
            }
            arguments.Add(Rvalue(expression));
            int n = cast<int>(newNode.Arguments().Count());
            for (int i = 0; i < n; ++i)
            {
                newNode.Arguments()[i]->Accept(*this);
                if (Error()) return;
                arguments.Add(Rvalue(expression));
            }
            List<FunctionScopeLookup> functionScopeLookups;
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
            Result<ContainerScope*> scopeResult = nonPtrType->ClassInterfaceEnumDelegateOrNsScope(context);
            if (scopeResult.Error())
            {
                SetErrorId(scopeResult.GetErrorId());
                return;
            }
            ContainerScope* scope = scopeResult.Value();
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, scope));
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
            Result<UniquePtr<BoundFunctionCall>> constructorCallResult = ResolveOverload(u"@constructor", containerScope, functionScopeLookups, arguments,
                boundCompileUnit, boundFunction, &newNode);
            if (constructorCallResult.Error())
            {
                SetErrorId(constructorCallResult.GetErrorId());
                return;
            }
            UniquePtr<BoundFunctionCall> constructorCall = Rvalue(constructorCallResult.Value());
            expression.Reset(new BoundConstructExpression(newNode.GetSpan(), UniquePtr<BoundExpression>(constructorCall.Release()), resultType));
        }
        public override void Visit(ThisNode& thisNode)
        {
            ParameterSymbol* thisParam = boundFunction->GetFunctionSymbol()->GetThisParam();
            if (thisParam != null)
            {
                expression.Reset(new BoundParameter(thisNode.GetSpan(), thisParam));
                expression->SetFlag(BoundExpressionFlags.argIsExplicitThisOrBasePtr);
            }
            else
            {
                int errorId = MakeError("'this' can only be used in member function context", thisNode.GetFullSpan());
                SetErrorId(errorId);
                return;
            }
        }
        public override void Visit(BaseNode& baseNode)
        {
            ParameterSymbol* thisParam = boundFunction->GetFunctionSymbol()->GetThisParam();
            if (thisParam != null)
            {
                TypeSymbol* thisType = thisParam->Type()->BaseType();
                if (thisType->IsClassTypeSymbol())
                {
                    ClassTypeSymbol* thisClassType = cast<ClassTypeSymbol*>(thisType);
                    if (thisClassType->BaseClass() != null)
                    {
                        Result<TypeSymbol*> baseClassPointerTypeResult = thisClassType->BaseClass()->AddPointer(context);
                        if (baseClassPointerTypeResult.Error())
                        {
                            SetErrorId(baseClassPointerTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* basePointerType = baseClassPointerTypeResult.Value();
                        if (thisParam->Type()->IsConstType())
                        {
                            Result<TypeSymbol*> constTypeResult = basePointerType->AddConst(context);
                            if (constTypeResult.Error())
                            {
                                SetErrorId(constTypeResult.GetErrorId());
                                return;
                            }
                            basePointerType = constTypeResult.Value();
                        }
                        ArgumentMatch argumentMatch;
                        Result<FunctionSymbol*> thisAsBaseConversionResult = GetConversion(
                            thisParam->Type(), basePointerType, containerScope, boundCompileUnit, boundFunction, argumentMatch, &baseNode);
                        if (!thisAsBaseConversionResult.Error())
                        {
                            FunctionSymbol* thisAsBaseConversionFunction = thisAsBaseConversionResult.Value();
                            expression.Reset(new BoundConversion(baseNode.GetSpan(), UniquePtr<BoundExpression>(new BoundParameter(
                                baseNode.GetSpan(), thisParam)), thisAsBaseConversionFunction));
                            expression->SetFlag(BoundExpressionFlags.argIsExplicitThisOrBasePtr);
                        }
                        else
                        {
                            Result<string> thisParamTypeFullNameResult = ToUtf8(thisParam->Type()->FullName());
                            if (thisParamTypeFullNameResult.Error())
                            {
                                SetErrorId(thisParamTypeFullNameResult.GetErrorId());
                                return;
                            }
                            string thisParamTypeFullName = Rvalue(thisParamTypeFullNameResult.Value());
                            Result<string> basePointerTypeFullNameResult = ToUtf8(basePointerType->FullName());
                            if (basePointerTypeFullNameResult.Error())
                            {
                                SetErrorId(basePointerTypeFullNameResult.GetErrorId());
                                return;
                            }
                            string basePointerTypeFullName = Rvalue(basePointerTypeFullNameResult.Value());
                            int errorId = MakeError("cannot convert from '" + thisParamTypeFullName + "' to '" + basePointerTypeFullName + "'", baseNode.GetFullSpan());
                            SetErrorId(errorId);
                            return;
                        }
                    }
                    else
                    {
                        Result<string> thisClassTypeFullNameResult = ToUtf8(thisClassType->FullName());
                        if (thisClassTypeFullNameResult.Error())
                        {
                            SetErrorId(thisClassTypeFullNameResult.GetErrorId());
                            return;
                        }
                        string thisClassTypeFullName = Rvalue(thisClassTypeFullNameResult.Value());
                        int errorId = MakeError("class '" + thisClassTypeFullName + "' does not have a base class", baseNode.GetFullSpan());
                        SetErrorId(errorId);
                        return;
                    }
                }
                else
                {
                    int errorId = MakeError("'base' can only be used in member function context", baseNode.GetFullSpan());
                    SetErrorId(errorId);
                    return;
                }
            }
            else
            {
                int errorId = MakeError("'base' can only be used in member function context", baseNode.GetFullSpan());
                SetErrorId(errorId);
                return;
            }
        }
        public override void Visit(ParenthesizedExpressionNode& parenthesizedExpressionNode)
        {
            parenthesizedExpressionNode.Subject()->Accept(*this);
            if (Error()) return;
        }
        public override void Visit(FunctionPtrNode& functionPtrNode)
        {
            BoundExpression* boundExpression = cast<BoundFunctionPtr*>(functionPtrNode.GetBoundExpression());
            expression.Reset(boundExpression->Clone());
        }
        public void BindSymbol(Symbol* symbol, IdentifierNode* identifierNode)
        {
            switch (symbol->Kind())
            {
                case SymbolKind.functionGroupSymbol:
                {
                    FunctionGroupSymbol* functionGroupSymbol = cast<FunctionGroupSymbol*>(symbol);
                    FunctionGroupTypeSymbol* functionGroupType = new FunctionGroupTypeSymbol(identifierNode->GetSpan(), functionGroupSymbol);
                    BoundFunctionGroupExpression* boundFunctionGroupExpression = new BoundFunctionGroupExpression(identifierNode->GetSpan(), identifierNode->ModuleId(),
                        identifierNode->FileIndex(), functionGroupSymbol, functionGroupType);
                    functionGroupType->SetBoundFunctionGroup(boundFunctionGroupExpression);
                    ParameterSymbol* thisParam = boundFunction->GetFunctionSymbol()->GetThisParam();
                    if (thisParam != null)
                    {
                        boundFunctionGroupExpression->SetClassPtr(UniquePtr<BoundExpression>(new BoundParameter(identifierNode->GetSpan(), thisParam)));
                    }
                    expression.Reset(boundFunctionGroupExpression);
                    break;
                }
                case SymbolKind.classTypeSymbol:
                case SymbolKind.classTemplateSpecializationSymbol:
                {
                    ClassTypeSymbol* classTypeSymbol = cast<ClassTypeSymbol*>(symbol);
                    Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), classTypeSymbol);
                    if (result.Error())
                    {
                        SetErrorId(result.GetErrorId());
                        return;
                    }
                    expression.Reset(new BoundTypeExpression(identifierNode->GetSpan(), classTypeSymbol));
                    break;
                }
                case SymbolKind.classGroupSymbol:
                {
                    ClassGroupSymbol* classGroupSymbol = cast<ClassGroupSymbol*>(symbol);
                    expression.Reset(new BoundTypeExpression(identifierNode->GetSpan(), classGroupSymbol));
                    break;
                }
                case SymbolKind.interfaceTypeSymbol:
                {
                    // todo
                    break;
                }
                case SymbolKind.delegateTypeSymbol:
                {
                    DelegateTypeSymbol* delegateTypeSymbol = cast<DelegateTypeSymbol*>(symbol);
                    Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), delegateTypeSymbol);
                    if (result.Error())
                    {
                        SetErrorId(result.GetErrorId());
                        return;
                    }
                    expression.Reset(new BoundTypeExpression(identifierNode->GetSpan(), delegateTypeSymbol));
                    break;
                }
                case SymbolKind.classDelegateTypeSymbol:
                {
                    ClassDelegateTypeSymbol* classDelegateTypeSymbol = cast<ClassDelegateTypeSymbol*>(symbol);
                    Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), classDelegateTypeSymbol);
                    if (result.Error())
                    {
                        SetErrorId(result.GetErrorId());
                        return;
                    }
                    expression.Reset(new BoundTypeExpression(identifierNode->GetSpan(), classDelegateTypeSymbol));
                    break;
                }
                case SymbolKind.aliasTypeSymbol:
                {
                    AliasTypeSymbol* aliasTypeSymbol = cast<AliasTypeSymbol*>(symbol);
                    Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), aliasTypeSymbol);
                    if (result.Error())
                    {
                        SetErrorId(result.GetErrorId());
                        return;
                    }
                    expression.Reset(new BoundTypeExpression(identifierNode->GetSpan(), aliasTypeSymbol->Type()));
                    break;
                }
                case SymbolKind.boundTemplateParameterSymbol:
                {
                    BoundTemplateParameterSymbol* boundTemplateParameterSymbol = cast<BoundTemplateParameterSymbol*>(symbol);
                    expression.Reset(new BoundTypeExpression(identifierNode->GetSpan(), boundTemplateParameterSymbol->Type()));
                    break;
                }
                case SymbolKind.parameterSymbol:
                {
                    ParameterSymbol* parameterSymbol = cast<ParameterSymbol*>(symbol);
                    Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), parameterSymbol);
                    if (result.Error())
                    {
                        SetErrorId(result.GetErrorId());
                        return;
                    }
                    expression.Reset(new BoundParameter(identifierNode->GetSpan(), parameterSymbol));
                    break;
                }
                case SymbolKind.localVariableSymbol:
                {
                    LocalVariableSymbol* localVariableSymbol = cast<LocalVariableSymbol*>(symbol);
                    if (!localVariableSymbol->IsInitialized())
                    {
                        Result<string> localVarNameResult = ToUtf8(localVariableSymbol->Name());
                        if (localVarNameResult.Error())
                        {
                            SetErrorId(localVarNameResult.GetErrorId());
                            return;
                        }
                        string localVarName = Rvalue(localVarNameResult.Value());
                        int errorId = MakeError("local variable '" + localVarName + "' used before initialized", identifierNode->GetFullSpan(), localVariableSymbol->FullSpan());
                        SetErrorId(errorId);
                        return;
                    }
                    Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), localVariableSymbol);
                    if (result.Error())
                    {
                        SetErrorId(result.GetErrorId());
                        return;
                    }
                    expression.Reset(new BoundLocalVariable(identifierNode->GetSpan(), localVariableSymbol));
                    break;
                }
                case SymbolKind.memberVariableSymbol:
                {
                    MemberVariableSymbol* memberVariableSymbol = cast<MemberVariableSymbol*>(symbol);
                    Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), memberVariableSymbol);
                    if (result.Error())
                    {
                        SetErrorId(result.GetErrorId());
                        return;
                    }
                    BoundMemberVariable* bmv = new BoundMemberVariable(identifierNode->GetSpan(), memberVariableSymbol);
                    bool accessFromOwnScope = false;
                    ClassTypeSymbol* currentClass = boundFunction->GetFunctionSymbol()->ContainingClass();
                    if (currentClass != null)
                    {
                        ClassTypeSymbol* cp = memberVariableSymbol->ContainingClass();
                        if (cp == currentClass)
                        {
                            accessFromOwnScope = true;
                        }
                    }
                    if (memberVariableSymbol->IsStatic())
                    {
                        if (!accessFromOwnScope)
                        {
                            bmv->SetStaticInitNeeded();
                        }
                    }
                    else
                    {
                        ParameterSymbol* thisParam = boundFunction->GetFunctionSymbol()->GetThisParam();
                        if (accessFromOwnScope && !boundFunction->GetFunctionSymbol()->IsStatic())
                        {
                            if (thisParam != null)
                            {
                                Result<TypeSymbol*> thisPointerTypeResult = thisParam->Type()->BaseType()->AddPointer(context);
                                if (thisPointerTypeResult.Error())
                                {
                                    SetErrorId(thisPointerTypeResult.GetErrorId());
                                    return;
                                }
                                TypeSymbol* thisPointerType = thisPointerTypeResult.Value();
                                if (thisParam->Type()->IsConstType())
                                {
                                    Result<TypeSymbol*> constTypeResult = thisPointerType->AddConst(context);
                                    if (constTypeResult.Error())
                                    {
                                        SetErrorId(constTypeResult.GetErrorId());
                                        return;
                                    }
                                    thisPointerType = constTypeResult.Value();
                                }
                                bmv->SetClassPtr(UniquePtr<BoundExpression>(new BoundParameter(identifierNode->GetSpan(), thisParam)));
                            }
                        }
                        else if (thisParam != null)
                        {
                            ClassTypeSymbol* containingClass = memberVariableSymbol->ContainingClass();
                            #assert(containingClass != null);
                            Result<TypeSymbol*> containingClassPointerTypeResult = containingClass->AddPointer(context);
                            if (containingClassPointerTypeResult.Error())
                            {
                                SetErrorId(containingClassPointerTypeResult.GetErrorId());
                                return;
                            }
                            TypeSymbol* containingClassPointerType = containingClassPointerTypeResult.Value();
                            Result<TypeSymbol*> thisPointerTypeResult = thisParam->Type()->BaseType()->AddPointer(context);
                            if (thisPointerTypeResult.Error())
                            {
                                SetErrorId(thisPointerTypeResult.GetErrorId());
                                return;
                            }
                            TypeSymbol* thisPointerType = thisPointerTypeResult.Value();
                            if (thisParam->Type()->IsConstType())
                            {
                                Result<TypeSymbol*> constTypeResult = thisPointerType->AddConst(context);
                                if (constTypeResult.Error())
                                {
                                    SetErrorId(constTypeResult.GetErrorId());
                                    return;
                                }
                                thisPointerType = constTypeResult.Value();
                                Result<TypeSymbol*> containingClassConstTypeResult = containingClassPointerType->AddConst(context);
                                if (containingClassConstTypeResult.Error())
                                {
                                    SetErrorId(containingClassConstTypeResult.GetErrorId());
                                    return;
                                }
                                containingClassPointerType = containingClassConstTypeResult.Value();
                            }
                            ArgumentMatch argumentMatch;
                            Result<FunctionSymbol*> conversionResult = GetConversion(thisPointerType, containingClassPointerType, containerScope,
                                boundCompileUnit, boundFunction, argumentMatch, identifierNode);
                            if (!conversionResult.Error())
                            {
                                FunctionSymbol* conversionFn = conversionResult.Value();
                                bmv->SetClassPtr(UniquePtr<BoundExpression>(new BoundConversion(identifierNode->GetSpan(),
                                    UniquePtr<BoundExpression>(new BoundParameter(identifierNode->GetSpan(), thisParam)), conversionFn)));
                            }
                        }
                    }
                    expression.Reset(bmv);
                    break;
                }
                case SymbolKind.globalVariableSymbol:
                {
                    GlobalVariableSymbol* globalVariableSymbol = cast<GlobalVariableSymbol*>(symbol);
                    expression.Reset(new BoundGlobalVariable(identifierNode->GetSpan(), globalVariableSymbol));
                    break;
                }
                case SymbolKind.constantSymbol:
                {
                    ConstantSymbol* constantSymbol = cast<ConstantSymbol*>(symbol);
                    Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), constantSymbol);
                    if (result.Error())
                    {
                        SetErrorId(result.GetErrorId());
                        return;
                    }
                    expression.Reset(new BoundConstant(identifierNode->GetSpan(), constantSymbol));
                    break;
                }
                case SymbolKind.enumTypeSymbol:
                {
                    EnumTypeSymbol* enumTypeSymbol = cast<EnumTypeSymbol*>(symbol);
                    Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), enumTypeSymbol);
                    if (result.Error())
                    {
                        SetErrorId(result.GetErrorId());
                        return;
                    }
                    expression.Reset(new BoundTypeExpression(identifierNode->GetSpan(), enumTypeSymbol));
                    break;
                }
                case SymbolKind.enumConstantSymbol:
                {
                    EnumConstantSymbol* enumConstantSymbol = cast<EnumConstantSymbol*>(symbol);
                    expression.Reset(new BoundEnumConstant(identifierNode->GetSpan(), enumConstantSymbol));
                    break;
                }
                case SymbolKind.namespaceSymbol:
                {
                    NamespaceSymbol* ns = cast<NamespaceSymbol*>(symbol);
                    NamespaceTypeSymbol* nsType = new NamespaceTypeSymbol(identifierNode->GetSpan(), ns);
                    expression.Reset(new BoundNamespaceExpression(identifierNode->GetSpan(), ns, nsType));
                    break;
                }
                default:
                {
                    Result<string> symbolFullNameResult = ToUtf8(symbol->FullName());
                    if (symbolFullNameResult.Error())
                    {
                        SetErrorId(symbolFullNameResult.GetErrorId());
                        return;
                    }
                    string symbolFullName = Rvalue(symbolFullNameResult.Value());
                    int errorId = MakeError("could not bind '" + symbolFullName + "'", identifierNode->GetFullSpan(), symbol->FullSpan());
                    SetErrorId(errorId);
                    break;
                }
            }
        }
        public void BindUnaryOp(UnaryNode* unaryNode, const ustring& groupName)
        {
            unaryNode->Subject()->Accept(*this);
            BoundExpression* operand = expression.Release();
            BindUnaryOp(operand, unaryNode, groupName);
        }
        public void BindUnaryOp(BoundExpression* operand, Node* node, const ustring& groupName)
        {
            List<UniquePtr<BoundExpression>> arguments;
            arguments.Add(UniquePtr<BoundExpression>(operand));
            List<FunctionScopeLookup> functionScopeLookups;
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
            Result<ContainerScope*> scopeResult = operand->Type()->BaseType()->ClassOrNsScope(context);
            if (scopeResult.Error())
            {
                SetErrorId(scopeResult.GetErrorId());
                return;
            }
            ContainerScope* scope = scopeResult.Value();
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, scope));
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
            Result<UniquePtr<BoundFunctionCall>> firstOperatorCallResult = ResolveOverload(groupName, containerScope, functionScopeLookups, arguments, boundCompileUnit,
                boundFunction, node);
            Result<UniquePtr<BoundFunctionCall>> secondOperatorCallResult(UniquePtr<BoundFunctionCall>());
            if (firstOperatorCallResult.Error())
            {
                Result<TypeSymbol*> argumentPlainTypeResult = arguments[0]->Type()->PlainType(context);
                if (argumentPlainTypeResult.Error())
                {
                    SetErrorId(argumentPlainTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* argumentPlainType = argumentPlainTypeResult.Value();
                if (argumentPlainType->IsClassTypeSymbol())
                {
                    if (arguments[0]->Type()->IsReferenceType())
                    {
                        Result<TypeSymbol*> nonRefTypeResult = arguments[0]->Type()->RemoveReference(context);
                        if (nonRefTypeResult.Error())
                        {
                            SetErrorId(nonRefTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* nonRefType = nonRefTypeResult.Value();
                        Result<TypeSymbol*> ptrTypeResult = nonRefType->AddPointer(context);
                        if (ptrTypeResult.Error())
                        {
                            SetErrorId(ptrTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* type = ptrTypeResult.Value();
                        arguments[0].Reset(new BoundReferenceToPointerExpression(node->GetSpan(), Rvalue(arguments[0]), type));
                    }
                    else
                    {
                        Result<TypeSymbol*> ptrTypeResult = argumentPlainType->AddPointer(context);
                        if (ptrTypeResult.Error())
                        {
                            SetErrorId(ptrTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* type = ptrTypeResult.Value();
                        arguments[0].Reset(new BoundAddressOfExpression(node->GetSpan(), Rvalue(arguments[0]), type));
                    }
                    secondOperatorCallResult = ResolveOverload(groupName, containerScope, functionScopeLookups, arguments, boundCompileUnit,
                        boundFunction, node);
                }
            }
            UniquePtr<BoundFunctionCall> operatorFunctionCall;
            if (!secondOperatorCallResult.Value().IsNull())
            {
                operatorFunctionCall = Rvalue(secondOperatorCallResult.Value());
            }
            else if (!firstOperatorCallResult.Value().IsNull())
            {
                operatorFunctionCall = Rvalue(firstOperatorCallResult.Value());
            }
            if (!operatorFunctionCall.IsNull())
            {
                Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), operatorFunctionCall->GetFunctionSymbol());
                if (result.Error())
                {
                    SetErrorId(result.GetErrorId());
                    return;
                }
                LocalVariableSymbol* temporary = null;
                if (operatorFunctionCall->GetFunctionSymbol()->ReturnsClassInterfaceOrClassDelegateByValue())
                {
                    TypeSymbol* type = operatorFunctionCall->GetFunctionSymbol()->ReturnType();
                    if (type->IsClassTemplateSpecializationSymbol())
                    {
                        ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type);
                        if (!specialization->IsBound())
                        {
                            Result<bool> result = boundCompileUnit->GetClassTemplateRepository()->BindClassTemplateSpecialization(specialization, containerScope, node);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                        }
                    }
                    Result<LocalVariableSymbol*> temporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(node->GetSpan(), type, context);
                    if (temporaryResult.Error())
                    {
                        SetErrorId(temporaryResult.GetErrorId());
                        return;
                    }
                    temporary = temporaryResult.Value();
                    Result<TypeSymbol*> ptrTypeResult = type->AddPointer(context);
                    if (ptrTypeResult.Error())
                    {
                        SetErrorId(ptrTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* ptrType = ptrTypeResult.Value();
                    operatorFunctionCall->AddArgument(UniquePtr<BoundExpression>(new BoundAddressOfExpression(node->GetSpan(),
                        UniquePtr<BoundExpression>(new BoundLocalVariable(node->GetSpan(), temporary)), ptrType)));
                    if (type->IsClassTypeSymbol())
                    {
                        ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type);
                        if (classType->Destructor() != null)
                        {
                            UniquePtr<BoundFunctionCall> destructorCall(new BoundFunctionCall(node->GetSpan(), classType->Destructor()));
                            destructorCall->AddArgument(UniquePtr<BoundExpression>(operatorFunctionCall->Arguments().Back()->Clone()));
                            Result<bool> result = boundFunction->AddTemporaryDestructorCall(Rvalue(destructorCall), boundFunction, containerScope, node);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                        }
                    }
                }
                expression.Reset(operatorFunctionCall.Release());
                if (temporary != null)
                {
                    expression.Reset(new BoundConstructAndReturnTemporaryExpression(node->GetSpan(), Rvalue(expression),
                        UniquePtr<BoundExpression>(new BoundLocalVariable(node->GetSpan(), temporary))));
                    expression->SetFlag(BoundExpressionFlags.bindToRvalueReference);
                }
            }
            else
            {
                string errorMessage;
                if (firstOperatorCallResult.Error())
                {
                    errorMessage = RtmGetErrorMessageWithoutStackTrace(firstOperatorCallResult.GetErrorId());
                }
                if (secondOperatorCallResult.Error())
                {
                    if (!errorMessage.IsEmpty())
                    {
                        errorMessage.Append("\n");
                    }
                    errorMessage.Append(RtmGetErrorMessageWithoutStackTrace(secondOperatorCallResult.GetErrorId()));
                }
                int errorId = AllocateError(errorMessage);
                SetErrorId(errorId);
                return;
            }
        }
        public void BindBinaryOp(BinaryNode* binaryNode, const ustring& groupName)
        {
            binaryNode->Left()->Accept(*this);
            if (Error()) return;
            BoundExpression* left = expression.Release();
            binaryNode->Right()->Accept(*this);
            if (Error()) return;
            BoundExpression* right = expression.Release();
            BindBinaryOp(left, right, binaryNode, groupName); 
        }
        public void BindBinaryOp(BoundExpression* left, BoundExpression* right, Node* node, const ustring& groupName)
        {
            List<UniquePtr<BoundExpression>> arguments;
            arguments.Add(UniquePtr<BoundExpression>(left));
            arguments.Add(UniquePtr<BoundExpression>(right));
            List<FunctionScopeLookup> functionScopeLookups;
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, containerScope));
            Result<ContainerScope*> leftScopeResult = left->Type()->BaseType()->ClassOrNsScope(context);
            if (leftScopeResult.Error())
            {
                SetErrorId(leftScopeResult.GetErrorId());
                return;
            }
            ContainerScope* leftScope = leftScopeResult.Value();
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, leftScope));
            Result<ContainerScope*> rightScopeResult = right->Type()->BaseType()->ClassOrNsScope(context);
            if (rightScopeResult.Error())
            {
                SetErrorId(rightScopeResult.GetErrorId());
                return;
            }
            ContainerScope* rightScope = rightScopeResult.Value();
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.this_and_base_and_parent, rightScope));
            functionScopeLookups.Add(FunctionScopeLookup(ScopeLookup.fileScopes));
            Result<UniquePtr<BoundFunctionCall>> firstOperatorCallResult = ResolveOverload(groupName, containerScope, functionScopeLookups, arguments, boundCompileUnit,
                boundFunction, node);
            Result<UniquePtr<BoundFunctionCall>> secondOperatorCallResult(UniquePtr<BoundFunctionCall>());
            if (firstOperatorCallResult.Error())
            {
                Result<TypeSymbol*> argumentPlainTypeResult = arguments[0]->Type()->PlainType(context);
                if (argumentPlainTypeResult.Error())
                {
                    SetErrorId(argumentPlainTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* argumentPlainType = argumentPlainTypeResult.Value();
                if (argumentPlainType->IsClassTypeSymbol())
                {
                    if (arguments[0]->Type()->IsReferenceType())
                    {
                        Result<TypeSymbol*> nonRefTypeResult = arguments[0]->Type()->RemoveReference(context);
                        if (nonRefTypeResult.Error())
                        {
                            SetErrorId(nonRefTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* nonRefType = nonRefTypeResult.Value();
                        Result<TypeSymbol*> ptrTypeResult = nonRefType->AddPointer(context);
                        if (ptrTypeResult.Error())
                        {
                            SetErrorId(ptrTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* type = ptrTypeResult.Value();
                        arguments[0].Reset(new BoundReferenceToPointerExpression(node->GetSpan(), Rvalue(arguments[0]), type));
                    }
                    else
                    {
                        Result<TypeSymbol*> ptrTypeResult = argumentPlainType->AddPointer(context);
                        if (ptrTypeResult.Error())
                        {
                            SetErrorId(ptrTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* type = ptrTypeResult.Value();
                        arguments[0].Reset(new BoundAddressOfExpression(node->GetSpan(), Rvalue(arguments[0]), type));
                    }
                    secondOperatorCallResult = ResolveOverload(groupName, containerScope, functionScopeLookups, arguments, boundCompileUnit,
                        boundFunction, node);
                }
            }
            UniquePtr<BoundFunctionCall> operatorFunctionCall;
            if (!secondOperatorCallResult.Value().IsNull())
            {
                operatorFunctionCall = Rvalue(secondOperatorCallResult.Value());
            }
            else if (!firstOperatorCallResult.Value().IsNull())
            {
                operatorFunctionCall = Rvalue(firstOperatorCallResult.Value());
            }
            if (!operatorFunctionCall.IsNull())
            {
                Result<bool> result = CheckAccess(boundFunction->GetFunctionSymbol(), operatorFunctionCall->GetFunctionSymbol());
                if (result.Error())
                {
                    SetErrorId(result.GetErrorId());
                    return;
                }
                LocalVariableSymbol* temporary = null;
                if (operatorFunctionCall->GetFunctionSymbol()->ReturnsClassInterfaceOrClassDelegateByValue())
                {
                    TypeSymbol* type = operatorFunctionCall->GetFunctionSymbol()->ReturnType();
                    if (type->IsClassTemplateSpecializationSymbol())
                    {
                        ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type);
                        if (!specialization->IsBound())
                        {
                            Result<bool> result = boundCompileUnit->GetClassTemplateRepository()->BindClassTemplateSpecialization(specialization, containerScope, node);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                        }
                    }
                    Result<LocalVariableSymbol*> temporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(node->GetSpan(), type, context);
                    if (temporaryResult.Error())
                    {
                        SetErrorId(temporaryResult.GetErrorId());
                        return;
                    }
                    temporary = temporaryResult.Value();
                    Result<TypeSymbol*> ptrTypeResult = type->AddPointer(context);
                    if (ptrTypeResult.Error())
                    {
                        SetErrorId(ptrTypeResult.GetErrorId());
                        return;
                    }
                    TypeSymbol* ptrType = ptrTypeResult.Value();
                    operatorFunctionCall->AddArgument(UniquePtr<BoundExpression>(new BoundAddressOfExpression(node->GetSpan(),
                        UniquePtr<BoundExpression>(new BoundLocalVariable(node->GetSpan(), temporary)), ptrType)));
                    if (type->IsClassTypeSymbol())
                    {
                        ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type);
                        if (classType->Destructor() != null)
                        {
                            UniquePtr<BoundFunctionCall> destructorCall(new BoundFunctionCall(node->GetSpan(), classType->Destructor()));
                            destructorCall->AddArgument(UniquePtr<BoundExpression>(operatorFunctionCall->Arguments().Back()->Clone()));
                            Result<bool> result = boundFunction->AddTemporaryDestructorCall(Rvalue(destructorCall), boundFunction, containerScope, node);
                            if (result.Error())
                            {
                                SetErrorId(result.GetErrorId());
                                return;
                            }
                        }
                    }
                }
                expression.Reset(operatorFunctionCall.Release());
                if (temporary != null)
                {
                    expression.Reset(new BoundConstructAndReturnTemporaryExpression(node->GetSpan(), Rvalue(expression),
                        UniquePtr<BoundExpression>(new BoundLocalVariable(node->GetSpan(), temporary))));
                    expression->SetFlag(BoundExpressionFlags.bindToRvalueReference);
                }
            }
            else
            {
                string errorMessage;
                if (firstOperatorCallResult.Error())
                {
                    errorMessage = RtmGetErrorMessageWithoutStackTrace(firstOperatorCallResult.GetErrorId());
                }
                if (secondOperatorCallResult.Error())
                {
                    if (!errorMessage.IsEmpty())
                    {
                        errorMessage.Append("\n");
                    }
                    errorMessage.Append(RtmGetErrorMessageWithoutStackTrace(secondOperatorCallResult.GetErrorId()));
                }
                int errorId = AllocateError(errorMessage);
                SetErrorId(errorId);
                return;
            }
        }
        public void BindArrow(Node* node, IdentifierNode* memberId)
        {
            if (expression->Type()->IsPointerType())
            {
                UniquePtr<BoundExpression> classPtr(Rvalue(expression));
                if (classPtr->Type()->BaseType()->IsClassTypeSymbol())
                {
                    ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(classPtr->Type()->BaseType());
                    ContainerScope* scope = classType->GetContainerScope();
                    Result<Symbol*> symbolResult = scope->Lookup(memberId->Str(), ScopeLookup.this_and_base, context);
                    if (symbolResult.Error())
                    {
                        SetErrorId(symbolResult.GetErrorId());
                        return;
                    }
                    Symbol* symbol = symbolResult.Value();
                    if (symbol != null)
                    {
                        BindSymbol(symbol, memberId);
                        if (expression->IsBoundFunctionGroupExpression())
                        {
                            BoundFunctionGroupExpression* bfg = cast<BoundFunctionGroupExpression*>(expression.Get());
                            if (!classPtr->GetFlag(BoundExpressionFlags.argIsExplicitThisOrBasePtr))
                            {
                                Symbol* parent = symbol->Parent();
                                #assert(parent->IsClassTypeSymbol());
                                ClassTypeSymbol* owner = cast<ClassTypeSymbol*>(parent);
                                if (classType->HasBaseClass(owner))
                                {
                                    if (classPtr->Type()->IsConstType())
                                    {
                                        ArgumentMatch argumentMatch;
                                        Result<TypeSymbol*> constTypeResult = classType->AddConst(context);
                                        if (constTypeResult.Error())
                                        {
                                            SetErrorId(constTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* constType = constTypeResult.Value();
                                        Result<TypeSymbol*> ptrTypeResult = constType->AddPointer(context);
                                        if (ptrTypeResult.Error())
                                        {
                                            SetErrorId(ptrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ptrType = ptrTypeResult.Value();
                                        Result<TypeSymbol*> ownerConstTypeResult = owner->AddConst(context);
                                        if (ownerConstTypeResult.Error())
                                        {
                                            SetErrorId(ownerConstTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ownerConstType = ownerConstTypeResult.Value();
                                        Result<TypeSymbol*> ownerPtrTypeResult = ownerConstType->AddPointer(context);
                                        if (ownerPtrTypeResult.Error())
                                        {
                                            SetErrorId(ownerPtrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ownerPtrType = ownerPtrTypeResult.Value();
                                        Result<FunctionSymbol*> conversionResult = GetConversion(ptrType,
                                            ownerPtrType, containerScope, boundCompileUnit, boundFunction, argumentMatch, node);
                                        if (conversionResult.Error())
                                        {
                                            SetErrorId(conversionResult.GetErrorId());
                                            return;
                                        }
                                        FunctionSymbol* conversionFn = conversionResult.Value();
                                        classPtr.Reset(new BoundConversion(node->GetSpan(), UniquePtr<BoundExpression>(classPtr.Release()), conversionFn));
                                    }
                                    else
                                    {
                                        ArgumentMatch argumentMatch;
                                        Result<TypeSymbol*> ptrTypeResult = classType->AddPointer(context);
                                        if (ptrTypeResult.Error())
                                        {
                                            SetErrorId(ptrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ptrType = ptrTypeResult.Value();
                                        Result<TypeSymbol*> ownerPtrTypeResult = owner->AddPointer(context);
                                        if (ownerPtrTypeResult.Error())
                                        {
                                            SetErrorId(ownerPtrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ownerPtrType = ownerPtrTypeResult.Value();
                                        Result<FunctionSymbol*> conversionResult = GetConversion(ptrType,
                                            ownerPtrType, containerScope, boundCompileUnit, boundFunction, argumentMatch, node);
                                        if (conversionResult.Error())
                                        {
                                            SetErrorId(conversionResult.GetErrorId());
                                            return;
                                        }
                                        FunctionSymbol* conversionFn = conversionResult.Value();
                                        classPtr.Reset(new BoundConversion(node->GetSpan(), UniquePtr<BoundExpression>(classPtr.Release()), conversionFn));
                                    }
                                }
                                MemberExpressionTypeSymbol* memberExpressionType = new MemberExpressionTypeSymbol(node->GetSpan(), expression->Type()->Name());
                                BoundMemberExpression* bme = new BoundMemberExpression(node->GetSpan(), UniquePtr<BoundExpression>(classPtr.Release()),
                                    Rvalue(expression), memberExpressionType);
                                memberExpressionType->SetBoundMemberExpression(bme);
                                expression.Reset(bme);
                            }
                        }
                        else if (expression->IsBoundMemberVariable())
                        {
                            BoundMemberVariable* bmv = cast<BoundMemberVariable*>(expression.Get());
                            if (!bmv->GetMemberVariableSymbol()->IsStatic())
                            {
                                Symbol* parent = symbol->Parent();
                                #assert(parent->IsClassTypeSymbol());
                                ClassTypeSymbol* owner = cast<ClassTypeSymbol*>(parent);
                                if (classType->HasBaseClass(owner))
                                {
                                    if (classPtr->Type()->IsConstType())
                                    {
                                        ArgumentMatch argumentMatch;
                                        Result<TypeSymbol*> constTypeResult = classType->AddConst(context);
                                        if (constTypeResult.Error())
                                        {
                                            SetErrorId(constTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* constType = constTypeResult.Value();
                                        Result<TypeSymbol*> ptrTypeResult = constType->AddPointer(context);
                                        if (ptrTypeResult.Error())
                                        {
                                            SetErrorId(ptrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ptrType = ptrTypeResult.Value();
                                        Result<TypeSymbol*> ownerConstTypeResult = owner->AddConst(context);
                                        if (ownerConstTypeResult.Error())
                                        {
                                            SetErrorId(ownerConstTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ownerConstType = ownerConstTypeResult.Value();
                                        Result<TypeSymbol*> ownerPtrTypeResult = ownerConstType->AddPointer(context);
                                        if (ownerPtrTypeResult.Error())
                                        {
                                            SetErrorId(ownerPtrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ownerPtrType = ownerPtrTypeResult.Value();
                                        Result<FunctionSymbol*> conversionResult = GetConversion(ptrType,
                                            ownerPtrType, containerScope, boundCompileUnit, boundFunction, argumentMatch, node);
                                        if (conversionResult.Error())
                                        {
                                            SetErrorId(conversionResult.GetErrorId());
                                            return;
                                        }
                                        FunctionSymbol* conversionFn = conversionResult.Value();
                                        classPtr.Reset(new BoundConversion(node->GetSpan(), UniquePtr<BoundExpression>(classPtr.Release()), conversionFn));
                                    }
                                    else
                                    {
                                        ArgumentMatch argumentMatch;
                                        Result<TypeSymbol*> ptrTypeResult = classType->AddPointer(context);
                                        if (ptrTypeResult.Error())
                                        {
                                            SetErrorId(ptrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ptrType = ptrTypeResult.Value();
                                        Result<TypeSymbol*> ownerPtrTypeResult = owner->AddPointer(context);
                                        if (ownerPtrTypeResult.Error())
                                        {
                                            SetErrorId(ownerPtrTypeResult.GetErrorId());
                                            return;
                                        }
                                        TypeSymbol* ownerPtrType = ownerPtrTypeResult.Value();
                                        Result<FunctionSymbol*> conversionResult = GetConversion(ptrType,
                                            ownerPtrType, containerScope, boundCompileUnit, boundFunction, argumentMatch, node);
                                        if (conversionResult.Error())
                                        {
                                            SetErrorId(conversionResult.GetErrorId());
                                            return;
                                        }
                                        FunctionSymbol* conversionFn = conversionResult.Value();
                                        classPtr.Reset(new BoundConversion(node->GetSpan(), UniquePtr<BoundExpression>(classPtr.Release()), conversionFn));
                                    }
                                }
                                bmv->SetClassPtr(UniquePtr<BoundExpression>(classPtr.Release()));
                            }
                            else
                            {
                                Result<string> memberVariableSymbolFullNameResult = ToUtf8(bmv->GetMemberVariableSymbol()->FullName());
                                string memberVariableSymbolFullName = Rvalue(memberVariableSymbolFullNameResult.Value());
                                int errorId = MakeError("member variable '" + memberVariableSymbolFullName + "' is static", node->GetFullSpan());
                                SetErrorId(errorId);
                                return;
                            }
                        }
                        else
                        {
                            Result<string> symbolNameResult = ToUtf8(memberId->Str());
                            if (symbolNameResult.Error())
                            {
                                SetErrorId(symbolNameResult.GetErrorId());
                                return;
                            }
                            string symbolName = Rvalue(symbolNameResult.Value());
                            int errorId = MakeError("symbol '" + symbolName + "' does not denote a function group or a member variable", memberId->GetFullSpan());
                            SetErrorId(errorId);
                            return;
                        }
                    }
                    else
                    {
                        Result<string> symbolNameResult = ToUtf8(memberId->Str());
                        if (symbolNameResult.Error())
                        {
                            SetErrorId(symbolNameResult.GetErrorId());
                            return;
                        }
                        string symbolName = Rvalue(symbolNameResult.Value());
                        Result<string> classTypeFullNameResult = ToUtf8(classType->FullName());
                        if (classTypeFullNameResult.Error())
                        {
                            SetErrorId(classTypeFullNameResult.GetErrorId());
                            return;
                        }
                        string classTypeFullName = Rvalue(classTypeFullNameResult.Value());
                        int errorId = MakeError("symbol '" + symbolName + "' not found from class '" + classTypeFullName + "'", memberId->GetFullSpan());
                        SetErrorId(errorId);
                        return;
                    }
                }
                else
                {
                    int errorId = MakeError("type of arrow expression subject must be pointer to class type", node->GetFullSpan());
                    SetErrorId(errorId);
                    return;
                }
            }
            else if (expression->Type()->IsClassTypeSymbol())
            {
                TypeSymbol* type = expression->Type();
                if (type->IsClassTemplateSpecializationSymbol())
                {
                    ClassTemplateSpecializationSymbol* specialization = cast<ClassTemplateSpecializationSymbol*>(type);
                    if (!specialization->IsBound())
                    {
                        Result<bool> result = boundCompileUnit->GetClassTemplateRepository()->BindClassTemplateSpecialization(specialization, containerScope, node);
                        if (result.Error())
                        {
                            SetErrorId(result.GetErrorId());
                            return;
                        }
                    }
                }
                Result<TypeSymbol*> pointerTypeResult = type->AddPointer(context);
                if (pointerTypeResult.Error())
                {
                    SetErrorId(pointerTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* pointerType = pointerTypeResult.Value();
                Result<LocalVariableSymbol*> temporaryResult = boundFunction->GetFunctionSymbol()->CreateTemporary(node->GetSpan(), type, context);
                if (temporaryResult.Error())
                {
                    SetErrorId(temporaryResult.GetErrorId());
                    return;
                }
                LocalVariableSymbol* temporary = temporaryResult.Value();
                #assert(expression->IsBoundFunctionCall());
                BoundFunctionCall* boundFunctionCall = cast<BoundFunctionCall*>(expression.Get());
                boundFunctionCall->AddArgument(UniquePtr<BoundExpression>(new BoundAddressOfExpression(node->GetSpan(), UniquePtr<BoundExpression>(
                    new BoundLocalVariable(node->GetSpan(), temporary)), pointerType)));
                if (type->IsClassTypeSymbol())
                {
                    ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(type);
                    if (classType->Destructor() != null)
                    {
                        UniquePtr<BoundFunctionCall> destructorCall(new BoundFunctionCall(node->GetSpan(), classType->Destructor()));
                        destructorCall->AddArgument(UniquePtr<BoundExpression>(boundFunctionCall->Arguments().Back()->Clone()));
                        Result<bool> result = boundFunction->AddTemporaryDestructorCall(Rvalue(destructorCall), boundFunction, containerScope, node);
                        if (result.Error())
                        {
                            SetErrorId(result.GetErrorId());
                            return;
                        }
                    }
                }
                expression.Reset(new BoundAddressOfExpression(node->GetSpan(), UniquePtr<BoundExpression>(
                    new BoundConstructAndReturnTemporaryExpression(node->GetSpan(), Rvalue(expression),
                    UniquePtr<BoundExpression>(new BoundLocalVariable(node->GetSpan(), temporary)))), pointerType));
                BindUnaryOp(expression.Release(), node, u"operator->");
                BindArrow(node, memberId);
            }
            else
            {
                int errorId = MakeError("arrow operator member function must return a class type object or a pointer to a class type object", node->GetFullSpan());
                SetErrorId(errorId);
                return;
            }
        }
        public void BindDerefExpr(Node* node)
        {
            if (expression->Type()->IsPointerType())
            {
                Result<TypeSymbol*> nonPtrTypeResult = expression->Type()->RemovePointer(context);
                if (nonPtrTypeResult.Error())
                {
                    SetErrorId(nonPtrTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* type = nonPtrTypeResult.Value();
                expression.Reset(new BoundDereferenceExpression(node->GetSpan(), UniquePtr<BoundExpression>(expression.Release()), type));
            }
            else
            {
                Result<TypeSymbol*> plainSubjectTypeResult = expression->Type()->PlainType(context);
                if (plainSubjectTypeResult.Error())
                {
                    SetErrorId(plainSubjectTypeResult.GetErrorId());
                    return;
                }
                TypeSymbol* plainSubjectType = plainSubjectTypeResult.Value();
                if (plainSubjectType->IsClassTypeSymbol())
                {
                    if (expression->Type()->IsReferenceType())
                    {
                        Result<TypeSymbol*> nonRefTypeResult = expression->Type()->RemoveReference(context);
                        if (nonRefTypeResult.Error())
                        {
                            SetErrorId(nonRefTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* nonRefType = nonRefTypeResult.Value();
                        Result<TypeSymbol*> ptrTypeResult = nonRefType->AddPointer(context);
                        if (ptrTypeResult.Error())
                        {
                            SetErrorId(ptrTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* type = ptrTypeResult.Value();
                        expression.Reset(new BoundReferenceToPointerExpression(node->GetSpan(), Rvalue(expression), type));
                    }
                    else if (expression->Type()->IsClassTypeSymbol())
                    {
                        Result<TypeSymbol*> pointerTypeResult = expression->Type()->AddPointer(context);
                        if (pointerTypeResult.Error())
                        {
                            SetErrorId(pointerTypeResult.GetErrorId());
                            return;
                        }
                        TypeSymbol* type = pointerTypeResult.Value();
                        expression.Reset(new BoundAddressOfExpression(node->GetSpan(), Rvalue(expression), type));
                    }
                    BindUnaryOp(expression.Release(), node, u"operator*");
                }
                else
                {
                    int errorId = MakeError("dereference needs pointer or class type argument", node->GetFullSpan());
                    SetErrorId(errorId);
                    return;
                }
            }
        }
        public inline bool Error() const
        {
            return errorId != 0;
        }
        public inline void SetErrorId(int errorId_)
        {
            errorId = errorId_;
        }
        public inline int GetErrorId() const
        {
            return errorId;
        }
        private BoundCompileUnit* boundCompileUnit;
        private SymbolsContext& context;
        private SymbolTable* symbolTable;
        private Module* module;
        private BoundFunction* boundFunction;
        private ContainerScope* containerScope;
        private StatementBinder* statementBinder;
        private UniquePtr<BoundExpression> expression;
        private bool lvalue;
        private bool inhibitCompile;
        private int errorId;
    }

    public Result<UniquePtr<BoundExpression>> BindExpression(Node* node, BoundCompileUnit* boundCompileUnit, BoundFunction* boundFunction, ContainerScope* containerScope,
        StatementBinder* statementBinder)
    {
        return BindExpression(node, boundCompileUnit, boundFunction, containerScope, statementBinder, false);
    }

    public Result<UniquePtr<BoundExpression>> BindExpression(Node* node, BoundCompileUnit* boundCompileUnit, BoundFunction* boundFunction, ContainerScope* containerScope,
        StatementBinder* statementBinder, bool lvalue)
    {
        return BindExpression(node, boundCompileUnit, boundFunction, containerScope, statementBinder, lvalue, false);
    }

    public Result<UniquePtr<BoundExpression>> BindExpression(Node* node, BoundCompileUnit* boundCompileUnit, BoundFunction* boundFunction, ContainerScope* containerScope,
        StatementBinder* statementBinder, bool lvalue, bool acceptFunctionGroupOrMemberExpression)
    {
        return BindExpression(node, boundCompileUnit, boundFunction, containerScope, statementBinder, lvalue, acceptFunctionGroupOrMemberExpression, false);
    }

    public Result<UniquePtr<BoundExpression>> BindExpression(Node* node, BoundCompileUnit* boundCompileUnit, BoundFunction* boundFunction, ContainerScope* containerScope,
        StatementBinder* statementBinder, bool lvalue, bool acceptFunctionGroupOrMemberExpression, bool acceptIncomplete)
    {
        ExpressionBinder expressionBinder(boundCompileUnit, boundFunction, containerScope, statementBinder, lvalue);
        node->Accept(expressionBinder);
        if (expressionBinder.Error())
        {
            return Result<UniquePtr<BoundExpression>>(ErrorId(expressionBinder.GetErrorId()));
        }
        UniquePtr<BoundExpression> expression = expressionBinder.GetExpression();
        if (expression.IsNull())
        {
            int errorId = MakeError("could not bind expression", node->GetFullSpan());
            return Result<UniquePtr<BoundExpression>>(ErrorId(errorId));
        }
        if (acceptFunctionGroupOrMemberExpression && (expression->IsBoundFunctionGroupExpression() || expression->IsBoundMemberExpression()))
        {
            return expression;
        }
        if (!acceptIncomplete)
        {
            if (!expression->IsComplete())
            {
                int errorId = MakeError("incomplete expression", node->GetFullSpan());
                return Result<UniquePtr<BoundExpression>>(ErrorId(errorId));
            }
        }
        if (lvalue && !expression->IsLvalueExpression())
        {
            int errorId = MakeError("not an lvalue expression", node->GetFullSpan());
            return Result<UniquePtr<BoundExpression>>(ErrorId(errorId));
        }
        return Result<UniquePtr<BoundExpression>>(Rvalue(expression));
    }
}

