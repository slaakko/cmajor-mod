// =================================
// Copyright (c) 2025 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.IO;

namespace System.Windows.API
{
    public const long ERROR_DUPLICATE_CODE_MAPPING = -2;
    public const long ERROR_CODE_NOT_FOUND = -1;
    public const long ERROR_OUT_OF_RESOURCES = 0;
    public const long ERROR_FILE_NOT_FOUND = 1;
    public const long ERROR_PATH_NOT_FOUND = 2;
    public const long ERROR_BAD_FORMAT = 3;
    public const long SE_ERR_ACCESSDENIED  = 4;
    public const long SE_ERR_ASSOCINCOMPLETE = 5;
    public const long SE_ERR_DDEBUSY = 6;
    public const long SE_ERR_DDEFAIL = 7;
    public const long SE_ERR_DDETIMEOUT = 8;
    public const long SE_ERR_DLLNOTFOUND = 9;
    public const long SE_ERR_FNF = 10;
    public const long SE_ERR_NOASSOC = 11;
    public const long SE_ERR_OOM = 12;
    public const long SE_ERR_PNF = 13;
    public const long SE_ERR_SHARE = 14;

    [nodiscard]
    public Result<string> GetWindowsAPIErrorMessage(ulong errorCode)
    {
        wchar[4096] buffer;
        WinFormatMessage(errorCode, &buffer[0]);
        auto utf8Result = ToUtf8(wstring(&buffer[0]));
        if (utf8Result.Error())
        {
            return Result<string>(ErrorId(utf8Result.GetErrorId()));
        }
        return Result<string>(utf8Result.Value());
    }

    [nodiscard]
    public Result<void*> FindFirstChangeNotification(const string& directoryPath)
    {
        void* notificationHandle = WinFindFirstChangeNotification(directoryPath.Chars());
        if (notificationHandle == null)
        {
            int errorId = WinAllocateWindowsError("find first change notification failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        return Result<void*>(notificationHandle);
    }

    [nodiscard]
    public Result<bool> FindNextChangeNotification(void* notificationHandle)
    {
        bool result = WinFindNextChangeNotification(notificationHandle);
        if (!result)
        {
            int errorId = WinAllocateWindowsError("find next change notification failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> FindCloseChangeNotification(void* notificationHandle)
    {
        bool result = WinFindCloseChangeNotification(notificationHandle);
        if (!result)
        {
            int errorId = WinAllocateWindowsError("find close change notification failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<void*> CreateEvent()
    {
        void* eventHandle = WinCreateEvent();
        if (eventHandle == null)
        {
            int errorId = WinAllocateWindowsError("create event failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        return Result<void*>(eventHandle);
    }

    [nodiscard]
    public Result<bool> SetEvent(void* eventHandle)
    {
        bool result = WinSetEvent(eventHandle);
        if (!result)
        {
            int errorId = WinAllocateWindowsError("set event failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> ResetEvent(void* eventHandle)
    {
        bool result = WinResetEvent(eventHandle);
        if (!result)
        {
            int errorId = WinAllocateWindowsError("reset event failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> WaitEvent(void* eventHandle)
    {
        bool result = WinWaitEvent(eventHandle);
        if (!result)
        {
            int errorId = WinAllocateWindowsError("wait event failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> CloseHandle(void* handle)
    {
        bool result = WinCloseHandle(handle);
        if (!result)
        {
            int errorId = WinAllocateWindowsError("close handle failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> CloseEvent(void* eventHandle)
    {
        return CloseHandle(eventHandle);
    }

    [nodiscard]
    public Result<int> WaitForMultipleObjects(const List<void*>& handles)
    {
        int result = WinWaitForMultipleObjects(cast<uint>(handles.Count()), handles.Begin().Ptr());
        if (result >= 0 && result <= handles.Count())
        {
            return Result<int>(result);
        }
        else
        {
            int errorId = WinAllocateWindowsError("wait for multiple objects failed", WinGetLastError());
            return Result<int>(ErrorId(errorId));
        }
    }

    [nodiscard]
    public Result<bool> ShellExecute(const string& filePath)
    {
        long errorCode = 0;
        bool succeeded = WinShellExecute(filePath.Chars(), errorCode);
        if (!succeeded)
        {
            string errorMessage = "shell execution error for file '" + filePath + "': ";
            string error = "out of resources";
            switch (errorCode)
            {
                case ERROR_DUPLICATE_CODE_MAPPING:
                {
                    error = "duplicate code mapping detected"; break;
                }
                case ERROR_CODE_NOT_FOUND:
                {
                    error = "code not found"; break;
                }
                case ERROR_OUT_OF_RESOURCES:
                {
                    error = "out of resources"; break;
                }
                case ERROR_FILE_NOT_FOUND:
                {
                    error = "file not found"; break;
                }
                case ERROR_PATH_NOT_FOUND:
                {
                    error = "path not found"; break;
                }
                case ERROR_BAD_FORMAT:
                {
                    error = "invalid executable"; break;
                }
                case SE_ERR_ACCESSDENIED:
                {
                    error = "access denied"; break;
                }
                case SE_ERR_ASSOCINCOMPLETE:
                {
                    error = "invalid file association"; break;
                }
                case SE_ERR_DDEBUSY:
                {
                    error = "DDE busy"; break;
                }
                case SE_ERR_DDEFAIL:
                {
                    error = "DDE failed"; break;
                }
                case SE_ERR_DDETIMEOUT:
                {
                    error = "DDE timeout"; break;
                }
                case SE_ERR_DLLNOTFOUND:
                {
                    error = "DLL not found"; break;
                }
                case SE_ERR_FNF:
                {
                    error = "file not found"; break;
                }
                case SE_ERR_NOASSOC:
                {
                    error = "no association for this type of file"; break;
                }
                case SE_ERR_OOM:
                {
                    error = "not enough memory"; break;
                }
                case SE_ERR_PNF:
                {
                    error = "path not found"; break;
                }
                case SE_ERR_SHARE:
                {
                    error = "sharing violation"; break;
                }
            }
            errorMessage.Append(error);
            int errorId = AllocateError(errorMessage);
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<ushort> RegisterWindowClass(const char* windowClassName, uint style, int backgroundColor)
    {
        ushort windowClass = WinRegisterWindowClass(windowClassName, style, backgroundColor);
        if (windowClass == 0u)
        {
            int errorId = WinAllocateWindowsError("register window class failed", WinGetLastError());
            return Result<ushort>(ErrorId(errorId));
        }
        return Result<ushort>(windowClass);
    }

    [nodiscard]
    public Result<void*> CreateWindowByClassAtom(ushort windowClass, const char* windowName, long style, long exStyle, Point location, Size size, Control* parent)
    {
        void* parentHandle = null;
        if (parent != null)
        {
            parentHandle = parent->Handle();
        }
        void* result = WinCreateWindowByClassAtom(windowClass, windowName, style, exStyle, location.x, location.y, size.w, size.h, parentHandle);
        if (result == null)
        {
            int errorId = WinAllocateWindowsError("create window by class atom failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        else
        {
            return Result<void*>(result);
        }
    }

    [nodiscard]
    public Result<void*> CreateWindowByClassName(const char* windowClass, const char* windowName, long style, long exStyle, Point location, Size size, Control* parent)
    {
        void* parentHandle = null;
        if (parent != null)
        {
            parentHandle = parent->Handle();
        }
        void* result = WinCreateWindowByClassName(windowClass, windowName, style, exStyle, location.x, location.y, size.w, size.h, parentHandle);
        if (result == null)
        {
            int errorId = WinAllocateWindowsError("create window by class name failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        else
        {
            return Result<void*>(result);
        }
    }

    [nodiscard]
    public Result<bool> MoveWindow(void* windowHandle, const Point& location, const Size& size, bool repaint)
    {
        bool succeeded = WinMoveWindow(windowHandle, location.x, location.y, size.w, size.h, repaint);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("move window failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<WinRect> GetClientRect(void* windowHandle)
    {
        WinRect rect;
        bool succeeded = WinGetClientRect(windowHandle, &rect);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("get client rect failed", WinGetLastError());
            return Result<WinRect>(ErrorId(errorId));
        }
        return Result<WinRect>(rect);
    }

    [nodiscard]
    public Result<WinRect> GetWindowRect(void* windowHandle)
    {
        WinRect rect;
        bool succeeded = WinGetWindowRect(windowHandle, &rect);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("get window rect failed", WinGetLastError());
            return Result<WinRect>(ErrorId(errorId));
        }
        return Result<WinRect>(rect);
    }

    [nodiscard]
    public Result<Point> ClientToScreen(void* windowHandle, const Point& point)
    {
        Point pt(point);
        bool succeeded = WinClientToScreen(windowHandle, &pt);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("client to screen failed", WinGetLastError());
            return Result<Point>(ErrorId(errorId));
        }
        return Result<Point>(pt);
    }

    [nodiscard]
    public Result<Point> ScreenToClient(void* windowHandle, const Point& point)
    {
        Point pt(point);
        bool succeeded = WinScreenToClient(windowHandle, &pt);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("screen to client failed", WinGetLastError());
            return Result<Point>(ErrorId(errorId));
        }
        return Result<Point>(pt);
    }

    public bool PtInRect(const Point& point, const WinRect& rect)
    {
        return WinPtInRect(&rect, &point);
    }

    [nodiscard]
    public Result<bool> SetWindowText(void* windowHandle, const string& text)
    {
        bool succeeded = WinSetWindowText(windowHandle, text.Chars());
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("set window text failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<int> GetWindowTextLength(void* windowHandle)
    {
        int result = WinGetWindowTextLength(windowHandle);
        if (result == 0)
        {
            ulong errorCode = WinGetLastError();
            if (errorCode != 0u)
            {
                int errorId = WinAllocateWindowsError("get window text length failed", errorCode);
                return Result<int>(ErrorId(errorId));
            }
        }
        return Result<int>(result);
    }

    [nodiscard]
    public Result<string> GetWindowText(void* windowHandle)
    {
        Result<int> lengthResult = GetWindowTextLength(windowHandle);
        if (lengthResult.Error())
        {
            return Result<string>(ErrorId(lengthResult.GetErrorId()));
        }
        int length = lengthResult.Value();
        UniquePtr<wchar> buffer(cast<wchar*>(MemAlloc(sizeof(wchar) * (length + 1))));
        int result = WinGetWindowText(windowHandle, buffer.Get(), length + 1);
        if (result == 0)
        {
            ulong errorCode = WinGetLastError();
            if (errorCode != 0u)
            {
                int errorId = WinAllocateWindowsError("get window text failed", errorCode);
                return Result<string>(ErrorId(errorId));
            }
        }
        auto utf8Result = ToUtf8(buffer.Get());
        if (utf8Result.Error())
        {
            return Result<string>(ErrorId(utf8Result.GetErrorId()));
        }
        return Result<string>(utf8Result.Value());
    }

    [nodiscard]
    public Result<bool> SetParentWindow(void* childWindowHandle, void* parentWindowHandle)
    {
        void* result = WinSetParent(childWindowHandle, parentWindowHandle);
        if (result == null)
        {
            int errorId = WinAllocateWindowsError("set parent window failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<void*> BeginPaint(void* windowHandle, void*& paintStruct)
    {
        void* result = WinBeginPaint(windowHandle, paintStruct);
        if (result == null)
        {
            int errorId = WinAllocateWindowsError("begin paint failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        return Result<void*>(result);
    }

    public void EndPaint(void* windowHandle, void* paintStruct)
    {
        WinEndPaint(windowHandle, paintStruct);
    }

    [nodiscard]
    public Result<bool> InvalidateRect(void* windowHandle, WinRect* rect, bool eraseBackground)
    {
        bool succeeded = WinInvalidateRect(windowHandle, rect, eraseBackground);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("invalidate rect failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> MessageBeep(uint beepType)
    {
        bool succeeded = WinMessageBeep(beepType);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("message beep failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    public void* GetDC(void* windowHandle)
    {
        return WinGetDC(windowHandle);
    }

    [nodiscard]
    public Result<bool> PostMessage(void* windowHandle, uint msg, ulong wparam, long lparam)
    {
        bool succeeded = WinPostMessage(windowHandle, msg, wparam, lparam);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("post message failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    public string CommonDialogError(uint errorCode)
    {
        string errorStr;
        switch (errorCode)
        {
            case 0xFFFFu:
            {
                errorStr = "CDERR_DIALOGFAILURE";
                break;
            }
            case 0x0006u:
            {
                errorStr = "CDERR_FINDRESFAILURE";
                break;
            }
            case 0x0002u:
            {
                errorStr = "CDERR_INITIALIZATION";
                break;
            }
            case 0x0007u:
            {
                errorStr = "CDERR_LOADRESFAILURE";
                break;
            }
            case 0x0005u:
            {
                errorStr = "CDERR_LOADSTRFAILURE";
                break;
            }
            case 0x0008u:
            {
                errorStr = "CDERR_LOCKRESFAILURE";
                break;
            }
            case 0x0009u:
            {
                errorStr = "CDERR_MEMALLOCFAILURE";
                break;
            }
            case 0x000Au:
            {
                errorStr = "CDERR_MEMLOCKFAILURE";
                break;
            }
            case 0x0004u:
            {
                errorStr = "CDERR_NOHINSTANCE";
                break;
            }
            case 0x000Bu:
            {
                errorStr = "CDERR_NOHOOK";
                break;
            }
            case 0x0003u:
            {
                errorStr = "CDERR_NOTEMPLATE";
                break;
            }
            case 0x000Cu:
            {
                errorStr = "CDERR_REGISTERMSGFAIL";
                break;
            }
            case 0x0001u:
            {
                errorStr = "CDERR_STRUCTSIZE";
                break;
            }
            case 0x100Au:
            {
                errorStr = "PDERR_CREATEICFAILURE";
                break;
            }
            case 0x100Cu:
            {
                errorStr = "PDERR_DEFAULTDIFFERENT";
                break;
            }
            case 0x1009u:
            {
                errorStr = "PDERR_DNDMMISMATCH";
                break;
            }
            case 0x1005u:
            {
                errorStr = "PDERR_GETDEVMODEFAIL";
                break;
            }
            case 0x1006u:
            {
                errorStr = "PDERR_INITFAILURE";
                break;
            }
            case 0x1004u:
            {
                errorStr = "PDERR_LOADDRVFAILURE";
                break;
            }
            case 0x1008u:
            {
                errorStr = "PDERR_NODEFAULTPRN";
                break;
            }
            case 0x1007u:
            {
                errorStr = "PDERR_NODEVICES";
                break;
            }
            case 0x1002u:
            {
                errorStr = "PDERR_PARSEFAILURE";
                break;
            }
            case 0x100Bu:
            {
                errorStr = "PDERR_PRINTERNOTFOUND";
                break;
            }
            case 0x1003u:
            {
                errorStr = "PDERR_RETDEFFAILURE";
                break;
            }
            case 0x1001u:
            {
                errorStr = "PDERR_SETUPFAILURE";
                break;
            }
            case 0x2002u:
            {
                errorStr = "CFERR_MAXLESSTHANMIN";
                break;
            }
            case 0x2001u:
            {
                errorStr = "CFERR_NOFONTS";
                break;
            }
            case 0x3003u:
            {
                errorStr = "FNERR_BUFFERTOOSMALL";
                break;
            }
            case 0x3002u:
            {
                errorStr = "FNERR_INVALIDFILENAME";
                break;
            }
            case 0x3001u:
            {
                errorStr = "FNERR_SUBCLASSFAILURE";
                break;
            }
            case 0x4001u:
            {
                errorStr = "FRERR_BUFFERLENGTHZERO";
                break;
            }
            default:
            {
                errorStr = "generic error";
                break;
            }
        }
        return errorStr;
    }

    public const uint OFN_READONLY =                0x00000001u;
    public const uint OFN_OVERWRITEPROMPT =         0x00000002u;
    public const uint OFN_HIDEREADONLY =            0x00000004u;
    public const uint OFN_NOCHANGEDIR =             0x00000008u;
    public const uint OFN_SHOWHELP =                0x00000010u;
    public const uint OFN_ENABLEHOOK =              0x00000020u;
    public const uint OFN_ENABLETEMPLATE =          0x00000040u;
    public const uint OFN_ENABLETEMPLATEHANDLE =    0x00000080u;
    public const uint OFN_NOVALIDATE =              0x00000100u;
    public const uint OFN_ALLOWMULTISELECT =        0x00000200u;
    public const uint OFN_EXTENSIONDIFFERENT =      0x00000400u;
    public const uint OFN_PATHMUSTEXIST =           0x00000800u;
    public const uint OFN_FILEMUSTEXIST =           0x00001000u;
    public const uint OFN_CREATEPROMPT =            0x00002000u;
    public const uint OFN_SHAREAWARE =              0x00004000u;
    public const uint OFN_NOREADONLYRETURN =        0x00008000u;
    public const uint OFN_NOTESTFILECREATE =        0x00010000u;
    public const uint OFN_NONETWORKBUTTON =         0x00020000u;
    public const uint OFN_NOLONGNAMES =             0x00040000u;     // force no long names for 4.x modules
    public const uint OFN_EXPLORER =                0x00080000u;     // new look commdlg
    public const uint OFN_NODEREFERENCELINKS =      0x00100000u;
    public const uint OFN_LONGNAMES =               0x00200000u;     // force long names for 3.x modules

    [nodiscard]
    public Result<bool> GetOpenFileName(void* windowHandle, const List<Pair<string, string>>& descriptionFilterPairs, const string& initialDirectory,
        const string& defaultFilePath, const string& defaultExtension, uint flags, string& currentDirectory, List<string>& fileNames)
    {
        long filterBufferSize = 0;
        for (const Pair<string, string>& descriptionFilterPair : descriptionFilterPairs)
        {
            auto descriptionResult = ToUtf16(descriptionFilterPair.first);
            if (descriptionResult.Error())
            {
                return Result<bool>(ErrorId(descriptionResult.GetErrorId()));
            }
            wstring description = Rvalue(descriptionResult.Value());
            auto filterResult = ToUtf16(descriptionFilterPair.second);
            if (filterResult.Error())
            {
                return Result<bool>(ErrorId(filterResult.GetErrorId()));
            }
            wstring filter = Rvalue(filterResult.Value());
            filterBufferSize = filterBufferSize + description.Length() + 1 + filter.Length() + 1;
        }
        filterBufferSize = filterBufferSize + 1 + 1;
        UniquePtr<wchar> filterBuffer = cast<wchar*>(MemAlloc(sizeof(wchar) * filterBufferSize));
        wchar* filterBufferPtr = filterBuffer.Get();
        for (const Pair<string, string>& descriptionFilterPair : descriptionFilterPairs)
        {
            auto descriptionResult = ToUtf16(descriptionFilterPair.first);
            if (descriptionResult.Error())
            {
                return Result<bool>(ErrorId(descriptionResult.GetErrorId()));
            }
            wstring description = Rvalue(descriptionResult.Value());
            long descLen = StrCopy(filterBufferPtr, description.Chars(), description.Length());
            filterBufferPtr = filterBufferPtr + descLen + 1;
            auto filterResult = ToUtf16(descriptionFilterPair.second);
            if (filterResult.Error())
            {
                return Result<bool>(ErrorId(filterResult.GetErrorId()));
            }
            wstring filter = Rvalue(filterResult.Value());
            long filterLen = StrCopy(filterBufferPtr, filter.Chars(), filter.Length());
            filterBufferPtr = filterBufferPtr + filterLen + 1;
        }
        *filterBufferPtr++ = '\0';
        *filterBufferPtr++ = '\0';
        long fileNameBufferSize = 16 * 1024;
        UniquePtr<wchar> fileNameBuffer = cast<wchar*>(MemAlloc(sizeof(wchar) * fileNameBufferSize));
        auto defaultFilePathResult = ToUtf16(defaultFilePath);
        if (defaultFilePathResult.Error())
        {
            return Result<bool>(ErrorId(defaultFilePathResult.GetErrorId()));
        }
        wstring defFilePath = Rvalue(defaultFilePathResult.Value());
        if (defaultFilePath.IsEmpty())
        {
            *fileNameBuffer.Get() = '\0';
        }
        else
        {
            StrCopy(fileNameBuffer.Get(), defFilePath.Chars(), defFilePath.Length());
        }
        auto initialDirResult = ToUtf16(initialDirectory);
        if (initialDirResult.Error())
        {
            return Result<bool>(ErrorId(initialDirResult.GetErrorId()));
        }
        wstring initialDir = Rvalue(initialDirResult.Value());
        auto defExtResult = ToUtf16(defaultExtension);
        if (defExtResult.Error())
        {
            return Result<bool>(ErrorId(defExtResult.GetErrorId()));
        }
        wstring defExt = Rvalue(defExtResult.Value());
        bool success = WinGetOpenFileName(windowHandle, filterBuffer.Get(), initialDir.Chars(), fileNameBuffer.Get(), cast<uint>(fileNameBufferSize), flags, defExt.Chars());
        if (success)
        {
            long firstPathLength = StrLen(fileNameBuffer.Get());
            auto firstPathResult = ToUtf8(wstring(fileNameBuffer.Get(), firstPathLength));
            if (firstPathResult.Error())
            {
                return Result<bool>(ErrorId(firstPathResult.GetErrorId()));
            }
            string firstPath = Rvalue(firstPathResult.Value());
            if ((flags & OFN_ALLOWMULTISELECT) == 0)
            {
                currentDirectory = Path.GetDirectoryName(firstPath);
                fileNames.Add(Path.GetFileName(firstPath));
            }
            else
            {
                currentDirectory = firstPath;
                long pathStart = firstPathLength + 1;
                wchar* wpath = fileNameBuffer.Get() + pathStart;
                while (*wpath != '\0')
                {
                    long pathLength = StrLen(wpath);
                    auto pathResult = ToUtf8(wstring(wpath, pathLength));
                    if (pathResult.Error())
                    {
                        return Result<bool>(ErrorId(pathResult.GetErrorId()));
                    }
                    string path = Rvalue(pathResult.Value());
                    fileNames.Add(path);
                    wpath = wpath + pathLength + 1;
                }
            }
            return Result<bool>(true);
        }
        else
        {
            uint errorCode = WinCommDlgExtendedError();
            if (errorCode == 0u)
            {
                return Result<bool>(false);
            }
            else
            {
                string message = CommonDialogError(errorCode);
                int errorId = AllocateError("get open file name failed: " + message);
                return Result<bool>(ErrorId(errorId));
            }
        }
        return Result<bool>(false);
    }

    [nodiscard]
    public Result<bool> GetSaveFileName(void* windowHandle, const List<Pair<string, string>>& descriptionFilterPairs, const string& initialDirectory,
        const string& defaultFilePath, const string& defaultExtension, uint flags, string& currentDirectory, string& filePath)
    {
        long filterBufferSize = 0;
        for (const Pair<string, string>& descriptionFilterPair : descriptionFilterPairs)
        {
            auto descriptionResult = ToUtf16(descriptionFilterPair.first);
            if (descriptionResult.Error())
            {
                return Result<bool>(ErrorId(descriptionResult.GetErrorId()));
            }
            wstring description = Rvalue(descriptionResult.Value());
            auto filterResult = ToUtf16(descriptionFilterPair.second);
            if (filterResult.Error())
            {
                return Result<bool>(ErrorId(filterResult.GetErrorId()));
            }
            wstring filter = Rvalue(filterResult.Value());
            filterBufferSize = filterBufferSize + description.Length() + 1 + filter.Length() + 1;
        }
        filterBufferSize = filterBufferSize + 1 + 1;
        UniquePtr<wchar> filterBuffer = cast<wchar*>(MemAlloc(sizeof(wchar) * filterBufferSize));
        wchar* filterBufferPtr = filterBuffer.Get();
        for (const Pair<string, string>& descriptionFilterPair : descriptionFilterPairs)
        {
            auto descriptionResult = ToUtf16(descriptionFilterPair.first);
            if (descriptionResult.Error())
            {
                return Result<bool>(ErrorId(descriptionResult.GetErrorId()));
            }
            wstring description = Rvalue(descriptionResult.Value());
            long descLen = StrCopy(filterBufferPtr, description.Chars(), description.Length());
            filterBufferPtr = filterBufferPtr + descLen + 1;
            auto filterResult = ToUtf16(descriptionFilterPair.second);
            if (filterResult.Error())
            {
                return Result<bool>(ErrorId(filterResult.GetErrorId()));
            }
            wstring filter = Rvalue(filterResult.Value());
            long filterLen = StrCopy(filterBufferPtr, filter.Chars(), filter.Length());
            filterBufferPtr = filterBufferPtr + filterLen + 1;
        }
        *filterBufferPtr++ = '\0';
        *filterBufferPtr++ = '\0';
        long fileNameBufferSize = 1024;
        UniquePtr<wchar> fileNameBuffer = cast<wchar*>(MemAlloc(sizeof(wchar) * fileNameBufferSize));
        auto defFilePathResult = ToUtf16(defaultFilePath);
        if (defFilePathResult.Error())
        {
            return Result<bool>(ErrorId(defFilePathResult.GetErrorId()));
        }
        wstring defFilePath = Rvalue(defFilePathResult.Value());
        if (defaultFilePath.IsEmpty())
        {
            *fileNameBuffer.Get() = '\0';
        }
        else
        {
            StrCopy(fileNameBuffer.Get(), defFilePath.Chars(), defFilePath.Length());
        }
        auto initialDirResult = ToUtf16(initialDirectory);
        if (initialDirResult.Error())
        {
            return Result<bool>(ErrorId(initialDirResult.GetErrorId()));
        }
        wstring initialDir = Rvalue(initialDirResult.Value());
        auto defExtResult = ToUtf16(defaultExtension);
        if (defExtResult.Error())
        {
            return Result<bool>(ErrorId(defExtResult.GetErrorId()));
        }
        wstring defExt = Rvalue(defExtResult.Value());
        bool success = WinGetSaveFileName(windowHandle, filterBuffer.Get(), initialDir.Chars(), fileNameBuffer.Get(), cast<uint>(fileNameBufferSize), flags, defExt.Chars());
        if (success)
        {
            long firstPathLength = StrLen(fileNameBuffer.Get());
            auto filePathResult = ToUtf8(wstring(fileNameBuffer.Get(), firstPathLength));
            if (filePathResult.Error())
            {
                return Result<bool>(ErrorId(filePathResult.GetErrorId()));
            }
            filePath = Rvalue(filePathResult.Value());
            return Result<bool>(true);
        }
        else
        {
            uint errorCode = WinCommDlgExtendedError();
            if (errorCode == 0u)
            {
                return Result<bool>(false);
            }
            else
            {
                string message = CommonDialogError(errorCode);
                int errorId = AllocateError("get save file name failed: " + message);
                return Result<bool>(ErrorId(errorId));
            }
        }
        return Result<bool>(false);
    }

    [nodiscard]
    public Result<void*> LoadImage(const char* name, uint type, int cx, int cy)
    {
        void* result = WinLoadImage(name, type, cx, cy);
        if (result == null)
        {
            int errorId = WinAllocateWindowsError("load image failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        return Result<void*>(result);
    }

    [nodiscard]
    public Result<void*> LoadCursor(const char* name)
    {
        void* result = WinLoadCursor(name);
        if (result == null)
        {
            int errorId = WinAllocateWindowsError("load cursor failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        return Result<void*>(result);
    }

    [nodiscard]
    public Result<void*> LoadIcon(const char* name)
    {
        void* result = WinLoadIcon(name);
        if (result == null)
        {
            int errorId = WinAllocateWindowsError("load icon failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        return Result<void*>(result);
    }

    [nodiscard]
    public Result<void*> LoadBitmap(const char* name)
    {
        void* result = WinLoadBitmap(name);
        if (result == null)
        {
            int errorId = WinAllocateWindowsError("load bitmap failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        return Result<void*>(result);
    }

    [nodiscard]
    public Result<int> GetSystemMetrics(int index)
    {
        int result = WinGetSystemMetrics(index);
        if (result == 0)
        {
            int errorId = WinAllocateWindowsError("get system metrics failed", WinGetLastError());
            return Result<int>(ErrorId(errorId));
        }
        return Result<int>(result);
    }

    public void* GetTopWindow(void* windowHandle)
    {
        return WinGetTopWindow(windowHandle);
    }

    [nodiscard]
    public Result<bool> BringWindowToTop(void* windowHandle)
    {
        bool succeeded = WinBringWindowToTop(windowHandle);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("bring window to top failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    public enum WindowPos : int
    {
        top = 0, bottom = 1, topmost = -1, noTopmost = -2
    }

    public void* WindowPosHandle(WindowPos pos)
    {
        return cast<void*>(cast<ulong>(cast<int>(pos)));
    }

    public enum SetWindowPosFlags : uint
    {
        SWP_ASYNCWINDOWPOS = 0x4000u,
        SWP_DEFERERASE = 0x2000u,
        SWP_DRAWFRAME = 0x20u,
        SWP_FRAMECHANGED = 0x20u,
        SWP_HIDEWINDOW = 0x80u,
        SWP_NOACTIVATE = 0x10u,
        SWP_NOCOPYBITS = 0x100u,
        SWP_NOMOVE = 0x2u,
        SWP_NOOWNERZORDER = 0x200u,
        SWP_NOREDRAW = 0x8u,
        SWP_NOREPOSITION = 0x200u,
        SWP_NOSENDCHANGING = 0x400u,
        SWP_NOSIZE = 0x1u,
        SWP_NOZORDER = 0x4u,
        SWP_SHOWWINDOW = 0x40u
    }

    [nodiscard]
    public Result<bool> SetWindowPos(void* windowHandle, void* insertAfterWindowHandle, int x, int y, int cx, int cy, SetWindowPosFlags flags)
    {
        bool succeeded = WinSetWindowPos(windowHandle, insertAfterWindowHandle, x, y, cx, cy, cast<uint>(flags));
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("set window pos failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    public enum ClassLongIndex : int
    {
        GCL_CBCLSEXTRA = -20,
        GCL_CBWNDEXTRA = -18,
        GCL_HBRBACKGROUND = -10,
        GCL_HCURSOR = -12,
        GCL_HICON = -14,
        GCL_HICONSM = -34,
        GCL_HMODULE = -16,
        GCL_MENUNAME = -8,
        GCL_STYLE = -26,
        GCL_WNDPROC = -24
    }

    [nodiscard]
    public Result<long> GetClassLong(void* windowHandle, ClassLongIndex index)
    {
        long value = WinGetClassLong(windowHandle, cast<int>(index));
        if (value == 0)
        {
            ulong errorCode = WinGetLastError();
            if (errorCode != 0u)
            {
                int errorId = WinAllocateWindowsError("get class long failed", errorCode);
                return Result<long>(ErrorId(errorId));
            }
        }
        return Result<long>(value);
    }

    [nodiscard]
    public Result<long> SetClassLong(void* windowHandle, ClassLongIndex index, long newValue)
    {
        long value = WinSetClassLong(windowHandle, cast<int>(index), newValue);
        if (value == 0)
        {
            ulong errorCode = WinGetLastError();
            if (errorCode != 0u)
            {
                int errorId = WinAllocateWindowsError("set class long failed", errorCode);
                return Result<long>(ErrorId(errorId));
            }
        }
        return Result<long>(value);
    }

    public enum WindowLongIndex : int
    {
        GWL_EXSTYLE = -20,
        GWLP_HINSTANCE = -6,
        GWLP_ID = -12,
        GWL_STYLE = -16,
        GWLP_USERDATA = -21,
        GWLP_WNDPROC = -4
    }

    [nodiscard]
    public Result<long> GetWindowLong(void* windowHandle, WindowLongIndex index)
    {
        long value = WinGetWindowLong(windowHandle, cast<int>(index));
        if (value == 0)
        {
            int errorId = WinAllocateWindowsError("get window long failed", WinGetLastError());
            return Result<long>(ErrorId(errorId));
        }
        return Result<long>(value);
    }

    [nodiscard]
    public Result<bool> SetWindowLong(void* windowHandle, WindowLongIndex index, long newValue)
    {
        bool succeeded = WinSetWindowLong(windowHandle, cast<int>(index), newValue);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("set window long failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> ScrollWindow(void* windowHandle, int xAmount, int yAmount, const Rect* clientRect, const Rect* clipRect)
    {
        int clientLocX = 0;
        int clientLocY = 0;
        int clientSizeW = 0;
        int clientSizeH = 0;
        if (clientRect != null)
        {
            clientLocX = clientRect->location.x;
            clientLocY = clientRect->location.y;
            clientSizeW = clientRect->size.w;
            clientSizeH = clientRect->size.h;
        }
        int clipLocX = 0;
        int clipLocY = 0;
        int clipSizeW = 0;
        int clipSizeH = 0;
        if (clipRect != null)
        {
            clipLocX = clipRect->location.x;
            clipLocY = clipRect->location.y;
            clipSizeW = clipRect->size.w;
            clipSizeH = clipRect->size.h;
        }
        bool succeeded = WinScrollWindow(windowHandle, xAmount, yAmount, clientLocX, clientLocY, clientSizeW, clientSizeH, clipLocX, clipLocY, clipSizeW, clipSizeH);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("scroll window failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> ScrollWindowEx(void* windowHandle, int dx, int dy, const Rect* clientRect, const Rect* clipRect, const Rect& updateRect)
    {
        int clientLocX = 0;
        int clientLocY = 0;
        int clientSizeW = 0;
        int clientSizeH = 0;
        if (clientRect != null)
        {
            clientLocX = clientRect->location.x;
            clientLocY = clientRect->location.y;
            clientSizeW = clientRect->size.w;
            clientSizeH = clientRect->size.h;
        }
        int clipLocX = 0;
        int clipLocY = 0;
        int clipSizeW = 0;
        int clipSizeH = 0;
        if (clipRect != null)
        {
            clipLocX = clipRect->location.x;
            clipLocY = clipRect->location.y;
            clipSizeW = clipRect->size.w;
            clipSizeH = clipRect->size.h;
        }
        int x1 = updateRect.location.x;
        int y1 = updateRect.location.y;
        int x2 = updateRect.location.x + updateRect.size.w;
        int y2 = updateRect.location.y + updateRect.size.h;
        bool succeeded = WinScrollWindowEx(windowHandle, dx, dy, clientLocX, clientLocY, clientSizeW, clientSizeH, clipLocX, clipLocY, clipSizeW, clipSizeH, x1, y1, x2, y2);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("scroll window ex failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    public enum ScrollBar : int
    {
        SB_BOTH = 3,
        SB_CTL = 2,
        SB_HORZ = 0,
        SB_VERT = 1
    }

    [nodiscard]
    public Result<bool> GetScrollInfo(void* windowHandle, ScrollBar scrollBar, uint& nPage, int& nPos, int& nMin, int& nMax, int& nTrackPos)
    {
        bool succeeded = WinGetScrollInfo(windowHandle, cast<int>(scrollBar), nPage, nPos, nMin, nMax, nTrackPos);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("get scroll info failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    public enum ScrollInfoMask : uint
    {
        SIF_DISABLENOSCROLL = 8u,
        SIF_PAGE = 2u,
        SIF_POS = 4u,
        SIF_RANGE = 1u
    }

    public int SetScrollInfo(void* windowHandle, ScrollBar scrollBar, ScrollInfoMask mask, bool redraw, uint nPage, int nPos, int nMin, int nMax)
    {
        return WinSetScrollInfo(windowHandle, cast<int>(scrollBar), cast<uint>(mask), redraw, nPage, nPos, nMin, nMax);
    }

    [nodiscard]
    public Result<bool> ShowScrollBar(void* windowHandle, ScrollBar scrollBar, bool show)
    {
        bool succeeded = WinShowScrollBar(windowHandle, cast<int>(scrollBar), show);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("show scroll bar failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> CreateCaret(void* windowHandle, void* bitmapHandle, int width, int height)
    {
        bool succeeded = WinCreateCaret(windowHandle, bitmapHandle, width, height);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("create caret failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> DestroyCaret()
    {
        bool succeeded = WinDestroyCaret();
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("destroy caret failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> ShowCaret(void* windowHandle)
    {
        bool succeeded = WinShowCaret(windowHandle);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("show caret failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> HideCaret(void* windowHandle)
    {
        bool succeeded = WinHideCaret(windowHandle);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("hide caret failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<Point> GetCaretPos()
    {
        Point caretPos;
        bool succeeded = WinGetCaretPos(caretPos.x, caretPos.y);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("get caret pos failed", WinGetLastError());
            return Result<Point>(ErrorId(errorId));
        }
        return Result<Point>(caretPos);
    }

    [nodiscard]
    public Result<bool> SetCaretPos(const Point& caretPos)
    {
        bool succeeded = WinSetCaretPos(caretPos.x, caretPos.y);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("set caret pos failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> SetTimer(void* windowHandle, uint timerId, uint elapseMs)
    {
        bool succeeded = WinSetTimer(windowHandle, timerId, elapseMs);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("set timer failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> KillTimer(void* windowHandle, uint timerId)
    {
        bool succeeded = WinKillTimer(windowHandle, timerId);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("kill timer failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<uint> RegisterClipboardFormat(const char* formatName)
    {
        uint format = WinRegisterClipboardFormat(formatName);
        if (format == 0u)
        {
            int errorId = WinAllocateWindowsError("register clipboard format failed", WinGetLastError());
            return Result<uint>(ErrorId(errorId));
        }
        return Result<uint>(format);
    }

    [nodiscard]
    public Result<bool> OpenClipboard(void* windowHandle)
    {
        uint maxWait = 100u;
        for (int i = 0; i < 5; ++i)
        {
            bool succeeded = WinOpenClipboard(windowHandle);
            if (succeeded)
            {
                return Result<bool>(true);
            }
            else if (i < 4)
            {
                Sleep(Duration.FromMilliseconds(Random() % maxWait));
                maxWait = maxWait * 2u;
            }
        }
        int errorId = WinAllocateWindowsError("open clipboard failed", WinGetLastError());
        return Result<bool>(ErrorId(errorId));
    }

    [nodiscard]
    public Result<bool> CloseClipboard()
    {
        bool succeeded = WinCloseClipboard();
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("close clipboard failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> EmptyClipboard()
    {
        bool succeeded = WinEmptyClipboard();
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("empty clipboard failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<void*> SetClipboardData(uint format, void* mem)
    {
        void* retval = WinSetClipboardData(format, mem);
        if (retval == null)
        {
            int errorId = WinAllocateWindowsError("set clipboard data failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        return Result<void*>(retval);
    }

    [nodiscard]
    public Result<void*> GetClipboardData(uint format)
    {
        void* retval = WinGetClipboardData(format);
        if (retval == null)
        {
            int errorId = WinAllocateWindowsError("get clipboard data failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        return Result<void*>(retval);
    }

    public bool IsClipboardFormatAvailable(uint format)
    {
        return WinIsClipboardFormatAvailable(format);
    }

    [nodiscard]
    public Result<bool> AddClipboardFormatListener(void* windowHandle)
    {
        bool succeeded = WinAddClipboardFormatListener(windowHandle);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("add clipboard format listener failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> RemoveClipboardFormatListener(void* windowHandle)
    {
        bool succeeded = WinRemoveClipboardFormatListener(windowHandle);
        if (!succeeded)
        {
            int errorId = WinAllocateWindowsError("remove clipboard format listener failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    public enum GlobalAllocFlags : uint
    {
        GMEM_FIXED = 0x0u,
        GHND = 0x0042u,
        GMEM_MOVEABLE = 0x0002u,
        GMEM_ZEROINIT = 0x0040u,
        GPTR = 0x0040u
    }

    [nodiscard]
    public Result<void*> GlobalAlloc(GlobalAllocFlags flags, ulong size)
    {
        void* retval = WinGlobalAlloc(cast<uint>(flags), size);
        if (retval == null)
        {
            int errorId = WinAllocateWindowsError("global alloc failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        return Result<void*>(retval);
    }

    [nodiscard]
    public Result<void*> GlobalLock(void* memHandle)
    {
        void* retval = WinGlobalLock(memHandle);
        if (retval == null)
        {
            int errorId = WinAllocateWindowsError("global lock failed", WinGetLastError());
            return Result<void*>(ErrorId(errorId));
        }
        return Result<void*>(retval);
    }

    [nodiscard]
    public Result<bool> GlobalUnlock(void* memHandle)
    {
        bool retval = WinGlobalUnlock(memHandle);
        if (!retval)
        {
            ulong error = WinGetLastError();
            if (error != 0u)
            {
                int errorId = WinAllocateWindowsError("global unlock failed", error);
                return Result<bool>(ErrorId(errorId));
            }
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<bool> GlobalFree(void* memHandle)
    {
        void* retval = WinGlobalFree(memHandle);
        if (retval != null)
        {
            int errorId = WinAllocateWindowsError("global free failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<ulong> GlobalSize(void* memHandle)
    {
        ulong size = WinGlobalSize(memHandle);
        if (size == 0u)
        {
            int errorId = WinAllocateWindowsError("global size failed", WinGetLastError());
            return Result<ulong>(ErrorId(errorId));
        }
        return Result<ulong>(size);
    }

    [nodiscard]
    public Result<bool> GetCursorPos(int& x, int& y)
    {
        if (!WinGetCursorPos(x, y))
        {
            int errorId = WinAllocateWindowsError("get cursor pos failed", WinGetLastError());
            return Result<bool>(ErrorId(errorId));
        }
        return Result<bool>(true);
    }

    [nodiscard]
    public Result<string> GetFolder(void* windowHandle, const string& defaultDirectory)
    {
        auto defaultDirResult = ToUtf16(defaultDirectory);
        if (defaultDirResult.Error())
        {
            return Result<string>(ErrorId(defaultDirResult.GetErrorId()));
        }
        wstring defaultDir = Rvalue(defaultDirResult.Value());
        long folderNameBufferSize = 1024;
        UniquePtr<wchar> folderNameBuffer = cast<wchar*>(MemAlloc(sizeof(wchar) * folderNameBufferSize));
        bool success = WinGetFolder(windowHandle, defaultDir.Chars(), folderNameBuffer.Get(), cast<uint>(folderNameBufferSize));
        if (success)
        {
            wstring folderName(folderNameBuffer.Get());
            auto utf8Result = ToUtf8(folderName);
            if (utf8Result.Error())
            {
                return utf8Result;
            }
            else
            {
                return Result<string>(utf8Result.Value());
            }
        }
        else
        {
            int errorId = AllocateError("GetFolder failed");
            return Result<string>(ErrorId(errorId));
        }
    }
}
