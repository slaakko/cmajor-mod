// =================================
// Copyright (c) 2024 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;

namespace System.Windows
{
    public Color DefaultToolTipWindowColor()
    {
        return Color.FloralWhite();
    }

    public Color DefaultToolButtonTransparentColor()
    {
        return Color.DefaultBitmapTransparent();
    }

    public int DefaultToolButtonHeight()
    {
        return 38;
    }

    public ToolBar.Style DefaultToolBarStyle()
    {
        return ToolBar.Style.regular;
    }

    public Padding DefaultToolBarPadding()
    {
        return Padding(0, 0, 0, 0);
    }

    public Padding DefaultToolButtonPadding()
    {
        return Padding(0, 0, 0, 0);
    }

    public Color DefaultToolBarDarkColor()
    {
        return Color(100u, 100u, 100u);
    }

    public Color DefaultToolBarLightColor()
    {
        return Color.White();
    }

    public Color DefaultToolBarMediumLightColor()
    {
        return Color(227u, 227u, 227u);
    }

    public Color DefaultToolBarMediumDarkColor()
    {
        return Color(160u, 160u, 160u);
    }

    public Color DefaultToolBarDisabledColor()
    {
        return Color(204u, 204u, 207u);
    }

    public Color DefaultToolBarToolButtonSeparatorColor1()
    {
        return Color(204u, 206u, 219u);
    }

    public Color DefaultToolBarToolButtonSeparatorColor2()
    {
        return Color(245u, 245u, 245u);
    }

    public ControlCreateParams& ToolBarControlCreateParams(ControlCreateParams& controlCreateParams,
        const Padding& padding,
        const Padding& buttonPadding,
        int toolButtonHeight)
    {
        return controlCreateParams.SetWindowClassName("System.Windows.ToolBar").SetLocation(Point(padding.left, padding.top)).
            SetSize(Size(0, toolButtonHeight + padding.Vertical() + buttonPadding.Vertical())).SetDock(Dock.top);
    }

    public ControlCreateParams& ToolBarControlCreateParams(ControlCreateParams& controlCreateParams)
    {
        return ToolBarControlCreateParams(controlCreateParams, DefaultToolBarPadding(), DefaultToolButtonPadding(), DefaultToolButtonHeight());
    }

    public class ToolBarCreateParams
    {
        public ToolBarCreateParams(ControlCreateParams& controlCreateParams_) :
            controlCreateParams(controlCreateParams_),
            toolTipWindowColor(DefaultToolTipWindowColor()),
            toolButtonTransparentColor(DefaultToolButtonTransparentColor()),
            toolButtonHeight(DefaultToolButtonHeight()),
            style(DefaultToolBarStyle()),
            padding(DefaultToolBarPadding()),
            buttonPadding(DefaultToolButtonPadding()),
            darkColor(DefaultToolBarDarkColor()),
            lightColor(DefaultToolBarLightColor()),
            mediumLightColor(DefaultToolBarMediumLightColor()),
            mediumDarkColor(DefaultToolBarMediumDarkColor()),
            disabledColor(DefaultToolBarDisabledColor()),
            toolButtonSeparatorColor1(DefaultToolBarToolButtonSeparatorColor1()),
            toolButtonSeparatorColor2(DefaultToolBarToolButtonSeparatorColor2())
        {
        }
        public ToolBarCreateParams& Defaults()
        {
            return *this;
        }
        public ToolBarCreateParams& SetToolTipWindowColor(const Color& toolTipWindowColor_)
        {
            toolTipWindowColor = toolTipWindowColor_;
            return *this;
        }
        public ToolBarCreateParams& SetToolButtonTransparentColor(const Color& toolButtonTransparentColor_)
        {
            toolButtonTransparentColor = toolButtonTransparentColor_;
            return *this;
        }
        public ToolBarCreateParams& SetToolButtonHeight(int toolButtonHeight_)
        {
            toolButtonHeight = toolButtonHeight_;
            return *this;
        }
        public ToolBarCreateParams& SetStyle(ToolBar.Style style_)
        {
            style = style_;
            return *this;
        }
        public ToolBarCreateParams& SetPadding(const Padding& padding_)
        {
            padding = padding_;
            return *this;
        }
        public ToolBarCreateParams& SetButtonPadding(const Padding& buttonPadding_)
        {
            buttonPadding = buttonPadding_;
            return *this;
        }
        public ToolBarCreateParams& SetDarkColor(const Color& darkColor_)
        {
            darkColor = darkColor_;
            return *this;
        }
        public ToolBarCreateParams& SetLightColor(const Color& lightColor_)
        {
            lightColor = lightColor_;
            return *this;
        }
        public ToolBarCreateParams& SetMediumLightColor(const Color& mediumLightColor_)
        {
            mediumLightColor = mediumLightColor_;
            return *this;
        }
        public ToolBarCreateParams& SetMediumDarkColor(const Color& mediumDarkColor_)
        {
            mediumDarkColor = mediumDarkColor_;
            return *this;
        }
        public ToolBarCreateParams& SetDisabledColor(const Color& disabledColor_)
        {
            disabledColor = disabledColor_;
            return *this;
        }
        public ToolBarCreateParams& SetToolButtonSeparatorColor1(const Color& toolButtonSeparatorColor1_)
        {
            toolButtonSeparatorColor1 = toolButtonSeparatorColor1_;
            return *this;
        }
        public ToolBarCreateParams& SetToolButtonSeperatorColor2(const Color& toolButtonSeparatorColor2_)
        {
            toolButtonSeparatorColor2 = toolButtonSeparatorColor2_;
            return *this;
        }
        public ControlCreateParams& controlCreateParams;
        public Color toolTipWindowColor;
        public Color toolButtonTransparentColor;
        public int toolButtonHeight;
        public ToolBar.Style style;
        public Padding padding;
        public Padding buttonPadding;
        public Color darkColor;
        public Color lightColor;
        public Color mediumLightColor;
        public Color mediumDarkColor;
        public Color disabledColor;
        public Color toolButtonSeparatorColor1;
        public Color toolButtonSeparatorColor2;
    }

    public class ToolBar : Control
    {
        private enum Flags : sbyte
        {
            none = 0, toolTipWindowAdded = 1 << 0, toolTipWindowVisible = 1 << 1
        }
        public enum Style
        {
            regular = 0, radioButtonGroup = 1
        }
        public ToolBar(const Color& backgroundColor, const Color& toolTipWindowColor, const Color& toolButtonTransparentColor_, const Point& location,
            const Size& size, Dock dock, Anchors anchors,
            int toolButtonHeight_, Style style_, const Padding& padding_, const Padding& buttonPadding_) :
            base("System.Windows.ToolBar", DefaultWindowClassStyle(), DefaultChildWindowStyle(), DefaultExtendedWindowStyle(),
            backgroundColor, "toolBar", location, size, dock, anchors), flags(Flags.none), toolButtonTransparentColor(toolButtonTransparentColor_),
            toolButtonHeight(toolButtonHeight_), darkColor(Color(100u, 100u, 100u)), lightColor(Color.White()), mediumLightColor(227u, 227u, 227u),
            mediumDarkColor(160u, 160u, 160u), disabledColor(Color(204u, 204u, 207u)),
            toolButtonSeparatorColor1(204u, 206u, 219u), toolButtonSeparatorColor2(245u, 245u, 245u), mouseInToolButton(null), mouseDownToolButton(null),
            pressedStateToolButton(null), style(style_), toolTipWindow(new ToolTip(toolTipWindowColor)), padding(padding_), buttonPadding(buttonPadding_),
            toolButtons(this), centerFormat(StringAlignment.center, StringAlignment.center)
        {
            SetMouseHoverMs(DefaultMouseHoverMs());
            if (toolTipWindow->Error())
            {
                SetErrorId(toolTipWindow->GetErrorId());
            }
        }
        public ToolBar(int toolButtonHeight, const Color& toolTipWindowColor, const Color& toolButtonTransparentColor, Style style,
            const Padding& padding, const Padding& buttonPadding) :
            this(DefaultControlBackgroundColor(), toolTipWindowColor, toolButtonTransparentColor, Point(padding.left, padding.top),
                Size(0, toolButtonHeight + padding.Vertical() + buttonPadding.Vertical()), Dock.top, Anchors.none, toolButtonHeight, style,
                padding, buttonPadding)
        {
        }
        public ToolBar(Style style) : this(38, Color.FloralWhite(), Color.DefaultBitmapTransparent(), style, DefaultPadding(), DefaultButtonPadding())
        {
        }
        public ToolBar() : this(Style.regular)
        {
        }
        public ToolBar(ToolBarCreateParams& createParams) :
            base(createParams.controlCreateParams),
            flags(Flags.none), toolButtonTransparentColor(createParams.toolButtonTransparentColor),
            toolButtonHeight(createParams.toolButtonHeight),
            darkColor(createParams.darkColor),
            lightColor(createParams.lightColor),
            mediumLightColor(createParams.mediumLightColor),
            mediumDarkColor(createParams.mediumDarkColor),
            disabledColor(createParams.disabledColor),
            toolButtonSeparatorColor1(createParams.toolButtonSeparatorColor1),
            toolButtonSeparatorColor2(createParams.toolButtonSeparatorColor2),
            mouseInToolButton(null), mouseDownToolButton(null), pressedStateToolButton(null),
            style(createParams.style), toolTipWindow(new ToolTip(createParams.toolTipWindowColor)),
            padding(createParams.padding),
            buttonPadding(createParams.buttonPadding),
            toolButtons(this),
            centerFormat(StringAlignment.center, StringAlignment.center)
        {
            SetMouseHoverMs(DefaultMouseHoverMs());
            if (toolTipWindow->Error())
            {
                SetErrorId(toolTipWindow->GetErrorId());
            }
        }
        public void SetTextToolButtonFont(const Font& textToolButtonFont_)
        {
            textToolButtonFont = textToolButtonFont_;
        }
        public inline const Font& GetTextToolButtonFont() const
        {
            return textToolButtonFont;
        }
        public inline const StringFormat& CenterFormat() const
        {
            return centerFormat;
        }
        public inline const int ToolButtonHeight() const
        {
            return toolButtonHeight;
        }
        public override Padding DefaultPadding() const
        {
            return Padding(0, 0, 0, 0);
        }
        public Padding DefaultButtonPadding()
        {
            return Padding(0, 0, 0, 0);
        }
        public const Padding& GetPadding() const
        {
            return padding;
        }
        public const Padding& GetButtonPadding()
        {
            return buttonPadding;
        }
        public void SetButtonPadding(const Padding& buttonPadding_)
        {
            buttonPadding = buttonPadding_;
        }
        public ~ToolBar()
        {
            if (toolTipWindow != null && ToolTipWindowAdded())
            {
                ResetToolTipWindowAdded();
                Window* window = GetWindow();
                if (window != null)
                {
                    auto result = window->RemoveChild(toolTipWindow);
                    toolTipWindow = null;
                }
            }
        }
        public inline Style GetStyle() const
        {
            return style;
        }
        public inline const Color& DarkColor() const
        {
            return darkColor;
        }
        public void SetDarkColor(const Color& darkColor_)
        {
            darkColor = darkColor_;
        }
        public inline const Color& LightColor() const
        {
            return lightColor;
        }
        public void SetLightColor(const Color& lightColor_)
        {
            lightColor = lightColor_;
        }
        public inline const Color& MediumLightColor() const
        {
            return mediumLightColor;
        }
        public void SetMediumLightColor(const Color& mediumLightColor_)
        {
            mediumLightColor = mediumLightColor_;
        }
        public inline const Color& MediumDarkColor() const
        {
            return mediumDarkColor;
        }
        public void SetMediumDarkColor(const Color& mediumDarkColor_)
        {
            mediumDarkColor = mediumDarkColor_;
        }
        public inline const Color& DisabledColor() const
        {
            return disabledColor;
        }
        public void SetDisabledColor(const Color& disabledColor_)
        {
            disabledColor = disabledColor_;
        }
        public inline const Color& ToolButtonSeparatorColor1() const
        {
           return toolButtonSeparatorColor1;
        }
        public void SetToolButtonSeparatorColor1(const Color& toolButtonSeparatorColor1_)
        {
            toolButtonSeparatorColor1 = toolButtonSeparatorColor1_;
        }
        public inline const Color& ToolButtonSeparatorColor2() const
        {
           return toolButtonSeparatorColor2;
        }
        public void SetToolButtonSeparatorColor2(const Color& toolButtonSeparatorColor2_)
        {
            toolButtonSeparatorColor2 = toolButtonSeparatorColor2_;
        }
        [nodiscard]
        public Result<bool> AddToolButton(ToolButtonBase* toolButton)
        {
            toolButton->SetToolBar(this);
            auto result = toolButtons.AddChild(toolButton);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            if (toolButton is ToolButton*)
            {
                ToolButton* tb = cast<ToolButton*>(toolButton);
                tb->SetTransparentColor(toolButtonTransparentColor);
                auto result = SetToolButtonBitmaps(tb);
                if (result.Error())
                {
                    return Result<bool>(ErrorId(result.GetErrorId()));
                }
                if (style == Style.radioButtonGroup)
                {
                    if (pressedStateToolButton == null)
                    {
                        auto result = SetPressedStateToolButton(tb);
                        if (result.Error()) return result;
                    }
                }
            }
            return Result<bool>(true);
        }
        public ToolButton* GetToolButton(int toolButtonIndex) const
        {
            Component* component = toolButtons.FirstChild();
            int index = 0;
            while (component != null)
            {
                if (component is ToolButton*)
                {
                    if (index == toolButtonIndex) return cast<ToolButton*>(component);
                    ++index;
                }
                component = component->NextSibling();
            }
            return null;
        }
        public inline ToolButton* PressedStateToolButton() const
        {
            if (style == Style.radioButtonGroup)
            {
                return pressedStateToolButton;
            }
            else
            {
                return null;
            }
        }
        [nodiscard]
        public Result<bool> SetPressedStateToolButton(ToolButton* newPressedStateToolButton)
        {
            if (style == Style.radioButtonGroup)
            {
                if (pressedStateToolButton != newPressedStateToolButton)
                {
                    if (pressedStateToolButton != null)
                    {
                        auto result = pressedStateToolButton->SetState(ToolButton.State.normal);
                        if (result.Error()) return result;
                    }
                    pressedStateToolButton = newPressedStateToolButton;
                    if (pressedStateToolButton != null)
                    {
                        auto result = pressedStateToolButton->SetState(ToolButton.State.pressed);
                        if (result.Error()) return result;
                    }
                }
            }
            return Result<bool>(true);
        }
        public void ResetPressedStateToolButton()
        {
            if (style == Style.radioButtonGroup)
            {
                pressedStateToolButton = null;
            }
        }
        [nodiscard]
        protected override Result<bool> OnPaint(PaintEventArgs& args)
        {
            if (!ToolTipWindowAdded())
            {
                SetToolTipWindowAdded();
                Window* window = GetWindow();
                if (window != null)
                {
                    auto result = window->AddChild(toolTipWindow);
                    if (result.Error()) return result;
                }
            }
            auto result = args.graphics.Clear(BackgroundColor());
            if (result.Error()) return result;
            Point origin(padding.left, padding.top);
            Component* component = toolButtons.FirstChild();
            while (component != null)
            {
                if (component is ToolButtonBase*)
                {
                    ToolButtonBase* toolButton = cast<ToolButtonBase*>(component);
                    Size toolButtonSize = toolButton->GetSize();
                    Point toolButtonLocation = origin;
                    toolButtonLocation.Offset(buttonPadding.left, buttonPadding.top + (toolButtonHeight - toolButtonSize.h) / 2);
                    toolButton->SetLocation(toolButtonLocation);
                    result = toolButton->Draw(args.graphics, origin);
                    if (result.Error()) return result;
                    origin.x = origin.x + toolButtonSize.w + buttonPadding.Horizontal();
                }
                component = component->NextSibling();
            }
            return base->OnPaint(args);
        }
        [nodiscard]
        protected override Result<bool> OnMouseEnter(EnterLeaveEventArgs& args)
        {
            auto result = base->OnMouseEnter(args);
            if (result.Error()) return result;
            mouseInToolButton = null;
            mouseDownToolButton = null;
            return Result<bool>(true);
        }
        [nodiscard]
        protected override Result<bool> OnMouseLeave(EnterLeaveEventArgs& args)
        {
            auto result = base->OnMouseLeave(args);
            if (result.Error()) return result;
            if (mouseInToolButton != null)
            {
                result = mouseInToolButton->MouseLeaveInternal();
                if (result.Error()) return result;
            }
            mouseInToolButton = null;
            mouseDownToolButton = null;
            result = HideToolTipWindow();
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        [nodiscard]
        protected override Result<bool> OnMouseMove(MouseEventArgs& args)
        {
            auto result = base->OnMouseMove(args);
            if (result.Error()) return result;
            ToolButton* toolButton = GetToolButtonAt(args.location);
            if (toolButton != null)
            {
                if (mouseInToolButton != toolButton)
                {
                    if (mouseInToolButton != null)
                    {
                        result = mouseInToolButton->MouseLeaveInternal();
                        if (result.Error()) return result;
                        mouseInToolButton = null;
                    }
                    mouseInToolButton = toolButton;
                    result = mouseInToolButton->MouseEnterInternal();
                    if (result.Error()) return result;
                }
                result = toolButton->MouseMoveInternal(args);
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        protected override void OnMouseHover(MouseEventArgs& args)
        {
            base->OnMouseHover(args);
            ToolButton* toolButton = GetToolButtonAt(args.location);
            if (toolButton != null)
            {
                toolButton->MouseHoverInternal();
            }
        }
        [nodiscard]
        protected override Result<bool> OnMouseDown(MouseEventArgs& args)
        {
            auto result = base->OnMouseDown(args);
            if (result.Error()) return result;
            result = HideToolTipWindow();
            if (result.Error()) return result;
            if (style == Style.regular)
            {
                ToolButton* toolButton = GetToolButtonAt(args.location);
                if (toolButton != null)
                {
                    if (toolButton->GetState() == ToolButton.State.normal)
                    {
                        if (args.buttons == MouseButtons.lbutton)
                        {
                            mouseDownToolButton = toolButton;
                        }
                        result = toolButton->MouseDownInternal(args);
                        if (result.Error()) return result;
                        if (args.buttons == MouseButtons.lbutton)
                        {
                            result = toolButton->SetState(ToolButton.State.pressed);
                            if (result.Error()) return result;
                        }
                    }
                    else
                    {
                        return Result<bool>(true);
                    }
                }
                WinSetCapture(Handle());
            }
            else if (style == Style.radioButtonGroup)
            {
                ToolButton* toolButton = GetToolButtonAt(args.location);
                if (toolButton != null)
                {
                    if (args.buttons == MouseButtons.lbutton)
                    {
                        auto result = SetPressedStateToolButton(toolButton);
                        if (result.Error()) return result;
                        result = toolButton->DoClick();
                        if (result.Error()) return result;
                    }
                }
            }
            return Result<bool>(true);
        }
        [nodiscard]
        protected override Result<bool> OnMouseUp(MouseEventArgs& args)
        {
            auto result = base->OnMouseUp(args);
            if (result.Error()) return result;
            if (style == Style.regular)
            {
                ToolButton* toolButton = GetToolButtonAt(args.location);
                if (toolButton != null)
                {
                    if (toolButton->GetState() == ToolButton.State.pressed)
                    {
                        toolButton->MouseUpInternal(args);
                        if (args.buttons == MouseButtons.lbutton)
                        {
                            if (toolButton == mouseDownToolButton)
                            {
                                auto result = toolButton->DoClick();
                                if (result.Error()) return result;
                            }
                        }
                    }
                }
                if (mouseDownToolButton != null && mouseDownToolButton->GetStyle() == ToolButton.Style.automatic)
                {
                    result = mouseDownToolButton->SetState(ToolButton.State.normal);
                    if (result.Error()) return result;
                }
                mouseDownToolButton = null;
                WinReleaseCapture();
            }
            return Result<bool>(true);
        }
        internal Result<bool> ShowToolTipWindow(ToolButton* toolButton)
        {
            if (toolTipWindow == null || !ToolTipWindowAdded()) return Result<bool>(false);
            if (ToolTipWindowVisible())
            {
                auto result = toolTipWindow->Hide();
                if (result.Error()) return result;
            }
            ResetToolTipWindowVisible();
            Point loc = toolButton->Location();
            Size size = toolButton->GetSize();
            auto result = toolTipWindow->SetText(toolButton->GetToolTip());
            if (result.Error()) return result;
            result = toolTipWindow->MeasureExtent();
            if (result.Error()) return result;
            Point pt(loc.x, loc.y + size.h + 8);
            auto clientToScreenResult = ClientToScreen(pt);
            if (clientToScreenResult.Error())
            {
                return Result<bool>(ErrorId(clientToScreenResult.GetErrorId()));
            }
            pt = clientToScreenResult.Value();
            Window* window = GetWindow();
            if (window != null)
            {
                auto screentToClientResult = window->ScreenToClient(pt);
                if (screentToClientResult.Error())
                {
                    return Result<bool>(ErrorId(screentToClientResult.GetErrorId()));
                }
                pt = screentToClientResult.Value();
                Size sz = toolTipWindow->GetSize();
                auto locationResult = window->Location();
                if (locationResult.Error())
                {
                    return Result<bool>(ErrorId(locationResult.GetErrorId()));
                }
                Point wloc = locationResult.Value();
                Size wsz = window->GetSize();
                if (pt.y + sz.h > wloc.y + wsz.h)
                {
                    pt.y = wloc.y + wsz.h - sz.h;
                }
                if (pt.x + sz.w > wloc.x + wsz.w)
                {
                    pt.x = wloc.x + wsz.w - sz.w;
                }
                result = toolTipWindow->SetLocation(pt);
                if (result.Error()) return result;
                result = toolTipWindow->BringToFront();
                if (result.Error()) return result;
                result = toolTipWindow->Show();
                if (result.Error()) return result;
                result = toolTipWindow->Invalidate();
                if (result.Error()) return result;
                SetToolTipWindowVisible();
            }
            return Result<bool>(true);
        }
        [nodiscard]
        internal Result<bool> HideToolTipWindow()
        {
            if (toolTipWindow == null || !ToolTipWindowAdded() || !ToolTipWindowVisible()) return Result<bool>(false);
            auto result = toolTipWindow->Hide();
            if (result.Error()) return result;
            ResetToolTipWindowVisible();
            return Result<bool>(true);
        }
        internal SolidBrush* GetOrInsertSolidBrush(const Color& color)
        {
            HashMap<Color, SolidBrush*>.ConstIterator it = textBrushMap.CFind(color);
            if (it != textBrushMap.CEnd())
            {
                return it->second;
            }
            else
            {
                UniquePtr<SolidBrush> brushPtr(new SolidBrush(color));
                SolidBrush* brush = brushPtr.Get();
                textBrushMap[color] = brushPtr.Get();
                textBrushes.Add(Rvalue(brushPtr));
                return brush;
            }
        }
        private Result<bool> SetToolButtonBitmaps(ToolButton* toolButton)
        {
            Result<Pair<Bitmap*, Bitmap*>> toolBitmapPairResult = GetOrCreateBitmaps(toolButton->ToolBitmapName());
            if (toolBitmapPairResult.Error())
            {
                return Result<bool>(ErrorId(toolBitmapPairResult.GetErrorId()));
            }
            Pair<Bitmap*, Bitmap*> toolBitmapPair = toolBitmapPairResult.Value();
            toolButton->SetToolBitmaps(toolBitmapPair.first, toolBitmapPair.second);
            return Result<bool>(true);
        }
        private Result<Pair<Bitmap*, Bitmap*>> GetOrCreateBitmaps(const string& bitmapName)
        {
            Pair<Bitmap*, Bitmap*> bitmapPair;
            if (bitmapName.IsEmpty()) return bitmapPair;
            auto it = bitmapMap.Find(bitmapName);
            if (it != bitmapMap.End())
            {
                return Result<Pair<Bitmap*, Bitmap*>>(it->second);
            }
            auto bitmapResult = Bitmap.FromResource(bitmapName);
            if (bitmapResult.Error())
            {
                return Result<Pair<Bitmap*, Bitmap*>>(ErrorId(bitmapResult.GetErrorId()));
            }
            UniquePtr<Bitmap> bitmapPtr(new Bitmap(Rvalue(bitmapResult.Value())));
            Bitmap* bitmap = bitmapPtr.Get();
            auto grayBitmapResult = bitmap->ToGrayBitmap();
            if (grayBitmapResult.Error())
            {
                return Result<Pair<Bitmap*, Bitmap*>>(ErrorId(grayBitmapResult.GetErrorId()));
            }
            UniquePtr<Bitmap> disabledBitmapPtr(new Bitmap(Rvalue(grayBitmapResult.Value())));
            Bitmap* disabledBitmap = disabledBitmapPtr.Get();
            bitmapPair = MakePair(bitmap, disabledBitmap);
            bitmapMap[bitmapName] = bitmapPair;
            bitmaps.Add(Rvalue(bitmapPtr));
            bitmaps.Add(Rvalue(disabledBitmapPtr));
            return Result<Pair<Bitmap*, Bitmap*>>(bitmapPair);
        }
        private ToolButton* GetToolButtonAt(const Point& location) const
        {
            Size size = GetSize();
            if (location.y >= 0 && location.y < size.h && location.x >= 0 && location.x < size.w)
            {
                Component* component = toolButtons.FirstChild();
                while (component != null)
                {
                    if (component is ToolButton*)
                    {
                        ToolButton* toolButton = cast<ToolButton*>(component);
                        if (location.x >= toolButton->Location().x && location.x <= toolButton->Location().x + toolButton->GetSize().w)
                        {
                            return toolButton;
                        }
                    }
                    component = component->NextSibling();
                }
            }
            return null;
        }
        private inline bool ToolTipWindowAdded() const
        {
            return (flags & Flags.toolTipWindowAdded) != Flags.none;
        }
        private inline void SetToolTipWindowAdded()
        {
            flags = cast<Flags>(flags | Flags.toolTipWindowAdded);
        }
        private inline void ResetToolTipWindowAdded()
        {
            flags = cast<Flags>(flags & ~Flags.toolTipWindowAdded);
        }
        private inline bool ToolTipWindowVisible() const
        {
            return (flags & Flags.toolTipWindowVisible) != Flags.none;
        }
        private inline void SetToolTipWindowVisible()
        {
            flags = cast<Flags>(flags | Flags.toolTipWindowVisible);
        }
        private inline void ResetToolTipWindowVisible()
        {
            flags = cast<Flags>(flags & ~Flags.toolTipWindowVisible);
        }
        private Flags flags;
        private ComponentContainer toolButtons;
        private Color toolButtonTransparentColor;
        private int toolButtonHeight;
        private List<UniquePtr<Bitmap>> bitmaps;
        private HashMap<string, Pair<Bitmap*, Bitmap*>> bitmapMap;
        private Color darkColor;
        private Color lightColor;
        private Color mediumLightColor;
        private Color mediumDarkColor;
        private Color disabledColor;
        private Color toolButtonSeparatorColor1;
        private Color toolButtonSeparatorColor2;
        private ToolButton* mouseInToolButton;
        private ToolButton* mouseDownToolButton;
        private ToolButton* pressedStateToolButton;
        private Style style;
        private ToolTip* toolTipWindow;
        private Padding padding;
        private Padding buttonPadding;
        private Font textToolButtonFont;
        private StringFormat centerFormat;
        private HashMap<Color, SolidBrush*> textBrushMap;
        private List<UniquePtr<SolidBrush>> textBrushes;
    }

    public abstract class ToolButtonBase : Component
    {
        public ToolButtonBase() : location(), size()
        {
        }
        public virtual void SetToolBar(ToolBar* toolBar_)
        {
            toolBar = toolBar_;
        }
        public inline ToolBar* GetToolBar() const
        {
            return toolBar;
        }
        public abstract Result<bool> Draw(Graphics& graphics, const Point& origin);
        public inline const Point& Location() const
        {
            return location;
        }
        public inline void SetLocation(const Point& location_)
        {
            location = location_;
        }
        public inline const Size& GetSize() const
        {
            return size;
        }
        public inline void SetSize(const Size& size_)
        {
            size = size_;
        }
        private ToolBar* toolBar;
        private Point location;
        private Size size;
    }

    public class ToolButtonSeparator : ToolButtonBase
    {
        public ToolButtonSeparator() : base()
        {
        }
        public override void SetToolBar(ToolBar* toolBar)
        {
            base->SetToolBar(toolBar);
            SetSize(Size(2, toolBar->ToolButtonHeight() - 4));
        }
        [nodiscard]
        public override Result<bool> Draw(Graphics& graphics, const Point& origin)
        {
            ToolBar* toolBar = GetToolBar();
            Point location = Location();
            Size size = GetSize();
            Point firstLineStart(origin.x, origin.y);
            Point firstLineEnd(firstLineStart.x, firstLineStart.y + size.h);
            Pen firstLinePen(toolBar->ToolButtonSeparatorColor1());
            if (firstLinePen.Error())
            {
                return Result<bool>(ErrorId(firstLinePen.GetErrorId()));
            }
            auto result = graphics.DrawLine(firstLinePen, firstLineStart, firstLineEnd);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            Point secondLineStart(origin.x + 1, origin.y + location.y);
            Point secondLineEnd(secondLineStart.x, secondLineStart.y + size.h);
            Pen secondLinePen(toolBar->ToolButtonSeparatorColor2());
            if (secondLinePen.Error())
            {
                return Result<bool>(ErrorId(secondLinePen.GetErrorId()));
            }
            result = graphics.DrawLine(secondLinePen, secondLineStart, secondLineEnd);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            return Result<bool>(true);
        }
    }

    public class ClickGuard
    {
        public explicit ClickGuard(ToolButton* toolButton_) : toolButton(toolButton_)
        {
        }
        public ~ClickGuard()
        {
            if (toolButton->GetStyle() == ToolButton.Style.automatic)
            {
                auto result = toolButton->SetState(ToolButton.State.normal);
            }
        }
        private ToolButton* toolButton;
    }

    public class ToolButton : ToolButtonBase
    {
        public enum State : sbyte
        {
            normal = 0, pressed = 1, disabled = 2
        }
        public enum Style : sbyte
        {
            automatic, manual
        }
        public ToolButton(const string& toolBitmapName_, Style style_) :
            base(), state(State.normal), toolBitmapName(toolBitmapName_), toolBitmap(null), transparentColor(Color.DefaultBitmapTransparent()), padding(DefaultPadding()),
            style(style_)
        {
        }
        public ToolButton(const string& toolBitmapName) : this(toolBitmapName, Style.automatic)
        {
        }
        public default virtual ~ToolButton();
        public inline Style GetStyle() const
        {
            return style;
        }
        [nodiscard]
        public Result<bool> Enable()
        {
            if (state == State.disabled)
            {
                auto result = SetState(State.normal);
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> Disable()
        {
            if (state == State.normal)
            {
                auto result = SetState(State.disabled);
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        public Padding GetPadding() const
        {
            return padding;
        }
        public void SetPadding(const Padding& padding_)
        {
            padding = padding_;
        }
        protected Padding DefaultPadding()
        {
            return Padding(3, 3, 3, 3);
        }
        public inline State GetState() const
        {
            return state;
        }
        [nodiscard]
        public Result<bool> SetState(State state_)
        {
            ToolBar* toolBar = GetToolBar();
            if (state != state_)
            {
                if (state_ == State.pressed)
                {
                    if (toolBar->GetStyle() == ToolBar.Style.radioButtonGroup)
                    {
                        if (toolBar->PressedStateToolButton() != this)
                        {
                            auto result = toolBar->SetPressedStateToolButton(this);
                            if (result.Error()) return result;
                        }
                    }
                }
                else if (state_ == State.normal)
                {
                    if (toolBar->GetStyle() == ToolBar.Style.radioButtonGroup)
                    {
                        if (toolBar->PressedStateToolButton() == this)
                        {
                            toolBar->ResetPressedStateToolButton();
                        }
                    }
                }
                state = state_;
                auto result = Invalidate();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> SetToolTip(const string& toolTip_)
        {
            if (toolTip != toolTip_)
            {
                toolTip = toolTip_;
                auto result = Invalidate();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        public inline const string& GetToolTip() const
        {
            return toolTip;
        }
        public void SetTransparentColor(const Color& transparentColor_)
        {
            transparentColor = transparentColor_;
        }
        [nodiscard]
        internal Result<bool> MouseEnterInternal()
        {
            EnterLeaveEventArgs args;
            auto result = OnMouseEnter(args);
            if (result.Error()) return result;
            return Result<bool>(true);
        }
        internal void MouseHoverInternal()
        {
            ToolBar* toolBar = GetToolBar();
            if (!toolTip.IsEmpty() && toolBar != null)
            {
                toolBar->ShowToolTipWindow(this);
            }
        }
        [nodiscard]
        protected virtual Result<bool> OnMouseEnter(EnterLeaveEventArgs& args)
        {
            mouseEnterEvent.Fire(args);
            if (args.errorId != 0)
            {
                return Result<bool>(ErrorId(args.errorId));
            }
            return Result<bool>(true);
        }
        public Event<MouseEnterEventHandler, EnterLeaveEventArgs>& MouseEnterEvent() const
        {
            return mouseEnterEvent;
        }
        [nodiscard]
        internal Result<bool> MouseLeaveInternal()
        {
            EnterLeaveEventArgs args;
            auto result = OnMouseLeave(args);
            if (result.Error()) return result;
            ToolBar* toolBar = GetToolBar();
            if (!toolTip.IsEmpty() && toolBar != null)
            {
                auto result = toolBar->HideToolTipWindow();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        [nodiscard]
        protected virtual Result<bool> OnMouseLeave(EnterLeaveEventArgs& args)
        {
            mouseLeaveEvent.Fire(args);
            if (args.errorId != 0)
            {
                return Result<bool>(ErrorId(args.errorId));
            }
            return Result<bool>(true);
        }
        public Event<MouseLeaveEventHandler, EnterLeaveEventArgs>& MouseLeaveEvent() const
        {
            return mouseLeaveEvent;
        }
        [nodiscard]
        internal Result<bool> MouseMoveInternal(MouseEventArgs& args)
        {
            return OnMouseMove(args);
        }
        [nodiscard]
        protected virtual Result<bool> OnMouseMove(MouseEventArgs& args)
        {
            mouseMoveEvent.Fire(args);
            return Result<bool>(true);
        }
        public Event<MouseEventHandler, MouseEventArgs>& MouseMoveEvent() const
        {
            return mouseMoveEvent;
        }
        [nodiscard]
        internal Result<bool> MouseDownInternal(MouseEventArgs& args)
        {
            return OnMouseDown(args);
        }
        [nodiscard]
        protected virtual Result<bool> OnMouseDown(MouseEventArgs& args)
        {
            mouseDownEvent.Fire(args);
            return Result<bool>(true);
        }
        public Event<MouseEventHandler, MouseEventArgs>& MouseDownEvent() const
        {
            return mouseDownEvent;
        }
        internal void MouseUpInternal(MouseEventArgs& args)
        {
            OnMouseUp(args);
        }
        protected virtual void OnMouseUp(MouseEventArgs& args)
        {
            mouseUpEvent.Fire(args);
        }
        public Event<MouseEventHandler, MouseEventArgs>& MouseUpEvent() const
        {
            return mouseUpEvent;
        }
        [nodiscard]
        internal Result<bool> DoClick()
        {
            ClickEventArgs args;
            auto result = OnClick(args);
            if (result.Error()) return result;
            if (args.errorId != 0)
            {
                return Result<bool>(ErrorId(args.errorId));
            }
            return Result<bool>(true);
        }
        [nodiscard]
        protected virtual Result<bool> OnClick(ClickEventArgs& args)
        {
            ClickGuard guard(this);
            clickEvent.Fire(args);
            return Result<bool>(true);
        }
        public Event<ClickEventHandler, ClickEventArgs>& ClickEvent() const
        {
            return clickEvent;
        }
        [nodiscard]
        public override Result<bool> Draw(Graphics& graphics, const Point& location)
        {
            switch (state)
            {
                case State.normal:
                case State.disabled:
                {
                    return DrawNormalOrDisabled(graphics, location);
                }
                case State.pressed:
                {
                    return DrawPressed(graphics, location);
                }
            }
            return Result<bool>(true);
        }
        private Result<bool> DrawNormalOrDisabled(Graphics& graphics, const Point& location)
        {
            ToolBar* toolBar = GetToolBar();
            Pen darkPen(toolBar->DarkColor(), 1.0f);
            if (darkPen.Error())
            {
                return Result<bool>(ErrorId(darkPen.GetErrorId()));
            }
            Size size = GetSize();
            Rect rect(location, size);
            rect.size.w = rect.size.w - 1;
            rect.size.h = rect.size.h - 1;
            auto result = graphics.DrawRectangle(darkPen, rect);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            Point startRightInnerDarkLoc = location;
            startRightInnerDarkLoc.x = startRightInnerDarkLoc.x + size.w - 2;
            Point endRightInnerDarkLoc = location;
            endRightInnerDarkLoc.x = endRightInnerDarkLoc.x + size.w - 2;
            endRightInnerDarkLoc.y = endRightInnerDarkLoc.y + size.h - 1;
            result = graphics.DrawLine(darkPen, startRightInnerDarkLoc, endRightInnerDarkLoc);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            Point startBottomInnerDarkLoc = location;
            startBottomInnerDarkLoc.x = startBottomInnerDarkLoc.x + 1;
            startBottomInnerDarkLoc.y = startBottomInnerDarkLoc.y + size.h - 2;
            Point endBottomInnerDarkLoc = location;
            endBottomInnerDarkLoc.x = endBottomInnerDarkLoc.x + size.w - 2;
            endBottomInnerDarkLoc.y = endBottomInnerDarkLoc.y + size.h - 2;
            result = graphics.DrawLine(darkPen, startBottomInnerDarkLoc, endBottomInnerDarkLoc);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            Pen lightPen(toolBar->LightColor(), 1.0f);
            Point startTopOuterLightLoc = location;
            startTopOuterLightLoc.x = startTopOuterLightLoc.x + 1;
            startTopOuterLightLoc.y = startTopOuterLightLoc.y + 1;
            Point endTopOuterLightLoc = location;
            endTopOuterLightLoc.x = endTopOuterLightLoc.x + size.w - 3;
            endTopOuterLightLoc.y = endTopOuterLightLoc.y + 1;
            result = graphics.DrawLine(lightPen, startTopOuterLightLoc, endTopOuterLightLoc);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            Point startLeftOuterLightLoc = location;
            startLeftOuterLightLoc.x = startLeftOuterLightLoc.x + 1;
            startLeftOuterLightLoc.y = startLeftOuterLightLoc.y + 1;
            Point endLeftOuterLightLoc = location;
            endLeftOuterLightLoc.x = endLeftOuterLightLoc.x + 1;
            endLeftOuterLightLoc.y = endLeftOuterLightLoc.y + size.h - 3;
            result = graphics.DrawLine(lightPen, startLeftOuterLightLoc, endLeftOuterLightLoc);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            Pen mediumLightPen(toolBar->MediumLightColor(), 1.0f);
            if (mediumLightPen.Error())
            {
                return Result<bool>(ErrorId(mediumLightPen.GetErrorId()));
            }
            Point startTopInnerLightLoc = location;
            startTopInnerLightLoc.x = startTopInnerLightLoc.x + 2;
            startTopInnerLightLoc.y = startTopInnerLightLoc.y + 2;
            Point endTopInnerLightLoc = location;
            endTopInnerLightLoc.x = endTopInnerLightLoc.x + size.w - 4;
            endTopInnerLightLoc.y = endTopInnerLightLoc.y + 2;
            result = graphics.DrawLine(mediumLightPen, startTopInnerLightLoc, endTopInnerLightLoc);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            Point startLeftInnerLightLoc = location;
            startLeftInnerLightLoc.x = startLeftInnerLightLoc.x + 2;
            startLeftInnerLightLoc.y = startLeftInnerLightLoc.y + 2;
            Point endLeftInnerLightLoc = location;
            endLeftInnerLightLoc.x = endLeftInnerLightLoc.x + 2;
            endLeftInnerLightLoc.y = endLeftInnerLightLoc.y + size.h - 4;
            result = graphics.DrawLine(mediumLightPen, startLeftInnerLightLoc, endLeftInnerLightLoc);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            Pen mediumDarkPen(toolBar->MediumDarkColor(), 1.0f);
            Point startRightInnerMediumDarkLoc = location;
            startRightInnerMediumDarkLoc.x = startRightInnerMediumDarkLoc.x + size.w - 3;
            startRightInnerMediumDarkLoc.y = startRightInnerMediumDarkLoc.y + 2;
            Point endRightInnerMediumDarkLoc = location;
            endRightInnerMediumDarkLoc.x = endRightInnerMediumDarkLoc.x + size.w - 3;
            endRightInnerMediumDarkLoc.y = endRightInnerMediumDarkLoc.y + size.h - 3;
            result = graphics.DrawLine(mediumDarkPen, startRightInnerMediumDarkLoc, endRightInnerMediumDarkLoc);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            Point startBottomInnerMediumDarkLoc = location;
            startBottomInnerMediumDarkLoc.x = startBottomInnerMediumDarkLoc.x + 2;
            startBottomInnerMediumDarkLoc.y = startBottomInnerMediumDarkLoc.y + size.h - 3;
            Point endBottomInnerMediumDarkLoc = location;
            endBottomInnerMediumDarkLoc.x = endBottomInnerMediumDarkLoc.x + size.w - 3;
            endBottomInnerMediumDarkLoc.y = endBottomInnerMediumDarkLoc.y + size.h - 3;
            result = graphics.DrawLine(mediumDarkPen, startBottomInnerMediumDarkLoc, endBottomInnerMediumDarkLoc);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            return DrawContent(graphics, location);
        }
        private Result<bool> DrawPressed(Graphics& graphics, const Point& location)
        {
            ToolBar* toolBar = GetToolBar();
            Pen darkPen(toolBar->DarkColor(), 1.0f);
            if (darkPen.Error())
            {
                return Result<bool>(ErrorId(darkPen.GetErrorId()));
            }
            Size size = GetSize();
            Rect rect(location, size);
            rect.size.w = rect.size.w - 1;
            rect.size.h = rect.size.h - 1;
            auto result = graphics.DrawRectangle(darkPen, rect);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }

            Point startTopInnerDarkLoc = location;
            startTopInnerDarkLoc.x = startTopInnerDarkLoc.x + 1;
            startTopInnerDarkLoc.y = startTopInnerDarkLoc.y + 1;
            Point endTopInnerDarkLoc = location;
            endTopInnerDarkLoc.x = endTopInnerDarkLoc.x + size.w - 2;
            endTopInnerDarkLoc.y = endTopInnerDarkLoc.y + 1;
            result = graphics.DrawLine(darkPen, startTopInnerDarkLoc, endTopInnerDarkLoc);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }

            Point startLeftInnerDarkLoc = location;
            startLeftInnerDarkLoc.x = startLeftInnerDarkLoc.x + 1;
            startLeftInnerDarkLoc.y = startLeftInnerDarkLoc.y + 2;
            Point endLeftInnerDarkLoc = location;
            endLeftInnerDarkLoc.x = endLeftInnerDarkLoc.x + 1;
            endLeftInnerDarkLoc.y = endLeftInnerDarkLoc.y + size.h - 2;
            result = graphics.DrawLine(darkPen, startLeftInnerDarkLoc, endLeftInnerDarkLoc);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }

            Pen mediumDarkPen(toolBar->MediumDarkColor(), 1.0f);
            Point startTopInnerMediumDarkLoc = location;
            startTopInnerMediumDarkLoc.x = startTopInnerMediumDarkLoc.x + 2;
            startTopInnerMediumDarkLoc.y = startTopInnerMediumDarkLoc.y + 2;
            Point endTopInnerMediumDarkLoc = location;
            endTopInnerMediumDarkLoc.x = endTopInnerMediumDarkLoc.x + size.w - 2;
            endTopInnerMediumDarkLoc.y = endTopInnerMediumDarkLoc.y + 2;
            result = graphics.DrawLine(mediumDarkPen, startTopInnerMediumDarkLoc, endTopInnerMediumDarkLoc);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }

            Point startLeftInnerMediumDarkLoc = location;
            startLeftInnerMediumDarkLoc.x = startLeftInnerMediumDarkLoc.x + 2;
            startLeftInnerMediumDarkLoc.y = startLeftInnerMediumDarkLoc.y + 2;
            Point endLeftInnerMediumDarkLoc = location;
            endLeftInnerMediumDarkLoc.x = endLeftInnerMediumDarkLoc.x + 2;
            endLeftInnerMediumDarkLoc.y = endLeftInnerMediumDarkLoc.y + size.h - 2;
            result = graphics.DrawLine(mediumDarkPen, startLeftInnerMediumDarkLoc, endLeftInnerMediumDarkLoc);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }

            return DrawContent(graphics, Point(location.x + 1, location.y + 1));
        }
        protected virtual Result<bool> DrawContent(Graphics& graphics, const Point& location)
        {
            return DrawToolBitmap(graphics, location);
        }
        private Result<bool> DrawToolBitmap(Graphics& graphics, const Point& location)
        {
            if (toolBitmap == null) return Result<bool>(false);
            Point bitmapLocation(location);
            bitmapLocation.x = bitmapLocation.x + padding.left;
            bitmapLocation.y = bitmapLocation.y + padding.top;
            Rect r(bitmapLocation, toolBitmapSize);
            ImageAttributes attributes;
            if (attributes.Error())
            {
                return Result<bool>(ErrorId(attributes.GetErrorId()));
            }
            auto result = attributes.SetColorKey(transparentColor, transparentColor, ColorAdjustType.default_);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            if (state == State.normal || state == State.pressed)
            {
                result = graphics.DrawImage(*toolBitmap, r, 0, 0, toolBitmapSize.w, toolBitmapSize.h, Unit.pixel, attributes);
                if (result.Error())
                {
                    return Result<bool>(ErrorId(result.GetErrorId()));
                }
            }
            else if (state == State.disabled)
            {
                result = graphics.DrawImage(*disabledToolBitmap, r, 0, 0, toolBitmapSize.w, toolBitmapSize.h, Unit.pixel, attributes);
                if (result.Error())
                {
                    return Result<bool>(ErrorId(result.GetErrorId()));
                }
            }
            return Result<bool>(true);
        }
        public inline const string& ToolBitmapName() const
        {
            return toolBitmapName;
        }
        internal void SetToolBitmaps(Bitmap* toolBitmap_, Bitmap* disabledToolBitmap_)
        {
            toolBitmap = toolBitmap_;
            disabledToolBitmap = disabledToolBitmap_;
            if (toolBitmap != null && disabledToolBitmap != null)
            {
                toolBitmapSize = Size(cast<int>(toolBitmap->GetWidth()), cast<int>(toolBitmap->GetHeight()));
                SetSize(Size(padding.Horizontal() + toolBitmapSize.w, padding.Vertical() + toolBitmapSize.h));
            }
        }
        [nodiscard]
        private Result<bool> Invalidate()
        {
            ToolBar* toolBar = GetToolBar();
            if (toolBar != null)
            {
                auto result = toolBar->Invalidate();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        private State state;
        private Style style;
        private string toolBitmapName;
        private Bitmap* toolBitmap;
        private Bitmap* disabledToolBitmap;
        private Color transparentColor;
        private Size toolBitmapSize;
        private string toolTip;
        private Padding padding;
        private Event<MouseEnterEventHandler, EnterLeaveEventArgs> mouseEnterEvent;
        private Event<MouseLeaveEventHandler, EnterLeaveEventArgs> mouseLeaveEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseMoveEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseDownEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseUpEvent;
        private Event<ClickEventHandler, ClickEventArgs> clickEvent;
    }

    public class TextToolButton : ToolButton
    {
        public TextToolButton(const string& text_, const Size& size, const Color& textColor_, ToolButton.Style style)  :
            base("", style), text(text_), textColor(textColor_)
        {
            SetSize(size);
        }
        public TextToolButton(const string& text) : this(text, Size(12, 12), Color.Black(), ToolButton.Style.automatic)
        {
        }
        protected override void SetToolBar(ToolBar* toolBar)
        {
            base->SetToolBar(toolBar);
            Padding padding = GetPadding();
            Size size = GetSize();
            SetSize(Size(padding.Horizontal() + size.w, padding.Vertical() + size.h));
            normalBrush = toolBar->GetOrInsertSolidBrush(textColor);
            disabledBrush = toolBar->GetOrInsertSolidBrush(textColor.ToGray());
        }
        protected override Result<bool> DrawContent(Graphics& graphics, const Point& location)
        {
            return DrawText(graphics, location);
        }
        private Result<bool> DrawText(Graphics& graphics, const Point& location)
        {
            TextRenderingHint prevRenderingHint = graphics.GetTextRenderingHint();
            auto result = graphics.SetTextRenderingHint(TextRenderingHint.clearTypeGridFit);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            ToolBar* toolBar = GetToolBar();
            Brush* brush = normalBrush;
            if (GetState() == State.disabled)
            {
                brush = disabledBrush;
            }
            Size size = GetSize();
            RectF r(PointF(location.x, location.y), SizeF(size.w, size.h));
            result = graphics.DrawString(text, toolBar->GetTextToolButtonFont(), r, toolBar->CenterFormat(), *brush);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            result = graphics.SetTextRenderingHint(prevRenderingHint);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            return Result<bool>(true);
        }
        private string text;
        private Color textColor;
        private SolidBrush* normalBrush;
        private SolidBrush* disabledBrush;
    }
}
