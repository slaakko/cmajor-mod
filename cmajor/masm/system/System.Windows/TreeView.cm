// =================================
// Copyright (c) 2024 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;

namespace System.Windows
{
    public class delegate void TreeViewNodeMouseClickEventHandler(TreeViewNodeMouseClickEventArgs& args);
    public class delegate void TreeViewNodeEventHandler(TreeViewNodeEventArgs& args);

    public string DefaultTreeViewNormalNodeFontFamilyName()
    {
        return "Segoe UI";
    }

    public float DefaultTreeViewNormalNodeFontSize()
    {
        return 9.0f;
    }

    public FontStyle DefaultTreeViewNormalNodeFontStyle()
    {
        return FontStyle.regular;
    }

    public string DefaultTreeViewActiveNodeFontFamilyName()
    {
        return "Segoe UI";
    }

    public float DefaultTreeViewActiveNodeFontSize()
    {
        return 9.0f;
    }

    public FontStyle DefaultTreeViewActiveNodeFontStyle()
    {
        return FontStyle.bold;
    }

    public Color DefaultTreeViewBackgroundColor()
    {
        return Color.White();
    }

    public Color DefaultTreeViewStateIndicatorColor()
    {
        return Color.Red();
    }

    public Color DefaultTreeViewNodeSelectedColor()
    {
        return Color(201u, 222u, 245u);
    }

    public float DefaultTreeViewStateIndicatorPercentage()
    {
        return 50.0f;
    }

    public float DefaultTreeViewNodeIndentPercent()
    {
        return 200.0f;
    }

    public float DefaultTreeViewNodeTextIndentPercent()
    {
        return 100.0f;
    }

    public Padding DefaultTreeViewNodeImagePadding()
    {
        return Padding(0, 0, 0, 0);
    }

    public ControlCreateParams& TreeViewControlCreateParams(ControlCreateParams& controlCreateParams)
    {
        return controlCreateParams.SetWindowClassName("System.Windows.TreeView").SetWindowClassStyle(DoubleClickWindowClassStyle()).
            SetWindowClassBackgroundColor(SystemColor.COLOR_WINDOW).SetBackgroundColor(DefaultTreeViewBackgroundColor());
    }

    public class TreeViewCreateParams
    {
        public TreeViewCreateParams(ControlCreateParams& controlCreateParams_) :
            controlCreateParams(controlCreateParams_),
            normalNodeFontFamilyName(DefaultTreeViewNormalNodeFontFamilyName()),
            normalNodeFontSize(DefaultTreeViewNormalNodeFontSize()),
            normalNodeFontStyle(DefaultTreeViewNormalNodeFontStyle()),
            activeNodeFontFamilyName(DefaultTreeViewActiveNodeFontFamilyName()),
            activeNodeFontSize(DefaultTreeViewActiveNodeFontSize()),
            activeNodeFontStyle(DefaultTreeViewActiveNodeFontStyle()),
            stateIndicatorColor(DefaultTreeViewStateIndicatorColor()),
            nodeSelectedColor(DefaultTreeViewNodeSelectedColor()),
            stateIndicatorPercentage(DefaultTreeViewStateIndicatorPercentage()),
            nodeIndentPercent(DefaultTreeViewNodeIndentPercent()),
            nodeTextIndentPercent(DefaultTreeViewNodeTextIndentPercent()),
            nodeImagePadding(DefaultTreeViewNodeImagePadding())
        {
        }
        public TreeViewCreateParams& Defaults()
        {
            return *this;
        }
        public TreeViewCreateParams& SetNormalNodeFontFamilyName(const string& normalNodeFontFamilyName_)
        {
            normalNodeFontFamilyName = normalNodeFontFamilyName_;
            return *this;
        }
        public TreeViewCreateParams& SetNormalNodeFontSize(float normalNodeFontSize_)
        {
            normalNodeFontSize = normalNodeFontSize_;
            return *this;
        }
        public TreeViewCreateParams& SetNormalNodeFontStyle(FontStyle normalNodeFontStyle_)
        {
            normalNodeFontStyle = normalNodeFontStyle_;
            return *this;
        }
        public TreeViewCreateParams& SetActiveNodeFontFamilyName(const string& activeNodeFontFamilyName_)
        {
            activeNodeFontFamilyName = activeNodeFontFamilyName_;
            return *this;
        }
        public TreeViewCreateParams& SetActiveNodeFontSize(float activeNodeFontSize_)
        {
            activeNodeFontSize = activeNodeFontSize_;
            return *this;
        }
        public TreeViewCreateParams& SetActiveNodeFontStyle(FontStyle activeNodeFontStyle_)
        {
            activeNodeFontStyle = activeNodeFontStyle_;
            return *this;
        }
        public TreeViewCreateParams& SetStateIndicatorColor(const Color& stateIndicatorColor_)
        {
            stateIndicatorColor = stateIndicatorColor_;
            return *this;
        }
        public TreeViewCreateParams& SetNodeSelectedColor(const Color& nodeSelectedColor_)
        {
            nodeSelectedColor = nodeSelectedColor_;
            return *this;
        }
        public TreeViewCreateParams& SetTextColor(const Color& textColor_)
        {
            textColor = textColor_;
            return *this;
        }
        public TreeViewCreateParams& SetStateIndicatorPercentage(float stateIndicatorPercentage_)
        {
            stateIndicatorPercentage = stateIndicatorPercentage_;
            return *this;
        }
        public TreeViewCreateParams& SetNodeIndentPercent(float nodeIndentPercent_)
        {
            nodeIndentPercent = nodeIndentPercent_;
            return *this;
        }
        public TreeViewCreateParams& SetNodeTextIndentPercent(float nodeTextIndentPercent_)
        {
            nodeTextIndentPercent = nodeTextIndentPercent_;
            return *this;
        }
        public TreeViewCreateParams& SetNodeImagePadding(const Padding& nodeImagePadding_)
        {
            nodeImagePadding = nodeImagePadding_;
            return *this;
        }
        public ControlCreateParams& controlCreateParams;
        public string normalNodeFontFamilyName;
        public float normalNodeFontSize;
        public FontStyle normalNodeFontStyle;
        public string activeNodeFontFamilyName;
        public float activeNodeFontSize;
        public FontStyle activeNodeFontStyle;
        public Color stateIndicatorColor;
        public Color nodeSelectedColor;
        public Color textColor;
        public float stateIndicatorPercentage;
        public float nodeIndentPercent;
        public float nodeTextIndentPercent;
        public Padding nodeImagePadding;
    }

    public class TreeView : Control
    {
        private enum Flags : sbyte
        {
            none = 0, changed = 1 << 0, treeViewNodeChanged = 1 << 1, treeViewNodeStateChanged = 1 << 2, toolTipWindowAdded = 1 << 3
        }
        public TreeView(const Font& normalNodeFont_, const Font& activeNodeFont_,
            const Color& backgroundColor, const Color& stateIndicatorColor_, const Color& nodeSelectedColor_, const Color& textColor_,
            const Point& location, const Size& size, Dock dock, Anchors anchors) :
            base("System.Windows.TreeView", DoubleClickWindowClassStyle(), DefaultChildWindowStyle(), DefaultExtendedWindowStyle(),
                backgroundColor, "treeView",
                location, size, dock, anchors), flags(Flags.none), root(), normalNodeFont(normalNodeFont_), activeNodeFont(activeNodeFont_),
                textHeight(0), stateIndicatorPercentage(50.0f),
                stateIndicatorColor(stateIndicatorColor_), nodeSelectedColor(nodeSelectedColor_), nodeSelectedBrush(nodeSelectedColor),
                textColor(textColor_), textBrush(textColor),
                nodeIndentPercent(DefaultTreeViewNodeIndentPercent()),
                nodeTextIndentPercent(DefaultTreeViewNodeTextIndentPercent()),
                format(StringAlignment.near, StringAlignment.near), bitmapIndex(-1), animationMs(5), selectedNode(null), trackedNode(null),
                toolTipWindow(new ToolTip())
        {
            SetChanged();
            SetMouseHoverMs(DefaultMouseHoverMs());
        }
        public TreeView(const Point& location, const Size& size, Dock dock, Anchors anchors) :
            this(Font(FontFamily("Segoe UI"), 9.0f), Font(FontFamily("Segoe UI"), 9.0f, FontStyle.bold, Unit.point),
            Color.White(), Color.Red(), Color(201u, 222u, 245u), Color.Black(), location, size, dock, anchors)
        {
        }
        public TreeView(TreeViewCreateParams& createParams) :
            base(createParams.controlCreateParams),
            flags(Flags.none), root(),
            normalNodeFont(
                Font(FontFamily(createParams.normalNodeFontFamilyName),
                    createParams.normalNodeFontSize,
                    createParams.normalNodeFontStyle,
                    Unit.point)),
            activeNodeFont(
                Font(FontFamily(createParams.activeNodeFontFamilyName),
                    createParams.activeNodeFontSize,
                    createParams.activeNodeFontStyle,
                    Unit.point)),
            textHeight(0), stateIndicatorPercentage(createParams.stateIndicatorPercentage),
            stateIndicatorColor(createParams.stateIndicatorColor),
            nodeSelectedColor(createParams.nodeSelectedColor), nodeSelectedBrush(nodeSelectedColor),
            textColor(createParams.textColor), textBrush(textColor),
            nodeIndentPercent(createParams.nodeIndentPercent),
            nodeTextIndentPercent(createParams.nodeTextIndentPercent),
            nodeImagePadding(createParams.nodeImagePadding),
            format(StringAlignment.near, StringAlignment.near), bitmapIndex(-1), animationMs(5),
            selectedNode(null), trackedNode(null), toolTipWindow(new ToolTip())
        {
            SetChanged();
            SetMouseHoverMs(DefaultMouseHoverMs());
        }
        public ~TreeView()
        {
            if (toolTipWindow != null && ToolTipWindowAdded())
            {
                ResetToolTipWindowAdded();
                Window* window = GetWindow();
                if (window != null)
                {
                    auto result = window->RemoveChild(toolTipWindow);
                    toolTipWindow = null;
                }
            }
        }
        [nodiscard]
        public override Result<bool> PrintWindowTree(int level)
        {
            LogView* log = Application.GetLogView();
            if (log != null)
            {
                auto handleResult = ToHexString(cast<ulong>(Handle()));
                if (handleResult.Error())
                {
                    return Result<bool>(ErrorId(handleResult.GetErrorId()));
                }
                const string& handleStr = handleResult.Value();
                auto parentTextResult = ParentText();
                if (parentTextResult.Error())
                {
                    return Result<bool>(ErrorId(parentTextResult.GetErrorId()));
                }
                const string& parentText = parentTextResult.Value();
                auto result = log->WriteLine(string(' ', level) + "TreeView." + Text() + ".handle=" + handleStr + " " + parentText + "[" +
                    Rect(Point(), GetSize()).ToString() + "]");
               if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> EnsureNodeVisible(TreeViewNode* node)
        {
            Size size = GetSize();
            Point contentLocation = ContentLocation();
            Point nodeLocation = node->Location();
            if (nodeLocation.y >= contentLocation.y && nodeLocation.y < contentLocation.y + size.h)
            {
                return Result<bool>(false);
            }
            if (nodeLocation.y > contentLocation.y)
            {
                int y = nodeLocation.y - Max(cast<int>(0), cast<int>(size.h - 2 * textHeight));
                Point newOrigin(0, y);
                SetContentLocation(newOrigin);
                auto result = Invalidate();
                if (result.Error()) return result;
            }
            else
            {
                int y = nodeLocation.y;
                Point newOrigin(0, y);
                SetContentLocation(newOrigin);
                auto result = Invalidate();
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        public bool NodeVisible(TreeViewNode* node) const
        {
            Size size = GetSize();
            Point contentLocation = ContentLocation();
            Point nodeLocation = node->Location();
            if (nodeLocation.y >= contentLocation.y && nodeLocation.y < contentLocation.y + size.h)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        public List<TreeViewNode*> GetVisibleNodes(int level) const
        {
            List<TreeViewNode*> visibleNodes;
            root->GetVisibleNodes(visibleNodes, this, level);
            return visibleNodes;
        }
        public List<TreeViewNode*> GetVisibleNodes() const
        {
            return GetVisibleNodes(-1);
        }
        [nodiscard]
        protected override Result<bool> OnPaint(PaintEventArgs& args)
        {
            if (Debug.Paint())
            {
                Rect r(Point(), GetSize());
                LogView* log = Application.GetLogView();
                if (log != null)
                {
                    auto result = log->WriteLine("TreeView.OnPaint: " + r.ToString());
                    if (result.Error()) return result;
                }
            }
            if (!ToolTipWindowAdded())
            {
                SetToolTipWindowAdded();
                Window* window = GetWindow();
                if (window != null)
                {
                    auto result = window->AddChild(toolTipWindow);
                    if (result.Error())
                    {
                        return Result<bool>(ErrorId(result.GetErrorId()));
                    }
                }
            }
            if (Changed())
            {
                ResetChanged();
                auto measureResult = Measure(args.graphics);
                if (measureResult.Error())
                {
                    return Result<bool>(ErrorId(measureResult.GetErrorId()));
                }
                MakeStateIndicatorBitmaps(args.graphics);
                SetTreeViewNodeChanged();
                SetTreeViewNodeStateChanged();
            }
            if (TreeViewNodeChanged())
            {
                ResetTreeViewNodeChanged();
                if (!root.IsNull())
                {
                    auto result = root->MeasureSize(args.graphics, this);
                    if (result.Error()) return result;
                }
            }
            if (TreeViewNodeStateChanged())
            {
                ResetTreeViewNodeStateChanged();
                if (!root.IsNull())
                {
                    Rect r(Point(), GetSize());
                    r.size.w = r.size.w - 1;
                    r.size.h = r.size.h - 1;
                    int idx = 0;
                    Rect rect;
                    auto measureResult = root->Measure(args.graphics, r.location, this, 0, idx, rect);
                    if (measureResult.Error())
                    {
                        return Result<bool>(ErrorId(measureResult.GetErrorId()));
                    }
                    auto result = SetContentSize(rect.size);
                    if (result.Error()) return result;
                }
            }
            auto clearResult = args.graphics.Clear(BackgroundColor());
            if (clearResult.Error())
            {
                return Result<bool>(ErrorId(clearResult.GetErrorId()));
            }
            if (bitmapIndex != -1)
            {
                Point location;
                PointF loc(location.x, location.y);
                auto drawResult = args.graphics.DrawImage(stateIndicatorBitmaps[bitmapIndex], loc);
                if (drawResult.Error())
                {
                    return Result<bool>(ErrorId(drawResult.GetErrorId()));
                }
            }
            else
            {
                if (!root.IsNull())
                {
                    auto drawResult = root->Draw(args.graphics, this);
                    if (drawResult.Error())
                    {
                        return Result<bool>(ErrorId(drawResult.GetErrorId()));
                    }
                }
                auto paintResult = base->OnPaint(args);
                if (paintResult.Error())
                {
                    return Result<bool>(ErrorId(paintResult.GetErrorId()));
                }
            }
            return Result<bool>(true);
        }
        public inline TreeViewNode* Root() const
        {
            return root.Get();
        }
        public TreeViewNode* ReleaseRoot()
        {
            return root.Release();
        }
        public void ResetRoot(TreeViewNode* root_)
        {
            root.Reset(root_);
        }
        [nodiscard]
        public Result<bool> SetRoot(TreeViewNode* root_)
        {
            if (!root.IsNull())
            {
                root->SetTreeView(null);
            }
            root.Reset(root_);
            SetContentLocation(Point(0, 0));
            if (!root.IsNull())
            {
                root->SetTreeView(this);
                SetTreeViewNodeChanged();
                SetTreeViewNodeStateChanged();
                SetContentChanged();
            }
            SetChanged();
            return Invalidate();
        }
        public inline const Font& GetNormalNodeFont() const
        {
            return normalNodeFont;
        }
        public inline const Font& GetActiveNodeFont() const
        {
            return activeNodeFont;
        }
        public void SetNormalNodeFont(const Font& normalNodeFont_)
        {
            normalNodeFont = normalNodeFont_;
            SetChanged();
        }
        public void SetActiveNodeFont(const Font& activeNodeFont_)
        {
            activeNodeFont = activeNodeFont_;
            SetChanged();
        }
        public inline const SolidBrush& TextBrush() const
        {
            return textBrush;
        }
        public inline const SolidBrush& NodeSelectedBrush() const
        {
            return nodeSelectedBrush;
        }
        public inline float TextHeight() const
        {
            return textHeight;
        }
        public inline float StateIndicatorPercentage() const
        {
            return stateIndicatorPercentage;
        }
        public inline void SetStateIndicatorPercentage(float stateIndicatorPercentage_)
        {
            stateIndicatorPercentage = stateIndicatorPercentage_;
            SetChanged();
        }
        public inline float StateIndicatorHeight() const
        {
            return stateIndicatorHeight;
        }
        public inline const Color& StateIndicatorColor() const
        {
            return stateIndicatorColor;
        }
        public void SetStateIndicatorColor(const Color& stateIndicatorColor_)
        {
            stateIndicatorColor = stateIndicatorColor_;
            SetChanged();
        }
        public inline const Color& NodeSelectedColor() const
        {
            return nodeSelectedColor;
        }
        public void SetNodeSelectedColor(const Color& nodeSelectedColor_)
        {
            if (nodeSelectedColor != nodeSelectedColor_)
            {
                nodeSelectedColor = nodeSelectedColor_;
                nodeSelectedBrush = SolidBrush(nodeSelectedColor);
            }
        }
        public inline const Color& TextColor() const
        {
            return textColor;
        }
        public void SetTextColor(const Color& textColor_)
        {
            if (textColor != textColor_)
            {
                textColor = textColor_;
                textBrush = SolidBrush(textColor);
                SetChanged();
            }
        }
        public inline float NodeIndentPercent() const
        {
            return nodeIndentPercent;
        }
        public inline float NodeTextIndentPercent() const
        {
            return nodeTextIndentPercent;
        }
        public inline int AnimationMs() const
        {
            return animationMs;
        }
        public void SetAnimationMs(int animationMs_)
        {
            animationMs = animationMs_;
        }
        [nodiscard]
        public Result<bool> ShowToolTipWindow(const string& toolTipText, TreeViewNode* node)
        {
            auto result = toolTipWindow->Hide();
            if (result.Error()) return result;
            Point loc = node->Location();
            Size size = node->GetSize();
            Point pt(loc.x, loc.y + size.h + 4);
            if (!node->Children().IsEmpty())
            {
                pt.x = pt.x + cast<int>(textHeight + 2.0f);
            }
            TranslateContentLocation(pt);
            auto clientToScreenResult = ClientToScreen(pt);
            if (clientToScreenResult.Error())
            {
                return Result<bool>(ErrorId(clientToScreenResult.GetErrorId()));
            }
            pt = clientToScreenResult.Value();
            result = toolTipWindow->SetText(toolTipText);
            if (result.Error()) return result;
            auto measureResult = toolTipWindow->MeasureExtent();
            if (measureResult.Error())
            {
                return Result<bool>(ErrorId(measureResult.GetErrorId()));
            }
            Window* window = GetWindow();
            if (window != null)
            {
                auto screenToClientResult = window->ScreenToClient(pt);
                if (screenToClientResult.Error())
                {
                    return Result<bool>(ErrorId(screenToClientResult.GetErrorId()));
                }
                pt = screenToClientResult.Value();
                Size sz = toolTipWindow->GetSize();
                auto wlocResult = window->Location();
                if (wlocResult.Error())
                {
                    return Result<bool>(ErrorId(wlocResult.GetErrorId()));
                }
                Point wloc = wlocResult.Value();
                Size wsz = window->GetSize();
                if (pt.y + sz.h > wloc.y + wsz.h)
                {
                    pt.y = wloc.y + wsz.h - sz.h;
                }
                if (pt.x + sz.w > wloc.x + wsz.w)
                {
                    pt.x = wloc.x + wsz.w - sz.w;
                }
                result = toolTipWindow->SetLocation(pt);
                if (result.Error()) return result;
                result = toolTipWindow->BringToFront();
                if (result.Error()) return result;
                result = toolTipWindow->Show();
                if (result.Error()) return result;
                result = toolTipWindow->Invalidate();
                if (result.Error()) return result;
                toolTipWindow->Update();
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> HideToolTipWindow()
        {
            return toolTipWindow->Hide();
        }
        public Event<TreeViewNodeMouseClickEventHandler, TreeViewNodeMouseClickEventArgs>& NodeClickEvent()
        {
            return nodeClickEvent;
        }
        public Event<TreeViewNodeMouseClickEventHandler, TreeViewNodeMouseClickEventArgs>& NodeDoubleClickEvent()
        {
            return nodeDoubleClickEvent;
        }
        public Event<TreeViewNodeEventHandler, TreeViewNodeEventArgs>& NodeEnterEvent()
        {
            return nodeEnterEvent;
        }
        public Event<TreeViewNodeEventHandler, TreeViewNodeEventArgs>& NodeLeaveEvent()
        {
            return nodeLeaveEvent;
        }
        public Event<TreeViewNodeEventHandler, TreeViewNodeEventArgs>& NodeSelectedEvent()
        {
            return nodeSelectedEvent;
        }
        public Event<TreeViewNodeEventHandler, TreeViewNodeEventArgs>& NodeExpandedEvent()
        {
            return nodeExpandedEvent;
        }
        public Event<TreeViewNodeEventHandler, TreeViewNodeEventArgs>& NodeCollapsedEvent()
        {
            return nodeCollapsedEvent;
        }
        public Event<TreeViewNodeEventHandler, TreeViewNodeEventArgs>& NodeHoveredEvent()
        {
            return nodeHoveredEvent;
        }
        [nodiscard]
        protected override Result<bool> OnMouseDown(MouseEventArgs& args)
        {
            auto result = base->OnMouseDown(args);
            if (result.Error()) return result;
            if (!root.IsNull())
            {
                bool handled = false;
                result = root->DispatchMouseDown(args, handled);
                if (result.Error()) return result;
                if (TreeViewNodeStateChanged())
                {
                    DeselectNode();
                    result = Invalidate();
                    if (result.Error()) return result;
                }
            }
            return Result<bool>(true);
        }
        [nodiscard]
        protected override Result<bool> OnMouseUp(MouseEventArgs& args)
        {
            auto result = base->OnMouseUp(args);
            if (result.Error()) return result;
            if (!root.IsNull())
            {
                bool handled = false;
                root->DispatchMouseUp(args, handled);
            }
            return Result<bool>(true);
        }
        [nodiscard]
        protected override Result<bool> OnMouseDoubleClick(MouseEventArgs& args)
        {
            auto result = base->OnMouseDoubleClick(args);
            if (result.Error()) return result;
            if (!root.IsNull())
            {
                bool handled = false;
                result = root->DispatchMouseDoubleClick(args, handled);
                if (result.Error()) return result;
                if (TreeViewNodeStateChanged())
                {
                    DeselectNode();
                    result = Invalidate();
                    if (result.Error()) return result;
                }
            }
            return Result<bool>(true);
        }
        [nodiscard]
        protected override Result<bool> OnMouseEnter()
        {
            auto result = base->OnMouseEnter();
            if (result.Error()) return result;
            trackedNode = null;
            return Result<bool>(true);
        }
        [nodiscard]
        protected override Result<bool> OnMouseMove(MouseEventArgs& args)
        {
            auto result = base->OnMouseMove(args);
            if (result.Error()) return result;
            if (!root.IsNull())
            {
                bool handled = false;
                root->DispatchMouseMove(args, handled);
                if (!handled)
                {
                    if (trackedNode != null)
                    {
                        if (trackedNode->MouseEntered())
                        {
                            trackedNode->ResetMouseEntered();
                            trackedNode->MouseLeaveInternal();
                        }
                        trackedNode = null;
                    }
                }
            }
            return Result<bool>(true);
        }
        [nodiscard]
        protected override Result<bool> OnMouseLeave()
        {
            auto result = base->OnMouseLeave();
            if (result.Error()) return result;
            if (trackedNode != null)
            {
                if (trackedNode->MouseEntered())
                {
                    trackedNode->ResetMouseEntered();
                    trackedNode->MouseLeaveInternal();
                }
                trackedNode = null;
            }
            return Result<bool>(true);
        }
        protected override void OnMouseHover(MouseEventArgs& args)
        {
            base->OnMouseHover(args);
            if (!root.IsNull())
            {
                bool handled = false;
                root->DispatchMouseHover(args, handled);
            }
        }
        internal inline bool Changed() const
        {
            return (flags & Flags.changed) != Flags.none;
        }
        public inline void SetChanged()
        {
            flags = cast<Flags>(flags | Flags.changed);
        }
        private inline void ResetChanged()
        {
            flags = cast<Flags>(flags & ~Flags.changed);
        }
        internal inline bool TreeViewNodeChanged() const
        {
            return (flags & Flags.treeViewNodeChanged) != Flags.none;
        }
        internal inline void SetTreeViewNodeChanged()
        {
            flags = cast<Flags>(flags | Flags.treeViewNodeChanged);
        }
        private inline void ResetTreeViewNodeChanged()
        {
            flags = cast<Flags>(flags & ~Flags.treeViewNodeChanged);
        }
        internal inline bool TreeViewNodeStateChanged() const
        {
            return (flags & Flags.treeViewNodeStateChanged) != Flags.none;
        }
        private inline void ResetTreeViewNodeStateChanged()
        {
            flags = cast<Flags>(flags & ~Flags.treeViewNodeStateChanged);
        }
        internal inline void SetTreeViewNodeStateChanged()
        {
            flags = cast<Flags>(flags | Flags.treeViewNodeStateChanged);
        }
        private inline bool ToolTipWindowAdded() const
        {
            return (flags & Flags.toolTipWindowAdded) != Flags.none;
        }
        private inline void SetToolTipWindowAdded()
        {
            flags = cast<Flags>(flags | Flags.toolTipWindowAdded);
        }
        private inline void ResetToolTipWindowAdded()
        {
            flags = cast<Flags>(flags & ~Flags.toolTipWindowAdded);
        }
        private Result<bool> Measure(Graphics& graphics)
        {
            string s = "RootNode";
            auto measureStringResult = graphics.MeasureStringRectF(s, normalNodeFont, PointF(0, 0), format);
            if (measureStringResult.Error())
            {
                return Result<bool>(ErrorId(measureStringResult.GetErrorId()));
            }
            RectF normalTextRect = measureStringResult.Value();
            textHeight = normalTextRect.size.h;
            measureStringResult = graphics.MeasureStringRectF(s, activeNodeFont, PointF(0, 0), format);
            if (measureStringResult.Error())
            {
                return Result<bool>(ErrorId(measureStringResult.GetErrorId()));
            }
            RectF activeTextRect = measureStringResult.Value();
            textHeight = Max(textHeight, activeTextRect.size.h);
            stateIndicatorHeight = stateIndicatorPercentage * textHeight / 100.0f;
            SetScrollUnits(cast<int>(textHeight + 0.5f), cast<int>(textHeight + 0.5f));
            return Result<bool>(true);
        }
        private Result<bool> MakeStateIndicatorBitmaps(Graphics& graphics)
        {
            SolidBrush stateIndicatorBrush(stateIndicatorColor);
            stateIndicatorBitmaps.Clear();
            PointF center(textHeight / 2, textHeight / 2);
            float w = cast<float>(cast<float>(Sqrt(3.0) / 2) * stateIndicatorHeight);
            PointF pt1(center.x - w / 2, center.y - stateIndicatorHeight / 2);
            PointF pt2(center.x - w / 2, center.y + stateIndicatorHeight / 2);
            PointF pt3(center.x + w / 2, center.y);
            for (int i = 9; i >= 0; --i)
            {
                float angle = i * 10.0f;
                List<PointF> triangle;
                triangle.Add(pt1);
                triangle.Add(pt2);
                triangle.Add(pt3);
                Bitmap bm(cast<int>(textHeight), cast<int>(textHeight), graphics);
                auto imageGraphicsResult = Graphics.FromImage(bm);
                if (imageGraphicsResult.Error())
                {
                    return Result<bool>(ErrorId(imageGraphicsResult.GetErrorId()));
                }
                Graphics& bmGraphics = imageGraphicsResult.Value();
                auto clearResult = bmGraphics.Clear(BackgroundColor());
                if (clearResult.Error())
                {
                    return Result<bool>(ErrorId(clearResult.GetErrorId()));
                }
                if (i > 0)
                {
                    Matrix id;
                    Result<Matrix> rotateResult = RotateAt(id, angle, center);
                    if (rotateResult.Error())
                    {
                        return Result<bool>(ErrorId(rotateResult.GetErrorId()));
                    }
                    Matrix rm = Rvalue(rotateResult.Value());
                    auto transformResult = rm.TransformPoints(triangle);
                    if (transformResult.Error())
                    {
                        return Result<bool>(ErrorId(transformResult.GetErrorId()));
                    }
                }
                List<Point> indicatorTriangle;
                for (const PointF& pt : triangle)
                {
                    indicatorTriangle.Add(Point(cast<int>(pt.x), cast<int>(pt.y)));
                }
                auto setSmoothingModeResult = bmGraphics.SetSmoothingMode(SmoothingMode.highQuality);
                if (setSmoothingModeResult.Error())
                {
                    return Result<bool>(ErrorId(setSmoothingModeResult.GetErrorId()));
                }
                auto fillResult = bmGraphics.FillPolygon(stateIndicatorBrush, 3, indicatorTriangle.Begin().Ptr());
                if (fillResult.Error())
                {
                    return Result<bool>(ErrorId(fillResult.GetErrorId()));
                }
                stateIndicatorBitmaps.Add(Rvalue(bm));
            }
            return Result<bool>(true);
        }
        [nodiscard]
        internal Result<bool> DoAnimation(TreeViewNode.State targetState, const Rect& stateRect)
        {
            if (targetState == TreeViewNode.State.expanded)
            {
                for (long i = stateIndicatorBitmaps.Count() - 1; i >= 0; --i)
                {
                    UpdateGuard guard(this, i);
                    auto result = Invalidate(stateRect.ToWinRect());
                    if (result.Error()) return result;
                    Update();
                    Sleep(Duration.FromMilliseconds(animationMs));
                }
            }
            else if (targetState == TreeViewNode.State.collapsed)
            {
                for (long i = 0; i < stateIndicatorBitmaps.Count(); ++i)
                {
                    UpdateGuard guard(this, i);
                    auto result = Invalidate(stateRect.ToWinRect());
                    if (result.Error()) return result;
                    Update();
                    Sleep(Duration.FromMilliseconds(animationMs));
                }
            }
            return Result<bool>(true);
        }
        private class UpdateGuard
        {
            public UpdateGuard(TreeView* view_, long bitmapIndex) : view(view_)
            {
                view->SetBitmapIndex(bitmapIndex);
            }
            public ~UpdateGuard()
            {
                view->ResetBitmapIndex();
            }
            private TreeView* view;
        }
        private void SetBitmapIndex(long bitmapIndex_)
        {
            bitmapIndex = bitmapIndex_;
        }
        private void ResetBitmapIndex()
        {
            bitmapIndex = -1;
        }
        [nodiscard]
        public Result<Bitmap*> NodeExpandedBitmap() const
        {
            if (stateIndicatorBitmaps.IsEmpty())
            {
                int errorId = AllocateError("no state indicator bitmaps");
                return Result<Bitmap*>(ErrorId(errorId));
            }
            return Result<Bitmap*>(&stateIndicatorBitmaps.Front());
        }
        [nodiscard]
        public Result<Bitmap*> NodeCollapsedBitmap() const
        {
            if (stateIndicatorBitmaps.IsEmpty())
            {
                int errorId = AllocateError("no state indicator bitmaps");
                return Result<Bitmap*>(ErrorId(errorId));
            }
            return Result<Bitmap*>(&stateIndicatorBitmaps.Back());
        }
        public inline const StringFormat& Format() const
        {
            return format;
        }
        internal void SetSelectedNode(TreeViewNode* node)
        {
            if (selectedNode != node)
            {
                if (selectedNode != null)
                {
                    selectedNode->ResetSelected();
                }
                selectedNode = node;
                SetTreeViewNodeStateChanged();
            }
        }
        public TreeViewNode* SelectedNode() const
        {
            return selectedNode;
        }
        public void DeselectNode()
        {
            if (selectedNode != null)
            {
                TreeViewNode* selectedNodeParent = selectedNode->Parent();
                while (selectedNodeParent != null)
                {
                    if (selectedNodeParent->GetState() == TreeViewNode.State.collapsed)
                    {
                        SetSelectedNode(null);
                        break;
                    }
                    selectedNodeParent = selectedNodeParent->Parent();
                }
            }
        }
        internal inline TreeViewNode* TrackedNode() const
        {
            return trackedNode;
        }
        internal void SetTrackedNode(TreeViewNode* trackedNode_)
        {
            trackedNode = trackedNode_;
        }
        public inline const Padding& NodeImagePadding() const
        {
            return nodeImagePadding;
        }
        protected virtual void OnNodeClick(TreeViewNodeMouseClickEventArgs& args)
        {
            nodeClickEvent.Fire(args);
        }
        internal void NodeClick(const Point& location, MouseButtons buttons, TreeViewNode* node)
        {
            TreeViewNodeMouseClickEventArgs args(location, buttons, 1, node);
            OnNodeClick(args);
        }
        protected virtual void OnNodeDoubleClick(TreeViewNodeMouseClickEventArgs& args)
        {
            nodeDoubleClickEvent.Fire(args);
        }
        internal void NodeDoubleClick(const Point& location, MouseButtons buttons, TreeViewNode* node)
        {
            TreeViewNodeMouseClickEventArgs args(location, buttons, 2, node);
            OnNodeDoubleClick(args);
        }
        protected virtual void OnNodeEnter(TreeViewNodeEventArgs& args)
        {
            nodeEnterEvent.Fire(args);
        }
        internal void NodeEnter(TreeViewNode* node)
        {
            TreeViewNodeEventArgs args(node);
            OnNodeEnter(args);
        }
        protected virtual void OnNodeLeave(TreeViewNodeEventArgs& args)
        {
            nodeLeaveEvent.Fire(args);
        }
        internal void NodeLeave(TreeViewNode* node)
        {
            TreeViewNodeEventArgs args(node);
            OnNodeLeave(args);
        }
        protected virtual void OnNodeSelected(TreeViewNodeEventArgs& args)
        {
            nodeSelectedEvent.Fire(args);
        }
        internal void NodeSelected(TreeViewNode* node)
        {
            TreeViewNodeEventArgs args(node);
            OnNodeSelected(args);
        }
        protected virtual void OnNodeExpanded(TreeViewNodeEventArgs& args)
        {
            nodeExpandedEvent.Fire(args);
        }
        internal void NodeExpanded(TreeViewNode* node)
        {
            TreeViewNodeEventArgs args(node);
            OnNodeExpanded(args);
        }
        protected virtual void OnNodeCollapsed(TreeViewNodeEventArgs& args)
        {
            nodeCollapsedEvent.Fire(args);
        }
        protected virtual void OnNodeHovered(TreeViewNodeEventArgs& args)
        {
            nodeHoveredEvent.Fire(args);
        }
        internal void NodeCollapsed(TreeViewNode* node)
        {
            TreeViewNodeEventArgs args(node);
            OnNodeCollapsed(args);
        }
        internal void NodeHovered(TreeViewNode* node)
        {
            TreeViewNodeEventArgs args(node);
            OnNodeHovered(args);
        }
        public inline ImageList* GetImageList() const
        {
            return imageList;
        }
        public void SetImageList(ImageList* imageList_)
        {
            imageList = imageList_;
        }
        private Flags flags;
        private UniquePtr<TreeViewNode> root;
        private Font normalNodeFont;
        private Font activeNodeFont;
        private float textHeight;
        private float stateIndicatorPercentage;
        private float stateIndicatorHeight;
        private Color stateIndicatorColor;
        private Color nodeSelectedColor;
        private Color textColor;
        private float nodeIndentPercent;
        private float nodeTextIndentPercent;
        private Padding nodeImagePadding;
        private SolidBrush nodeSelectedBrush;
        private SolidBrush textBrush;
        private List<Bitmap> stateIndicatorBitmaps;
        private StringFormat format;
        private long bitmapIndex;
        private int animationMs;
        private TreeViewNode* selectedNode;
        private TreeViewNode* trackedNode;
        private ToolTip* toolTipWindow;
        private ImageList* imageList;
        private Event<TreeViewNodeMouseClickEventHandler, TreeViewNodeMouseClickEventArgs> nodeClickEvent;
        private Event<TreeViewNodeMouseClickEventHandler, TreeViewNodeMouseClickEventArgs> nodeDoubleClickEvent;
        private Event<TreeViewNodeEventHandler, TreeViewNodeEventArgs> nodeEnterEvent;
        private Event<TreeViewNodeEventHandler, TreeViewNodeEventArgs> nodeLeaveEvent;
        private Event<TreeViewNodeEventHandler, TreeViewNodeEventArgs> nodeSelectedEvent;
        private Event<TreeViewNodeEventHandler, TreeViewNodeEventArgs> nodeExpandedEvent;
        private Event<TreeViewNodeEventHandler, TreeViewNodeEventArgs> nodeCollapsedEvent;
        private Event<TreeViewNodeEventHandler, TreeViewNodeEventArgs> nodeHoveredEvent;
    }

    public class TreeViewNode : Component
    {
        public enum State : sbyte
        {
            collapsed = 0, expanded = 1
        }
        private enum Flags : sbyte
        {
            none = 0, mouseEntered = 1 << 0, selected = 1 << 1, active = 1 << 2
        }
        public explicit TreeViewNode(const string& text_) :
            treeView(null), text(text_), children(this), state(State.collapsed), flags(Flags.none), index(-1), imageIndex(-1), expandedImageIndex(-1)
        {
        }
        public void SetTreeView(TreeView* treeView_)
        {
            treeView = treeView_;
        }
        public TreeViewNode* Parent() const
        {
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null)
                {
                    if (parent is TreeViewNode*)
                    {
                        return cast<TreeViewNode*>(parent);
                    }
                }
            }
            return null;
        }
        public TreeView* GetTreeView() const
        {
            if (treeView != null)
            {
                return treeView;
            }
            TreeViewNode* parent = Parent();
            if (parent != null)
            {
                return parent->GetTreeView();
            }
            return null;
        }
        [nodiscard]
        public Result<bool> AddChild(TreeViewNode* child)
        {
            auto result = children.AddChild(child);
            if (result.Error())
            {
                return Result<bool>(ErrorId(result.GetErrorId()));
            }
            TreeView* view = GetTreeView();
            if (view != null)
            {
                view->SetTreeViewNodeChanged();
            }
            return Result<bool>(true);
        }
        public UniquePtr<TreeViewNode> RemoveChild(TreeViewNode* child)
        {
            UniquePtr<Component> removed = children.RemoveChild(child);
            TreeView* view = GetTreeView();
            if (view != null)
            {
                view->SetTreeViewNodeChanged();
            }
            return UniquePtr<TreeViewNode>(cast<TreeViewNode*>(removed.Release()));
        }
        public void RemoveChildren()
        {
            Component* component = children.FirstChild();
            while (component != null)
            {
                Component* next = component->NextSibling();
                UniquePtr<Component> removed = children.RemoveChild(component);
                component = next;
            }
        }
        public int Level() const
        {
            TreeViewNode* parent = Parent();
            if (parent != null)
            {
                return parent->Level() + 1;
            }
            return 0;
        }
        public const Point& Location() const
        {
            return location;
        }
        public const Size& GetSize() const
        {
            return size;
        }
        [nodiscard]
        public Result<bool> MeasureSize(Graphics& graphics, TreeView* treeView)
        {
            auto measureStringResult = graphics.MeasureStringRectF(text, treeView->GetNormalNodeFont(), PointF(0, 0), treeView->Format());
            if (measureStringResult.Error())
            {
                return Result<bool>(ErrorId(measureStringResult.GetErrorId()));
            }
            RectF textRect = measureStringResult.Value();
            SizeF imageSize(0, 0);
            if (imageIndex != -1)
            {
                Padding padding = treeView->NodeImagePadding();
                ImageList* imageList = treeView->GetImageList();
                if (imageList != null)
                {
                    Bitmap* bitmap = imageList->GetImage(imageIndex);
                    imageSize.w = bitmap->GetWidth() + padding.Horizontal();
                    imageSize.h = bitmap->GetHeight() + padding.Vertical();
                }
            }
            size = Size(cast<int>(treeView->TextHeight() + textRect.size.w + imageSize.w), cast<int>(Max(textRect.size.h, imageSize.h)));
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is TreeViewNode*)
                {
                    TreeViewNode* childNode = cast<TreeViewNode*>(child);
                    auto result = childNode->MeasureSize(graphics, treeView);
                    if (result.Error()) return result;
                }
                child = child->NextSibling();
            }
            return Result<bool>(true);
        }
        internal Result<bool> Measure(Graphics& graphics, const Point& loc, TreeView* treeView, int level, int& idx, Rect& parentRect)
        {
            //location = Point(cast<int>(loc.x + level * 2 * treeView->TextHeight()), cast<int>(loc.y + idx * treeView->TextHeight()));
            float imageHeight = 0;
            if (imageIndex != -1)
            {
                Padding padding = treeView->NodeImagePadding();
                ImageList* imageList = treeView->GetImageList();
                if (imageList != null)
                {
                    Bitmap* image = imageList->GetImage(imageIndex);
                    imageHeight = image->GetHeight() + padding.Vertical();
                }
            }
            location = Point(cast<int>(loc.x + level * treeView->NodeIndentPercent() * treeView->TextHeight() / 100.0f),
                cast<int>(loc.y + idx * Max(treeView->TextHeight(), imageHeight)));
            Rect rect(location, size);
            childRect = rect;
            parentRect = Rect.Union(parentRect, childRect);
            if (state == State.expanded)
            {
                Component* child = children.FirstChild();
                while (child != null)
                {
                    if (child is TreeViewNode*)
                    {
                        TreeViewNode* childNode = cast<TreeViewNode*>(child);
                        ++idx;
                        auto measureResult = childNode->Measure(graphics, loc, treeView, level + 1, idx, childRect);
                        if (measureResult.Error())
                        {
                            return Result<bool>(ErrorId(measureResult.GetErrorId()));
                        }
                        parentRect = Rect.Union(parentRect, childRect);
                    }
                    child = child->NextSibling();
                }
            }
            return Result<bool>(true);
        }
        [nodiscard]
        internal Result<bool> DispatchMouseDown(MouseEventArgs& args, bool& handled)
        {
            Rect r(location, size);
            if (r.Contains(args.location))
            {
                auto result = OnMouseDown(args);
                if (result.Error()) return result;
                handled = true;
            }
            else
            {
                if (childRect.Contains(args.location))
                {
                    Component* child = children.FirstChild();
                    while (child != null)
                    {
                        if (child is TreeViewNode*)
                        {
                            TreeViewNode* childNode = cast<TreeViewNode*>(child);
                            auto result = childNode->DispatchMouseDown(args, handled);
                            if (result.Error()) return result;
                            if (handled)
                            {
                                return Result<bool>(true);
                            }
                        }
                        child = child->NextSibling();
                    }
                }
            }
            return Result<bool>(true);
        }
        internal void DispatchMouseUp(MouseEventArgs& args, bool& handled)
        {
            Rect r(location, size);
            if (r.Contains(args.location))
            {
                OnMouseUp(args);
                handled = true;
            }
            else
            {
                if (childRect.Contains(args.location))
                {
                    Component* child = children.FirstChild();
                    while (child != null)
                    {
                        if (child is TreeViewNode*)
                        {
                            TreeViewNode* childNode = cast<TreeViewNode*>(child);
                            childNode->DispatchMouseUp(args, handled);
                            if (handled)
                            {
                                return;
                            }
                        }
                        child = child->NextSibling();
                    }
                }
            }
        }
        [nodiscard]
        internal Result<bool> DispatchMouseDoubleClick(MouseEventArgs& args, bool& handled)
        {
            Rect r(location, size);
            if (r.Contains(args.location))
            {
                auto result = OnMouseDoubleClick(args);
                if (result.Error()) return result;
                handled = true;
            }
            else
            {
                if (childRect.Contains(args.location))
                {
                    Component* child = children.FirstChild();
                    while (child != null)
                    {
                        if (child is TreeViewNode*)
                        {
                            TreeViewNode* childNode = cast<TreeViewNode*>(child);
                            auto result = childNode->DispatchMouseDoubleClick(args, handled);
                            if (result.Error()) return result;
                            if (handled)
                            {
                                return Result<bool>(true);
                            }
                        }
                        child = child->NextSibling();
                    }
                }
            }
            return Result<bool>(true);
        }
        internal void DispatchMouseMove(MouseEventArgs& args, bool& handled)
        {
            Rect r(location, size);
            if (r.Contains(args.location))
            {
                handled = true;
                TreeView* view = GetTreeView();
                if (view != null)
                {
                    TreeViewNode* prevNode = view->TrackedNode();
                    if (prevNode != null && prevNode != this)
                    {
                        if (prevNode->MouseEntered())
                        {
                            prevNode->ResetMouseEntered();
                            prevNode->OnMouseLeave();
                        }
                    }
                    view->SetTrackedNode(this);
                    if (!MouseEntered())
                    {
                        SetMouseEntered();
                        OnMouseEnter();
                    }
                }
            }
            else
            {
                if (childRect.Contains(args.location))
                {
                    Component* child = children.FirstChild();
                    while (child != null)
                    {
                        if (child is TreeViewNode*)
                        {
                            TreeViewNode* childNode = cast<TreeViewNode*>(child);
                            childNode->DispatchMouseMove(args, handled);
                            if (handled)
                            {
                                return;
                            }
                        }
                        child = child->NextSibling();
                    }
                }
            }
        }
        internal void MouseLeaveInternal()
        {
            OnMouseLeave();
        }
        internal void DispatchMouseHover(MouseEventArgs& args, bool& handled)
        {
            Rect r(location, size);
            if (r.Contains(args.location))
            {
                handled = true;
                OnMouseHover();
            }
            else
            {
                if (childRect.Contains(args.location))
                {
                    Component* child = children.FirstChild();
                    while (child != null)
                    {
                        if (child is TreeViewNode*)
                        {
                            TreeViewNode* childNode = cast<TreeViewNode*>(child);
                            childNode->DispatchMouseHover(args, handled);
                            if (handled)
                            {
                                return;
                            }
                        }
                        child = child->NextSibling();
                    }
                }
            }
        }
        [nodiscard]
        private Result<bool> OnMouseDown(MouseEventArgs& args)
        {
            if (args.buttons == MouseButtons.lbutton)
            {
                TreeView* view = GetTreeView();
                if (view != null)
                {
                    if (children.IsEmpty())
                    {
                        Select();
                    }
                    else
                    {
                        int stateSquareSideLength = cast<int>(view->TextHeight());
                        Rect stateRect(location, Size(stateSquareSideLength, stateSquareSideLength));
                        if (stateRect.Contains(args.location))
                        {
                            auto result = Toggle();
                            if (result.Error()) return result;
                        }
                        else
                        {
                            Select();
                        }
                    }
                }
            }
            else if (args.buttons == MouseButtons.rbutton)
            {
                Select();
            }
            return Result<bool>(true);
        }
        private void OnMouseUp(MouseEventArgs& args)
        {
            if (args.buttons == MouseButtons.lbutton)
            {
                if (Selected())
                {
                    TreeView* view = GetTreeView();
                    if (view != null)
                    {
                        view->NodeClick(args.location, args.buttons, this);
                    }
                }
            }
            else if (args.buttons == MouseButtons.rbutton)
            {
                if (Selected())
                {
                    TreeView* view = GetTreeView();
                    if (view != null)
                    {
                        view->NodeClick(args.location, args.buttons, this);
                    }
                }
            }
        }
        [nodiscard]
        private Result<bool> OnMouseDoubleClick(MouseEventArgs& args)
        {
            TreeView* view = GetTreeView();
            if (view != null)
            {
                view->NodeDoubleClick(args.location, args.buttons, this);
            }
            return Result<bool>(true);
        }
        private void OnMouseEnter()
        {
            TreeView* view = GetTreeView();
            if (view != null)
            {
                view->NodeEnter(this);
            }
        }
        private void OnMouseLeave()
        {
            TreeView* view = GetTreeView();
            if (view != null)
            {
                view->NodeLeave(this);
            }
        }
        private void OnMouseHover()
        {
            TreeView* view = GetTreeView();
            if (view != null)
            {
                view->NodeHovered(this);
            }
        }
        [nodiscard]
        public Result<bool> Toggle()
        {
            switch (state)
            {
                case State.expanded:
                {
                    auto result = Collapse();
                    if (result.Error()) return result;
                    break;
                }
                case State.collapsed:
                {
                    auto result = Expand();
                    if (result.Error()) return result;
                    break;
                }
            }
            return Result<bool>(true);
        }
        public void Select()
        {
            if (!Selected())
            {
                SetSelected();
                TreeView* view = GetTreeView();
                if (view != null)
                {
                    view->SetSelectedNode(this);
                    view->NodeSelected(this);
                }
            }
        }
        public void Deselect()
        {
            if (Selected())
            {
                ResetSelected();
                TreeView* view = GetTreeView();
                if (view != null)
                {
                    view->SetSelectedNode(null);
                }
            }
        }
        [nodiscard]
        public Result<bool> Expand()
        {
            if (children.IsEmpty()) return Result<bool>(false);
            auto result = DoAnimation();
            if (result.Error()) return result;
            Expand(false);
            TreeView* view = GetTreeView();
            if (view != null)
            {
                view->NodeExpanded(this);
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> ExpandAll()
        {
            if (children.IsEmpty()) return Result<bool>(false);
            auto result = DoAnimation();
            if (result.Error()) return result;
            Expand(true);
            TreeView* view = GetTreeView();
            if (view != null)
            {
                view->NodeExpanded(this);
            }
            return Result<bool>(true);
        }
        public void Expand(bool all)
        {
            if (children.IsEmpty()) return;
            SetState(State.expanded);
            if (all)
            {
                Component* child = children.FirstChild();
                while (child != null)
                {
                    if (child is TreeViewNode*)
                    {
                        TreeViewNode* childNode = cast<TreeViewNode*>(child);
                        childNode->Expand(all);
                    }
                    child = child->NextSibling();
                }
            }
        }
        [nodiscard]
        public Result<bool> Collapse()
        {
            if (children.IsEmpty()) return Result<bool>(false);
            auto result = DoAnimation();
            if (result.Error()) return result;
            Collapse(false);
            TreeView* view = GetTreeView();
            if (view != null)
            {
                view->NodeCollapsed(this);
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> CollapseAll()
        {
            if (children.IsEmpty()) return Result<bool>(false);
            auto result = DoAnimation();
            if (result.Error()) return result;
            Collapse(true);
            TreeView* view = GetTreeView();
            if (view != null)
            {
                view->NodeCollapsed(this);
            }
            return Result<bool>(true);
        }
        public void Collapse(bool all)
        {
            if (children.IsEmpty()) return;
            SetState(State.collapsed);
            if (all)
            {
                Component* child = children.FirstChild();
                while (child != null)
                {
                    if (child is TreeViewNode*)
                    {
                        TreeViewNode* childNode = cast<TreeViewNode*>(child);
                        childNode->Collapse(all);
                    }
                    child = child->NextSibling();
                }
            }
        }
        [nodiscard]
        private Result<bool> DoAnimation()
        {
            TreeView* view = GetTreeView();
            if (view != null)
            {
                int stateSquareSideLength = cast<int>(view->TextHeight());
                Rect stateRect(location, Size(stateSquareSideLength, stateSquareSideLength));
                auto result = view->DoAnimation(cast<State>(1 - state), stateRect);
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        public inline const string& Text() const
        {
            return text;
        }
        public void SetText(const string& text_)
        {
            text = text_;
            TreeView* view = GetTreeView();
            if (view != null)
            {
                view->SetTreeViewNodeChanged();
            }
        }
        public inline Container& Children() const
        {
            return children;
        }
        public inline State GetState() const
        {
            return state;
        }
        public void SetState(State state_)
        {
            if (state != state_)
            {
                state = state_;
                TreeView* view = GetTreeView();
                if (view != null)
                {
                    view->SetTreeViewNodeStateChanged();
                    if (state == State.collapsed)
                    {
                        view->SetContentLocation(Point(0, 0));
                    }
                }
            }
        }
        public inline void* Data() const
        {
            return data;
        }
        public inline void SetData(void* data_)
        {
            data = data_;
        }
        [nodiscard]
        public Result<bool> EnsureVisible()
        {
            TreeView* treeView = GetTreeView();
            if (treeView != null)
            {
                auto result = treeView->EnsureNodeVisible(this);
                if (result.Error()) return result;
            }
            return Result<bool>(true);
        }
        public void GetVisibleNodes(List<TreeViewNode*>& visibleNodes, TreeView* treeView, int selectLevel)
        {
            if (selectLevel == -1 || Level() == selectLevel)
            {
                if (treeView->NodeVisible(this))
                {
                    visibleNodes.Add(this);
                }
            }
            if (state == State.expanded)
            {
                Component* child = children.FirstChild();
                while (child != null)
                {
                    if (child is TreeViewNode*)
                    {
                        TreeViewNode* childNode = cast<TreeViewNode*>(child);
                        childNode->GetVisibleNodes(visibleNodes, treeView, selectLevel);
                    }
                    child = child->NextSibling();
                }
            }
        }
        [nodiscard]
        public Result<bool> Draw(Graphics& graphics, TreeView* treeView)
        {
            bool isVisible = treeView->NodeVisible(this);
            Point loc = location;
            if (!children.IsEmpty())
            {
                if (isVisible)
                {
                    switch (state)
                    {
                        case State.expanded:
                        {
                            auto bitmapResult = treeView->NodeExpandedBitmap();
                            if (bitmapResult.Error())
                            {
                                return Result<bool>(ErrorId(bitmapResult.GetErrorId()));
                            }
                            Bitmap* bm = bitmapResult.Value();
                            auto drawImageResult = graphics.DrawImage(*bm, PointF(loc.x, loc.y));
                            if (drawImageResult.Error())
                            {
                                return Result<bool>(ErrorId(drawImageResult.GetErrorId()));
                            }
                            break;
                        }
                        case State.collapsed:
                        {
                            auto bitmapResult = treeView->NodeCollapsedBitmap();
                            if (bitmapResult.Error())
                            {
                                return Result<bool>(ErrorId(bitmapResult.GetErrorId()));
                            }
                            Bitmap* bm = bitmapResult.Value();
                            auto drawImageResult = graphics.DrawImage(*bm, PointF(loc.x, loc.y));
                            if (drawImageResult.Error())
                            {
                                return Result<bool>(ErrorId(drawImageResult.GetErrorId()));
                            }
                            break;
                        }
                    }
                }
                loc.x = cast<int>(loc.x + treeView->NodeTextIndentPercent() * treeView->TextHeight() / 100.0f);
            }
            if (isVisible)
            {
                if (imageIndex != -1)
                {
                    auto drawImageResult = DrawImage(treeView, graphics, loc);
                    if (drawImageResult.Error())
                    {
                        return Result<bool>(ErrorId(drawImageResult.GetErrorId()));
                    }
                }
            }
            if (isVisible)
            {
                if (Selected())
                {
                    Rect rect(loc, size);
                    auto fillResult = graphics.FillRectangle(treeView->NodeSelectedBrush(), rect);
                    if (fillResult.Error())
                    {
                        return Result<bool>(ErrorId(fillResult.GetErrorId()));
                    }
                }
                if (Active())
                {
                    auto drawStringResult = graphics.DrawString(text, treeView->GetActiveNodeFont(), PointF(loc.x, loc.y), treeView->TextBrush());
                    if (drawStringResult.Error())
                    {
                        return Result<bool>(ErrorId(drawStringResult.GetErrorId()));
                    }
                }
                else
                {
                    auto drawStringResult = graphics.DrawString(text, treeView->GetNormalNodeFont(), PointF(loc.x, loc.y), treeView->TextBrush());
                    if (drawStringResult.Error())
                    {
                        return Result<bool>(ErrorId(drawStringResult.GetErrorId()));
                    }
                }
            }
            if (state == State.expanded)
            {
                Component* child = children.FirstChild();
                while (child != null)
                {
                    if (child is TreeViewNode*)
                    {
                        TreeViewNode* childNode = cast<TreeViewNode*>(child);
                        auto childDrawResult = childNode->Draw(graphics, treeView);
                        if (childDrawResult.Error())
                        {
                            return Result<bool>(ErrorId(childDrawResult.GetErrorId()));
                        }
                    }
                    child = child->NextSibling();
                }
            }
            return Result<bool>(true);
        }
        internal inline bool MouseEntered() const
        {
            return (flags & Flags.mouseEntered) != Flags.none;
        }
        internal inline void SetMouseEntered()
        {
            flags = cast<Flags>(flags | Flags.mouseEntered);
        }
        internal inline void ResetMouseEntered()
        {
            flags = cast<Flags>(flags & ~Flags.mouseEntered);
        }
        public inline bool Selected() const
        {
            return (flags & Flags.selected) != Flags.none;
        }
        private inline void SetSelected()
        {
            flags = cast<Flags>(flags | Flags.selected);
        }
        internal inline void ResetSelected()
        {
            flags = cast<Flags>(flags & ~Flags.selected);
        }
        public inline bool Active() const
        {
            return (flags & Flags.active) != Flags.none;
        }
        public void SetActive(bool active)
        {
            if (Active() != active)
            {
                if (active)
                {
                    flags = cast<Flags>(flags | Flags.active);
                }
                else
                {
                    flags = cast<Flags>(flags & ~Flags.active);
                }
                TreeView* view = GetTreeView();
                if (view != null)
                {
                    view->SetTreeViewNodeStateChanged();
                }
            }
        }
        public inline int Index() const
        {
            return index;
        }
        public void SetIndex(int index_)
        {
            index = index_;
        }
        public inline int ImageIndex() const
        {
            return imageIndex;
        }
        [nodiscard]
        public Result<bool> SetImageIndex(int imageIndex_)
        {
            if (imageIndex != imageIndex_)
            {
                imageIndex = imageIndex_;
                TreeView* view = GetTreeView();
                if (view != null)
                {
                    view->SetTreeViewNodeStateChanged();
                    view->SetChanged();
                    auto result = view->Invalidate();
                    if (result.Error()) return result;
                }
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> SetExpandedImageIndex(int expandedImageIndex_)
        {
            if (expandedImageIndex != expandedImageIndex_)
            {
                expandedImageIndex = expandedImageIndex_;
                TreeView* view = GetTreeView();
                if (view != null)
                {
                    view->SetTreeViewNodeStateChanged();
                    view->SetChanged();
                    auto result = view->Invalidate();
                    if (result.Error()) return result;
                }
            }
            return Result<bool>(true);
        }
        [nodiscard]
        public Result<bool> DrawImage(TreeView* view, Graphics& graphics, Point& loc)
        {
            ImageList* imageList = view->GetImageList();
            if (imageList != null)
            {
                int imgIndex = imageIndex;
                if (state == State.expanded)
                {
                    if (expandedImageIndex != -1)
                    {
                        imgIndex = expandedImageIndex;
                    }
                }
                Bitmap* image = imageList->GetImage(imgIndex);
                if (image != null)
                {
                    int imageWidth = cast<int>(image->GetWidth());
                    int imageHeight = cast<int>(image->GetHeight());
                    Padding padding = view->NodeImagePadding();
                    Rect r(loc, Size(imageWidth + padding.Horizontal(), imageHeight + padding.Vertical()));
                    ImageAttributes attributes;
                    Color transparentColor = System.Windows.Color.DefaultBitmapTransparent();
                    auto setColorKeyResult = attributes.SetColorKey(transparentColor, transparentColor, ColorAdjustType.default_);
                    if (setColorKeyResult.Error())
                    {
                        return Result<bool>(ErrorId(setColorKeyResult.GetErrorId()));
                    }
                    auto drawImageResult = graphics.DrawImage(*image, r, 0, 0, imageWidth + padding.Horizontal(), imageHeight + padding.Vertical(),
                        Unit.pixel, attributes);
                    if (drawImageResult.Error())
                    {
                        return Result<bool>(ErrorId(drawImageResult.GetErrorId()));
                    }
                    loc.x = loc.x + imageWidth + padding.Horizontal();
                }
            }
            return Result<bool>(true);
        }
        private TreeView* treeView;
        private string text;
        private Container children;
        private State state;
        private Flags flags;
        private void* data;
        private Point location;
        private Size size;
        private Rect childRect;
        private int index;
        private int imageIndex;
        private int expandedImageIndex;
    }
}
