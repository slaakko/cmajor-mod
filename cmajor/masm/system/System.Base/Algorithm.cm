// =================================
// Copyright (c) 2024 Seppo Laakko
// Distributed under the MIT license
// =================================

// Algorithm implementations are based on SGI STL implementation.

using System.Concepts;

namespace System
{
    public constexpr inline const T& Min<T>(const T& left, const T& right) where T is LessThanComparable
    {
        if (left <= right) return left;
        return right;
    }

    public constexpr inline const T& Max<T>(const T& left, const T& right) where T is LessThanComparable
    {
        if (right >= left) return right;
        return left;
    }

    public inline void Swap<T>(T& left, T& right) where T is MoveConstructible and T is MoveAssignable and T is Destructible
    {
        T temp(Rvalue(left));
        left = Rvalue(right);
        right = Rvalue(temp);
    }

    public void Reverse<I>(I begin, I end) where I is RandomAccessIterator
    {
        while (begin < end)
        {
            --end;
            Swap(*begin, *end);
            ++begin;
        }
    }

    public void Reverse<I>(I begin, I end) where I is BidirectionalIterator
    {
        while (true)
        {
            if (begin == end)
            {
                return;
            }
            --end;
            if (begin == end)
            {
                return;
            }
            Swap(*begin, *end);
            ++begin;
        }
    }

    public Pair<I, I> ReverseUntil<I>(I first, I middle, I last) where I is BidirectionalIterator
    {
        while (first != middle && middle != last)
        {
            --last;
            Swap(*first, *last);
            ++first;
        }
        return MakePair(first, last);
    }

    public I Rotate<I>(I first, I middle, I last) where I is BidirectionalIterator
    {
        Reverse(first, middle);
        Reverse(middle, last);
        Pair<I, I> p = ReverseUntil(first, middle, last);
        Reverse(p.first, p.second);
        if (middle == p.first) return p.second;
        return p.first;
    }

    public O Copy<I, O>(I begin, I end, O to) where I is InputIterator and O is OutputIterator and CopyAssignable<O.ValueType, I.ValueType>
    {
        while (begin != end)
        {
            *to = *begin;
            ++begin;
            ++to;
        }
        return to;
    }

    public O CopyBackward<I, O>(I begin, I end, O to) where I is BidirectionalIterator and O is BidirectionalIterator and CopyAssignable<O.ValueType, I.ValueType>
    {
        while (begin != end)
        {
            --to;
            --end;
            *to = *end;
        }
        return to;
    }

    public O Move<I, O>(I begin, I end, O to) where I is InputIterator and O is OutputIterator and O.ValueType is I.ValueType and I.ValueType is MoveAssignable
    {
        while (begin != end)
        {
            *to = Rvalue(*begin);
            ++begin;
            ++to;
        }
        return to;
    }

    public O MoveBackward<I, O>(I begin, I end, O to) where I is BidirectionalIterator and O is BidirectionalIterator and O.ValueType is I.ValueType and I.ValueType is MoveAssignable
    {
        while (begin != end)
        {
            --to;
            --end;
            *to = Rvalue(*end);
        }
        return to;
    }

    public constexpr long Distance<I>(I first, I last) where I is ForwardIterator
    {
        long distance = 0;
        while (first != last)
        {
            ++first;
            ++distance;
        }
        return distance;
    }

    public constexpr inline long Distance<I>(I first, I last) where I is RandomAccessIterator
    {
        return last - first;
    }

    public constexpr I Next<I>(I i, long n) where I is ForwardIterator
    {
        #assert(n >= 0);
        while (n > 0)
        {
            ++i;
            --n;
        }
        return i;
    }

    public constexpr inline I Next<I>(I i, long n) where I is RandomAccessIterator
    {
        return i + n;
    }

    public constexpr I LowerBound<I, T>(I first, I last, const T& value) where I is ForwardIterator and TotallyOrdered<T, I.ValueType>
    {
        long len = Distance(first, last);
        while (len > 0)
        {
            long half = len >> 1;
            I middle = Next(first, half);
            if (value > *middle)
            {
                first = middle;
                ++first;
                len = len - half - 1;
            }
            else // value <= *middle
            {
                len = half;
            }
        }
        return first;
    }

    public constexpr I LowerBound<I, T, R>(I first, I last, const T& value, R r) where I is ForwardIterator and T is I.ValueType and R is Relation and R.Domain is I.ValueType
    {
        long len = Distance(first, last);
        while (len > 0)
        {
            long half = len >> 1;
            I middle = Next(first, half);
            if (r(*middle, value)) // value > *middle
            {
                first = middle;
                ++first;
                len = len - half - 1;
            }
            else // value <= *middle
            {
                len = half;
            }
        }
        return first;
    }

    public constexpr I UpperBound<I, T>(I first, I last, const T& value) where I is ForwardIterator and TotallyOrdered<T, I.ValueType>
    {
        long len = Distance(first, last);
        while (len > 0)
        {
            long half = len >> 1;
            I middle = Next(first, half);
            if (value < *middle)
            {
                len = half;
            }
            else // value >= *middle
            {
                first = middle;
                ++first;
                len = len - half - 1;
            }
        }
        return first;
    }

    public constexpr I UpperBound<I, T, R>(I first, I last, const T& value, R r) where I is ForwardIterator and T is I.ValueType and R is Relation and R.Domain is I.ValueType
    {
        long len = Distance(first, last);
        while (len > 0)
        {
            long half = len >> 1;
            I middle = Next(first, half);
            if (r(value, *middle)) // value < *middle
            {
                len = half;
            }
            else // value >= *middle
            {
                first = middle;
                ++first;
                len = len - half - 1;
            }
        }
        return first;
    }

    public constexpr Pair<I, I> EqualRange<I, T>(I first, I last, const T& value) where I is ForwardIterator and TotallyOrdered<T, I.ValueType>
    {
        long len = Distance(first, last);
        while (len > 0)
        {
            long half = len >> 1;
            I middle = Next(first, half);
            if (*middle < value)
            {
                first = middle;
                ++first;
                len = len - half - 1;
            }
            else if (value < *middle)
            {
                len = half;
            }
            else
            {
                I left = LowerBound(first, middle, value);
                I end = Next(first, len);
                ++middle;
                I right = UpperBound(middle, end, value);
                return Pair<I, I>(left, right);
            }
        }
        return Pair<I, I>(first, first);
    }

    public constexpr Pair<I, I> EqualRange<I, T, R>(I first, I last, const T& value, R r) where I is ForwardIterator and T is I.ValueType and R is Relation and R.Domain is I.ValueType
    {
        long len = Distance(first, last);
        while (len > 0)
        {
            long half = len >> 1;
            I middle = Next(first, half);
            if (r(*middle, value))
            {
                first = middle;
                ++first;
                len = len - half - 1;
            }
            else if (r(value, *middle))
            {
                len = half;
            }
            else
            {
                I left = LowerBound(first, middle, value, r);
                I end = Next(first, len);
                ++middle;
                I right = UpperBound(middle, end, value, r);
                return Pair<I, I>(left, right);
            }
        }
        return Pair<I, I>(first, first);
    }

    public constexpr I Find<I, T>(I begin, I end, const T& value) where I is InputIterator and T is Semiregular and EqualityComparable<T, I.ValueType>
    {
        while (begin != end)
        {
            if (*begin == value)
            {
                return begin;
            }
            ++begin;
        }
        return end;
    }

    public constexpr I Find<I, P>(I begin, I end, P p) where I is InputIterator and P is UnaryPredicate and P.ArgumentType is I.ValueType
    {
        while (begin != end)
        {
            if (p(*begin))
            {
                return begin;
            }
            ++begin;
        }
        return end;
    }

    public constexpr long Count<I, T>(I begin, I end, const T& value) where I is InputIterator and T is Semiregular and EqualityComparable<T, I.ValueType>
    {
        long count = 0;
        while (begin != end)
        {
            if (*begin == value)
            {
                ++count;
            }
            ++begin;
        }
        return count;
    }

    public constexpr long Count<I, P>(I begin, I end, P p) where I is InputIterator and P is UnaryPredicate and P.ArgumentType is I.ValueType
    {
        long count = 0;
        while (begin != end)
        {
            if (p(*begin))
            {
                ++count;
            }
            ++begin;
        }
        return count;
    }

    public constexpr I Remove<I, T>(I begin, I end, const T& value) where I is ForwardIterator and T is Semiregular and EqualityComparable<T, I.ValueType>
    {
        begin = Find(begin, end, value);
        if (begin != end)
        {
            for (I it = begin; ++it != end;)
            {
                if (!(*it == value))
                {
                    *begin++ = Rvalue(*it);
                }
            }
        }
        return begin;
    }

    public constexpr I Remove<I, P>(I begin, I end, P p) where I is ForwardIterator and P is UnaryPredicate and P.ArgumentType is I.ValueType
    {
        begin = Find(begin, end, p);
        if (begin != end)
        {
            for (auto it = begin; ++it != end;)
            {
                if (!p(*it))
                {
                    *begin++ = Rvalue(*it);
                }
            }
        }
        return begin;
    }

    public void Fill<I, T>(I begin, I end, const T& value) where T is Semiregular and I is ForwardIterator and I.ValueType is T
    {
        while (begin != end)
        {
            *begin = value;
            ++begin;
        }
    }

    public T Accumulate<I, T, Op>(I begin, I end, T init, Op op) where I is InputIterator and T is Semiregular and Op is BinaryOperation and Op.FirstArgumentType is T and Op.SecondArgumentType is I.ValueType
    {
        while (begin != end)
        {
            init = op(init, *begin);
            ++begin;
        }
        return init;
    }

    public constexpr F ForEach<I, F>(I begin, I end, F f) where I is InputIterator and F is UnaryFunction and F.ArgumentType is I.ValueType
    {
        while (begin != end)
        {
            f(*begin);
            ++begin;
        }
        return f;
    }

    public O Transform<I, O, F>(I begin, I end, O to, F fun)
        where I is InputIterator and O is OutputIterator and F is UnaryFunction and F.ArgumentType is I.ValueType and CopyAssignable<O.ValueType, F.ResultType>
    {
        while (begin != end)
        {
            *to = fun(*begin);
            ++begin;
            ++to;
        }
        return to;
    }

    public O Transform<I1, I2, O, F>(I1 begin1, I1 end1, I2 begin2, O to, F fun)
        where I1 is InputIterator and I2 is InputIterator and O is OutputIterator and F is BinaryFunction and F.FirstArgumentType is I1.ValueType and
            F.SecondArgumentType is I2.ValueType and CopyAssignable<O.ValueType, F.ResultType>
    {
        while (begin1 != end1)
        {
            *to = fun(*begin1, *begin2);
            ++begin1;
            ++begin2;
            ++to;
        }
        return to;
    }
    
    public long Log2(long n)
    {
        long k = 0;
        while (n > 1)
        {
            n = n >> 1;
            ++k;
        }
        return k;
    }

    public const T& Median<T, R>(const T& a, const T& b, const T& c, R r) where R is Relation
    {
        if (r(a, b))
        {
            if (r(b, c))
            {
                return b;
            }
            else if (r(a, c))
            {
                return c;
            }
            else
            {
                return a;
            }
        }
        else if (r(a, c))
        {
            return a;
        }
        else if (r(b, c))
        {
            return c;
        }
        else
        {
            return b;
        }
    }

    public I UnguardedPartition<I, R, T>(I begin, I end, const T& pivot, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType and T is I.ValueType
    {
        while (true)
        {
            while (r(*begin, pivot))
            {
                ++begin;
            }
            --end;
            while (r(pivot, *end))
            {
                --end;
            }
            if (!(begin < end))
            {
                return begin;
            }
            Swap(*begin, *end);
            ++begin;
        }
        return begin;
    }

    public void PushHeap<I, T, R>(I begin, long holeIndex, long topIndex, const T& value, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType and T is I.ValueType and T is Copyable
    {
        long parent = (holeIndex - 1) / 2;
        while (holeIndex > topIndex && r(*(begin + parent), value))
        {
            I p = begin + holeIndex;
            *p = *(begin + parent);
            holeIndex = parent;
            parent = (holeIndex - 1) / 2;
        }
        I p = begin + holeIndex;
        *p = value;
    }

    public void PushHeap<I, T, R>(I begin, long holeIndex, long topIndex, T& value, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType and T is I.ValueType and T is Movable
    {
        long parent = (holeIndex - 1) / 2;
        while (holeIndex > topIndex && r(*(begin + parent), value))
        {
            I p = begin + holeIndex;
            *p = Rvalue(*(begin + parent));
            holeIndex = parent;
            parent = (holeIndex - 1) / 2;
        }
        I p = begin + holeIndex;
        *p = Rvalue(value);
    }

    public void AdjustHeap<I, T, R>(I begin, long holeIndex, long len, const T& value, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType and T is I.ValueType and T is Copyable
    {
        long topIndex = holeIndex;
        long secondChild = 2 * holeIndex + 2;
        while (secondChild < len)
        {
            if (r(*(begin + secondChild), *(begin + (secondChild - 1))))
            {
                --secondChild;
            }
            I p = begin + holeIndex;
            *p = *(begin + secondChild);
            holeIndex = secondChild;
            secondChild = 2 * (secondChild + 1);
        }
        if (secondChild == len)
        {
            I p = begin + holeIndex;
            *p = *(begin + (secondChild - 1));
            holeIndex = secondChild - 1;
        }
        PushHeap(begin, holeIndex, topIndex, value, r);
    }

    public void AdjustHeap<I, T, R>(I begin, long holeIndex, long len, T& value, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType and T is I.ValueType and T is Movable
    {
        long topIndex = holeIndex;
        long secondChild = 2 * holeIndex + 2;
        while (secondChild < len)
        {
            if (r(*(begin + secondChild), *(begin + (secondChild - 1))))
            {
                --secondChild;
            }
            I p = begin + holeIndex;
            *p = Rvalue(*(begin + secondChild));
            holeIndex = secondChild;
            secondChild = 2 * (secondChild + 1);
        }
        if (secondChild == len)
        {
            I p = begin + holeIndex;
            *p = Rvalue(*(begin + (secondChild - 1)));
            holeIndex = secondChild - 1;
        }
        PushHeap(begin, holeIndex, topIndex, value, r);
    }
    public void PopHeap<I, T, R>(I begin, I end, I result, const T& value, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType and T is I.ValueType and T is Copyable
    {
        *result = *begin;
        AdjustHeap(begin, 0, end - begin, value, r);
    }

    public void PopHeap<I, T, R>(I begin, I end, I result, T& value, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType and T is I.ValueType and T is Movable
    {
        *result = Rvalue(*begin);
        AdjustHeap(begin, 0, end - begin, value, r);
    }
    
    public void PopHeap<I, R>(I begin, I end, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType
    {
        PopHeap(begin, end - 1, end - 1, *(end - 1), r);
    }

    public void MakeHeap<I, R>(I begin, I end, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType
    {
        if (end - begin < 2) return;
        long len = end - begin;
        long parent = (len - 2) / 2;
        while (true)
        {
            AdjustHeap(begin, parent, len, *(begin + parent), r);
            if (parent == 0)
            {
                return;
            }
            --parent;
        }
    }

    public void SortHeap<I, R>(I begin, I end, R r)
    {
        while (end - begin > 1)
        {
            PopHeap(begin, end--, r);
        }
    }

    public void PartialSort<I, R>(I begin, I middle, I end, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType
    {
        MakeHeap(begin, middle, r);
        for (I i = middle; i < end; ++i)
        {
            if (r(*i, *begin))
            {
                PopHeap(begin, middle, i, *i, r);
            }
        }
        SortHeap(begin, middle, r);
    }

    public const long insertionSortThreshold = 16;

    public void IntroSortLoop<I, R>(I begin, I end, long depthLimit, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType
    {
        while (end - begin > insertionSortThreshold)
        {
            if (depthLimit == 0)
            {
                PartialSort(begin, end, end, r);
                return;
            }
            --depthLimit;
            I cut = UnguardedPartition(begin, end, Median(*begin, *(begin + (end - begin) / 2), *(end - 1), r), r);
            IntroSortLoop(cut, end, depthLimit, r);
            end = cut;
        }
    }

    public void UnguardedLinearInsert<I, T, R>(I last, const T& value, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType and T is I.ValueType and T is Copyable
    {
        I next = last;
        --next;
        while (r(value, *next))
        {
            *last = *next;
            last = next;
            --next;
        }
        *last = value;
    }

    public void UnguardedLinearInsert<I, T, R>(I last, T&& value, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType and T is I.ValueType and T is Movable
    {
        I next = last;
        --next;
        while (r(value, *next))
        {
            *last = Rvalue(*next);
            last = next;
            --next;
        }
        *last = Rvalue(value);
    }

    public void LinearInsert<I, R>(I first, I last, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType
    {
        auto value = *last;
        if (r(value, *first))
        {
            CopyBackward(first, last, last + 1);
            *first = value;
        }
        else
        {
            UnguardedLinearInsert(last, value, r);
        }
    }

    public void LinearInsert<I, R>(I first, I last, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType and I.ValueType is Movable
    {
        I.ValueType value = Rvalue(*last);
        if (r(value, *first))
        {
            MoveBackward(first, last, last + 1);
            *first = Rvalue(value);
        }
        else
        {
            UnguardedLinearInsert(last, Rvalue(value), r);
        }
    }

    public void InsertionSort<I, R>(I begin, I end, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType
    {
        if (begin == end)
        {
            return;
        }
        for (I i = begin + 1; i != end; ++i)
        {
            LinearInsert(begin, i, r);
        }
    }

    public void InsertionSort<I>(I begin, I end)
        where I is RandomAccessIterator and I.ValueType is TotallyOrdered
    {
        return InsertionSort(begin, end, Less<I.ValueType>());
    }

    public void UnguardedInsertionSort<I, R>(I begin, I end, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType
    {
        for (I i = begin; i != end; ++i)
        {
            UnguardedLinearInsert(i, *i, r);
        }
    }

    public void FinalInsertionSort<I, R>(I begin, I end, R r)
        where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType
    {
        if (end - begin > insertionSortThreshold)
        {
            InsertionSort(begin, begin + insertionSortThreshold, r);
            UnguardedInsertionSort(begin + insertionSortThreshold, end, r);
        }
        else
        {
            InsertionSort(begin, end, r);
        }
    }

    public void Sort<I, R>(I begin, I end, R r) where I is RandomAccessIterator and R is Relation and R.Domain is I.ValueType
    {
        if (begin == end) return;
        IntroSortLoop(begin, end, Log2(end - begin) * 2, r);
        FinalInsertionSort(begin, end, r);
    }

    public inline void Sort<I>(I begin, I end)
        where I is RandomAccessIterator and I.ValueType is TotallyOrdered
    {
        Sort(begin, end, Less<I.ValueType>());
    }

    public inline void Sort<C, R>(C& c, R r)
        where C is RandomAccessContainer and R is Relation and R.Domain is C.Iterator.ValueType
    {
        Sort(c.Begin(), c.End(), r);
    }

    public inline void Sort<C>(C& c)
        where C is RandomAccessContainer and C.Iterator.ValueType is TotallyOrdered
    {
        Sort(c.Begin(), c.End());
    }

    public void Sort<C>(C& c) where C is ForwardContainer and C.Iterator.ValueType is TotallyOrdered
    {
        List<C.ValueType> list;
        Copy(c.CBegin(), c.CEnd(), BackInserter(list));
        Sort(list);
        Copy(list.CBegin(), list.CEnd(), c.Begin());
    }

    public void Sort<C, R>(C& c, R r) where C is ForwardContainer and R is Relation and R.Domain is C.Iterator.ValueType
    {
        List<C.ValueType> list;
        Copy(c.CBegin(), c.CEnd(), BackInserter(list));
        Sort(list, r);
        Copy(list.CBegin(), list.CEnd(), c.Begin());
    }

    public constexpr bool Equal<I1, I2, R>(I1 first1, I1 last1, I2 first2, I2 last2, R r) where I1 is InputIterator and I2 is InputIterator and Relation<R, I1.ValueType, I2.ValueType>
    {
        while (first1 != last1 && first2 != last2)
        {
            if (!r(*first1, *first2))
            {
                return false;
            }
            ++first1;
            ++first2;
        }
        return first1 == last1 && first2 == last2;
    }

    public constexpr inline bool Equal<I1, I2>(I1 first1, I1 last1, I2 first2, I2 last2) where I1 is InputIterator and I2 is InputIterator and EqualityComparable<I1.ValueType, I2.ValueType>
    {
        return Equal(first1, last1, first2, last2, EqualTo<I1.ValueType, I2.ValueType>());
    }

    public constexpr bool LexicographicalCompare<I1, I2, R>(I1 first1, I1 last1, I2 first2, I2 last2, R r)
        where I1 is InputIterator and I2 is InputIterator and Same<I1.ValueType, I2.ValueType> and Relation<R, I1.ValueType, I2.ValueType> and Relation<R, I2.ValueType, I1.ValueType>
    {
        while (first1 != last1 && first2 != last2)
        {
            if (r(*first1, *first2))
            {
                return true;
            }
            if (r(*first2, *first1))
            {
                return false;
            }
            ++first1;
            ++first2;
        }
        return first1 == last1 && first2 != last2;
    }

    public constexpr inline bool LexicographicalCompare<I1, I2>(I1 first1, I1 last1, I2 first2, I2 last2) where I1 is InputIterator and I2 is InputIterator and LessThanComparable<I1.ValueType, I2.ValueType>
    {
        return LexicographicalCompare(first1, last1, first2, last2, Less<I1.ValueType, I2.ValueType>());
    }

    public constexpr I MinElement<I>(I first, I last) where I is ForwardIterator and I.ValueType is TotallyOrdered
    {
        if (first == last)
        {
            return first;
        }
        I minElementPos = first;
        ++first;
        while (first != last)
        {
            if (*first < *minElementPos)
            {
                minElementPos = first;
            }
            ++first;
        }
        return minElementPos;
    }

    public constexpr I MinElement<I, R>(I first, I last, R r) where I is ForwardIterator and R is Relation and R.Domain is I.ValueType
    {
        if (first == last)
        {
            return first;
        }
        I minElementPos = first;
        ++first;
        while (first != last)
        {
            if (r(*first, *minElementPos))
            {
                minElementPos = first;
            }
            ++first;
        }
        return minElementPos;
    }

    public constexpr I MaxElement<I>(I first, I last) where I is ForwardIterator and I.ValueType is TotallyOrdered
    {
        if (first == last)
        {
            return first;
        }
        I maxElementPos = first;
        ++first;
        while (first != last)
        {
            if (*maxElementPos < *first)
            {
                maxElementPos = first;
            }
            ++first;
        }
        return maxElementPos;
    }

    public constexpr I MaxElement<I, R>(I first, I last, R r) where I is ForwardIterator and R is Relation and R.Domain is I.ValueType
    {
        if (first == last)
        {
            return first;
        }
        I maxElementPos = first;
        ++first;
        while (first != last)
        {
            if (r(*maxElementPos, *first))
            {
                maxElementPos = first;
            }
            ++first;
        }
        return maxElementPos;
    }

    public constexpr inline T Abs<T>(const T& x) where T is OrderedAdditiveGroup
    {
        if (x < T(0))
        {
            return -x;
        }
        return x;
    }

    // naive implementation...
    public constexpr U Factorial<U>(U n) where U is UnsignedInteger
    {
        U f = 1u;
        for (U u = 2u; u <= n; ++u)
        {
            f = f * u;
        }
        return f;
    }

    public constexpr T Gcd<T>(T a, T b) where T is EuclideanSemiring
    {
        while (true)
        {
            if (b == T(0)) return a;
            a = a % b;
            if (a == T(0)) return b;
            b = b % a;
        }
    }

    public bool NextPermutation<I>(I begin, I end) where I is BidirectionalIterator and I.ValueType is LessThanComparable
    {
        if (begin == end)
        {
            return false;
        }
        I i = begin;
        ++i;
        if (i == end)
        {
            return false;
        }
        i = end;
        --i;
        while (true)
        {
            I ii = i;
            --i;
            if (*i < *ii)
            {
                I j = end;
                --j;
                while (*i >= *j)
                {
                    --j;
                }
                Swap(*i, *j);
                Reverse(ii, end);
                return true;
            }
            if (i == begin)
            {
                Reverse(begin, end);
                return false;
            }
        }
    }

    public bool NextPermutation<I, R>(I begin, I end, R r) where I is BidirectionalIterator and R is Relation and R.Domain is I.ValueType
    {
        if (begin == end)
        {
            return false;
        }
        I i = begin;
        ++i;
        if (i == end)
        {
            return false;
        }
        i = end;
        --i;
        while (true)
        {
            I ii = i;
            --i;
            if (r(*i, *ii))
            {
                I j = end;
                --j;
                while (!r(*i, *j))
                {
                    --j;
                }
                Swap(*i, *j);
                Reverse(ii, end);
                return true;
            }
            if (i == begin)
            {
                Reverse(begin, end);
                return false;
            }
        }
    }

    public bool PrevPermutation<I>(I begin, I end) where I is BidirectionalIterator and I.ValueType is LessThanComparable
    {
        if (begin == end)
        {
            return false;
        }
        I i = begin;
        ++i;
        if (i == end)
        {
            return false;
        }
        i = end;
        --i;
        while (true)
        {
            I ii = i;
            --i;
            if (*ii < *i)
            {
                I j = end;
                --j;
                while (*j >= *i)
                {
                    --j;
                }
                Swap(*i, *j);
                Reverse(ii, end);
                return true;
            }
            if (i == begin)
            {
                Reverse(begin, end);
                return false;
            }
        }
    }

    public bool PrevPermutation<I, R>(I begin, I end, R r) where I is BidirectionalIterator and R is Relation and R.Domain is I.ValueType
    {
        if (begin == end)
        {
            return false;
        }
        I i = begin;
        ++i;
        if (i == end)
        {
            return false;
        }
        i = end;
        --i;
        while (true)
        {
            I ii = i;
            --i;
            if (r(*ii, *i))
            {
                I j = end;
                --j;
                while (!r(*j, *i))
                {
                    --j;
                }
                Swap(*i, *j);
                Reverse(ii, end);
                return true;
            }
            if (i == begin)
            {
                Reverse(begin, end);
                return false;
            }
        }
    }

    public inline void InitRand(uint seed)
    {
        RtmInitRand(seed);
    }

    public inline uint Random()
    {
        return RtmRandom();
    }

    public inline ulong Random64()
    {
        return RtmRandom64();
    }

    public inline uint RandomNumber(uint n)
    {
        return Random() % n;
    }

    public void RandomShuffle<I>(I begin, I end) where I is RandomAccessIterator
    {
        if (begin == end) return;
        for (I i = begin + 1; i != end; ++i)
        {
            long d = (i - begin) + 1;
            long r = cast<long>(RandomNumber(cast<uint>(d)));
            I j = begin + r;
            Swap(*i, *j);
        }
    }

    public I AdjacentFind<I, R>(I begin, I end, R r) where I is ForwardIterator and R is Relation and R.Domain is I.ValueType
    {
        if (begin != end)
        {
            I i = begin;
            ++i;
            while (i != end)
            {
                if (r(*begin, *i))
                {
                    return begin;
                }
                begin = i;
                ++i;
            }
        }
        return end;
    }

    public I AdjacentFind<I>(I begin, I end) where I is ForwardIterator
    {
        return AdjacentFind(begin, end, EqualTo<I.ValueType>());
    }

    public I Unique<I, R>(I begin, I end, R r) where I is ForwardIterator and R is Relation and R.Domain is I.ValueType
    {
        begin = AdjacentFind(begin, end, r);
        if (begin != end)
        {
            I i = begin;
            ++i;
            ++i;
            while (i != end)
            {
                if (!r(*begin, *i))
                {
                    *++begin = Rvalue(*i);
                }
                ++i;
            }
            ++begin;
        }
        return begin;
    }

    public I Unique<I>(I begin, I end) where I is ForwardIterator
    {
        return Unique(begin, end, EqualTo<I.ValueType>());
    }
}
